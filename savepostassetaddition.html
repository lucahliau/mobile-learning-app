<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Learning Tool</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.4.2/math.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
            <style>
                
                * {
                    margin: 0;
                    padding: 0;
                    box-sizing: border-box;
                }
        
                body {
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    /* CHANGE: Switched to a light gray background */
                    background: #f9fafb;
                    min-height: 100vh;
                    /* CHANGE: Switched to a dark gray for primary text */
                    color: #374151;
                    overflow: hidden;
                }
                /* --- NEW: View & Landing Page Styles --- */
                .view {
                    width: 100%;
                    height: 100vh;
                    display: none; /* Keep hidden by default */
                }
        
                .view.active {
                    display: flex; /* Show the active view */
                }

                /* --- CHANGE 1: BREADCRUMB HEIGHT ADJUSTMENT --- */
.breadcrumb {
    /* We reduce the vertical padding from 15px to 10px to match the nav buttons */
    padding: 10px 25px; 
}

/* --- CHANGE 2: STYLES FOR THE NEW DELETE BUTTON --- */

/* Style for the new delete button in the nav bar */
#deleteTopicBtn {
    background: #ffffff;
    color: #ef4444; /* A nice red color for the icon */
    border: 2px solid #e5e7eb;
    padding: 10px; /* Make padding equal for a square look */
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    margin-left: 15px; /* Add some space between it and the breadcrumb */
}

#deleteTopicBtn:hover {
    background: #fee2e2; /* A light red background on hover */
    border-color: #ef4444;
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(239, 68, 68, 0.2);
}

/* Style for the 'Confirm Delete' button in the modal */
.modal-btn.delete {
    background: #dc2626; /* A strong red for the confirmation button */
    color: white;
}
.modal-btn.delete:hover {
    background: #b91c1c; /* A darker red on hover */
}
        
                #landingView {
                    flex-direction: column;
                    align-items: center;
                    padding: 40px;
                    overflow-y: auto;
                }
        
                .landing-header {
                    width: 100%;
                    max-width: 1200px;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    margin-bottom: 40px;
                    flex-shrink: 0;
                }
        
                .landing-header h1 {
                    font-size: 32px;
                    font-weight: 700;
                    /* CHANGE: Darker text for headers */
                    color: #11182c;
                }
        
                .new-topic-btn {
                    background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
                    color: white;
                    border: none;
                    padding: 12px 24px;
                    border-radius: 10px;
                    cursor: pointer;
                    font-size: 16px;
                    font-weight: 600;
                    transition: all 0.3s ease;
                    display: inline-flex;
                    align-items: center;
                    gap: 8px;
                }
        
                .new-topic-btn:hover {
                    transform: translateY(-2px);
                    box-shadow: 0 5px 15px rgba(99, 102, 241, 0.4);
                }
        
                #topicGrid {
                    width: 100%;
                    max-width: 1200px;
                    display: grid;
                    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
                    gap: 20px;
                }
                #topicGrid {
    width: 100%;
    max-width: 1200px;
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 20px;
}
/* --- Add this new rule to your <style> block --- */
    #topicGrid.empty {
    display: flex;
    justify-content: center;
    align-items: center;
    /* Sets the grid to take up a significant portion of the view height */
    min-height: 60vh; 
}

/* --- ADD THESE NEW STYLES FOR THE TOPIC CARD --- */
.topic-card {
    background: #ffffff; /* White background for the card */
    border: 1px solid #e5e7eb; /* Light gray border for the outline */
    border-radius: 16px; /* Rounded corners */
    padding: 25px; /* Space inside the card */
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05); /* Subtle shadow */
}

.topic-card:hover {
    transform: translateY(-5px); /* Lifts the card up on hover */
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1); /* Stronger shadow on hover */
    border-color: #6366f1; /* Purple border on hover */
}

.topic-card h2 {
    font-size: 20px;
    color: #11182c; /* Dark text for the title */
    margin-bottom: 8px;
}

.topic-card p {
    font-size: 14px;
    color: #6b7280; /* Medium gray for the description */
    line-height: 1.4;
}
        
                /* --- NEW: Modal Styles --- */
                .modal-overlay {
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.5); /* Kept dark overlay for contrast */
                    backdrop-filter: blur(5px);
                    display: none; /* Use display instead of visibility */
                    justify-content: center;
                    align-items: center;
                    z-index: 2000;
                    animation: fadeIn 0.3s ease;
                }
        
                .modal-overlay.active {
                    display: flex; /* Use flex to center the content */
                }
        
                .modal-content {
                    /* CHANGE: White modal background */
                    background: #ffffff;
                    padding: 40px;
                    border-radius: 20px;
                    width: 90%;
                    max-width: 500px;
                    /* CHANGE: Light border */
                    border: 1px solid #e5e7eb;
                    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
                    animation: fadeIn 0.3s ease; /* Match existing fadeIn */
                }
        
                .modal-content h2 {
                    font-size: 24px;
                    margin-bottom: 15px;
                    text-align: center;
                    /* CHANGE: Darker text for modal headers */
                    color: #11182c;
                }
        
                .modal-content label {
                    display: block;
                    font-size: 14px;
                    /* CHANGE: Medium gray for labels */
                    color: #6b7280;
                    margin-bottom: 8px;
                }
        
                .modal-input {
                    width: 100%;
                    padding: 12px 15px;
                    /* CHANGE: Lighter background for input */
                    background: #f3f4f6;
                    /* CHANGE: Light border */
                    border: 1px solid #d1d5db;
                    /* CHANGE: Dark text for input */
                    color: #11182c;
                    border-radius: 8px;
                    font-size: 16px;
                    margin-bottom: 25px;
                    transition: all 0.2s ease;
                }
        
                .modal-input:focus {
                    outline: none;
                    border-color: #6366f1;
                    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
                }
        
                .sophistication-slider {
                    display: flex;
                    border-radius: 8px;
                    overflow: hidden;
                    /* CHANGE: Light border */
                    border: 1px solid #d1d5db;
                    margin-bottom: 30px;
                }
        
                .sophistication-option {
                    flex: 1;
                    text-align: center;
                    padding: 12px;
                    cursor: pointer;
                    /* CHANGE: Lighter background for sophistication options */
                    background: #f3f4f6;
                    /* CHANGE: Medium gray text */
                    color: #6b7280;
                    transition: background 0.2s ease;
                    font-weight: 500;
                }
        
                .sophistication-option.active {
                    background: #6366f1;
                    color: white;
                    font-weight: 600;
                }
        
                .modal-actions {
                    display: flex;
                    justify-content: center;
                    gap: 15px;
                }
        
                .modal-btn {
                    padding: 10px 20px;
                    border: none;
                    border-radius: 8px;
                    font-size: 16px;
                    font-weight: 600;
                    cursor: pointer;
                    transition: background 0.2s ease;
                }
        
                .modal-btn.cancel {
                    /* CHANGE: Light gray background for cancel button */
                    background: #e5e7eb;
                    /* CHANGE: Dark gray text */
                    color: #374151;
                }
                .modal-btn.cancel:hover {
                    /* CHANGE: Slightly darker gray on hover */
                    background: #d1d5db;
                }
        
                .modal-btn.submit {
                    background: #6366f1;
                    color: white;
                }
                .modal-btn.submit:hover {
                    background: #4f46e5;
                }
        
                .app-wrapper {
                    display: flex;
                    width: 100%;
                    height: 100vh;
                }
        
                .tree-sidebar {
                    width: 320px;
                    /* CHANGE: White background for sidebar */
                    background: #ffffff;
                    box-shadow: 4px 0 20px rgba(0, 0, 0, 0.05);
                    padding: 10px;
                    overflow-x: auto;
                    overflow-y: auto;
                    /* CHANGE: Light border */
                    border-right: 1px solid #e5e7eb;
                    display: flex;
                    flex-direction: column;
                }
        
                .tree-sidebar h3 {
                    font-size: 18px;
                    margin-bottom: 20px;
                    /* CHANGE: Dark text for sidebar title */
                    color: #11182c;
                    font-weight: 600;
                    flex-shrink: 0;
                }
        
                .tree-container {
                    padding: 10px;
                    overflow-x: auto;
                    overflow-y: auto;
                    flex: 1;
                }
        
                .tree-node {
                    margin: 5px 0;
                    position: relative;
                    white-space: nowrap;
                }
        
                .tree-node::before {
                    content: '';
                    position: absolute;
                    left: -15px;
                    top: 16px;
                    width: 10px;
                    height: 1px;
                    /* CHANGE: Light gray for tree lines */
                    background: #d1d5db;
                }
        
                .tree-node-content {
                    cursor: pointer;
                    padding: 8px 15px;
                    border-radius: 8px;
                    font-size: 14px;
                    transition: all 0.2s ease;
                    display: inline-flex;
                    align-items: center;
                    gap: 8px;
                    /* CHANGE: Lighter background for tree nodes */
                    background: #f3f4f6;
                    /* CHANGE: Light border */
                    border: 1px solid #e5e7eb;
                    max-width: 250px;
                    overflow: hidden;
                    text-overflow: ellipsis;
                    white-space: nowrap;
                    /* CHANGE: Medium gray text for tree nodes */
                    color: #4b5563;
                }
        
                .tree-node-content:hover {
                    /* CHANGE: Lighter background on hover */
                    background: #e5e7eb;
                    /* CHANGE: Slightly darker border on hover */
                    border-color: #d1d5db;
                    transform: translateX(3px);
                    /* CHANGE: Darker text on hover */
                    color: #11182c;
                }
        
                .tree-node-content.active {
                    background: #6366f1;
                    color: white;
                    border-color: transparent;
                }
        
                .tree-node-icon {
                    flex-shrink: 0;
                    font-size: 16px;
                }
        
                .tree-node-text {
                    overflow: hidden;
                    text-overflow: ellipsis;
                    white-space: nowrap;
                }
        
                .tree-children {
                    margin-left: 25px;
                    margin-top: 5px;
                    /* CHANGE: Light gray border for tree children */
                    border-left: 1px solid #d1d5db;
                    padding-left: 15px;
                }
        
                .main-container {
                    flex: 1;
                    display: flex;
                    flex-direction: column;
                    padding: 20px;
                    overflow: hidden;
                    height: 100vh;
                }
        
                .app-container {
                    flex: 1;
                    display: flex;
                    flex-direction: column;
                    max-width: 1000px;
                    width: 100%;
                    margin: 0 auto;
                    overflow: hidden;
                }
        
                .navigation-controls {
                    display: flex;
                    gap: 15px;
                    margin-bottom: 20px;
                    align-items: center;
                    flex-shrink: 0;
                }
        
                .nav-button {
                    /* CHANGE: Lighter background for nav buttons */
                    background: #ffffff;
                    /* CHANGE: Dark gray text */
                    color: #4b5563;
                    /* CHANGE: Light border */
                    border: 2px solid #e5e7eb;
                    padding: 10px 20px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-size: 16px;
                    font-weight: 600;
                    transition: all 0.3s ease;
                    display: inline-flex;
                    align-items: center;
                    gap: 8px;
                }
        
                .nav-button:hover:not(:disabled) {
                    /* CHANGE: Lighter background on hover */
                    background: #f3f4f6;
                    /* CHANGE: Darker text on hover */
                    color: #11182c;
                    transform: translateY(-2px);
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
                }
        
                .nav-button:disabled {
                    opacity: 0.5;
                    cursor: not-allowed;
                }
        
                .breadcrumb {
                    flex: 1;
                    /* CHANGE: White background for breadcrumb */
                    background: #ffffff;
                    padding: 10px 25px;
                    border-radius: 12px;
                    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
                    display: flex;
                    align-items: center;
                    gap: 10px;
                    overflow-x: auto;
                    white-space: nowrap;
                    /* CHANGE: Light border */
                    border: 1px solid #e5e7eb;
                }
        
                .breadcrumb-item {
                    /* CHANGE: Medium gray for breadcrumb items */
                    color: #6b7280;
                    font-size: 14px;
                    padding: 5px 10px;
                    border-radius: 6px;
                    flex-shrink: 0;
                }
        
                .breadcrumb-separator {
                    /* CHANGE: Lighter gray for separator */
                    color: #9ca3af;
                    font-size: 18px;
                    flex-shrink: 0;
                }
        
                .breadcrumb-item.active {
                    /* CHANGE: Dark text for active item */
                    color: #11182c;
                    font-weight: 600;
                    /* CHANGE: Light gray background for active item */
                    background: #f3f4f6;
                }
        
                .main-content {
                    flex: 1;
                    /* CHANGE: White background for main content */
                    background: #ffffff;
                    border-radius: 20px;
                    padding: 40px;
                    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.05);
                    overflow-y: auto;
                    overflow-x: hidden;
                    animation: fadeIn 0.5s ease;
                    /* CHANGE: Light border */
                    border: 1px solid #e5e7eb;
                }
        
                @keyframes fadeIn {
                    from {
                        opacity: 0;
                        transform: translateY(20px);
                    }
                    to {
                        opacity: 1;
                        transform: translateY(0);
                    }
                }
        
                .welcome-message {
                    text-align: center;
                    padding: 60px 20px;
                }
        
                .welcome-message h1 {
                    font-size: 48px;
                    background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
                    -webkit-background-clip: text;
                    -webkit-text-fill-color: transparent;
                    margin-bottom: 20px;
                    font-weight: 800;
                }
        
                .welcome-message p {
                    font-size: 20px;
                    /* CHANGE: Medium gray for welcome message paragraph */
                    color: #6b7280;
                    margin-bottom: 40px;
                }
        
                .topic-overview {
                    margin-bottom: 30px;
                    padding: 25px;
                    /* CHANGE: Very light, almost white background for topic overview */
                    background: #f9fafb;
                    /* CHANGE: Dark text */
                    color: #1f2937;
                    border-radius: 16px;
                    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
                    /* CHANGE: Light border */
                    border: 1px solid #e5e7eb;
                }
        
                .topic-overview h2 {
                    font-size: 28px;
                    margin-bottom: 15px;
                    font-weight: 700;
                }
        
                .topic-overview p, .topic-overview div {
                    font-size: 18px;
                    line-height: 1.6;
                    /* CHANGE: Standard dark gray text */
                    color: #374151;
                }
        
                .topic-overview ul {
                    list-style-type: disc;
                    margin: 15px 0;
                    padding-left: 30px;
                }
        
                .topic-overview li {
                    margin: 8px 0;
                    line-height: 1.6;
                    /* CHANGE: Standard dark gray text */
                    color: #374151;
                }
        
                .cards-grid {
                    display: grid;
                    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
                    gap: 20px;
                    margin-top: 30px;
                }
        
                .card {
                    /* CHANGE: White background for cards */
                    background: #ffffff;
                    border-radius: 16px;
                    padding: 25px;
                    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
                    cursor: pointer;
                    transition: all 0.3s ease;
                    /* CHANGE: Light border */
                    border: 2px solid #e5e7eb;
                    position: relative;
                    overflow: hidden;
                }
        
                /* --- CARD STATUS INDICATOR STYLES --- */
        
                .status-indicator {
                    position: absolute;
                    top: 15px;
                    right: 15px;
                    width: 20px;
                    height: 20px;
                    border-radius: 50%;
                    background-color: transparent;
                    /* CHANGE: Lighter border for indicator */
                    border: 2px solid #d1d5db; /* Hollow circle style */
                    transition: all 0.3s ease;
                }
        
                .status-indicator.read {
                    background-color: #22c55e; /* Green background for 'read' state */
                    border-color: #22c55e;
                }
        
                /* The white checkmark icon */
                .status-indicator.read::before {
                    content: '';
                    display: block;
                    width: 100%;
                    height: 100%;
                    /* Embedded SVG for the checkmark - clean and scalable */
                    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='3' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='20 6 9 17 4 12'%3E%3C/polyline%3E%3C/svg%3E");
                    background-size: 60%;
                    background-position: center;
                    background-repeat: no-repeat;
                }
        
                .card::before {
                    content: '';
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 4px;
                    background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
                    transform: scaleX(0);
                    transform-origin: left;
                    transition: transform 0.3s ease;
                }
        
                .card:hover {
                    transform: translateY(-5px);
                    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
                    border-color: #6366f1;
                    /* CHANGE: No background change needed on hover, or a very subtle one */
                }
        
                .card:hover::before {
                    transform: scaleX(1);
                }
        
                .card h3 {
                    font-size: 20px;
                    margin-bottom: 8px;
                    color: #11182c;
                    display: flex;
                    align-items: center;
                    justify-content: space-between;
                    /* ADD THIS LINE to prevent text from flowing under the icon */
                    padding-right: 25px; 
                }
        
                .card-icon {
                    width: 20px;
                    height: 20px;
                    color: #6366f1;
                    transition: transform 0.3s ease;
                }
        
                .card:hover .card-icon {
                    transform: translateX(5px);
                }
        
                .card p {
                    /* CHANGE: Medium gray for card paragraphs */
                    color: #6b7280;
                    line-height: 1.4;
                    font-size: 14px;
                }
        
                .content-section {
                    margin-bottom: 30px;
                }
        
                .content-section h3 {
                    font-size: 24px;
                    /* CHANGE: Darker text for section headers */
                    color: #11182c;
                    margin-bottom: 15px;
                    font-weight: 600;
                }
        
                .content-section p {
                    font-size: 16px;
                    line-height: 1.8;
                    /* CHANGE: Standard dark gray for paragraphs */
                    color: #374151;
                    margin-bottom: 15px;
                    white-space: pre-wrap;
                }
        
                .tell-me-more-button {
                    background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
                    color: white;
                    border: none;
                    padding: 15px 30px;
                    border-radius: 12px;
                    cursor: pointer;
                    font-size: 16px;
                    font-weight: 600;
                    transition: all 0.3s ease;
                    display: inline-flex;
                    align-items: center;
                    gap: 10px;
                    margin: 20px 0;
                }
                .quiz-me-more-button {
    background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
    color: white;
    border: none;
    padding: 15px 10px;
    border-radius: 12px;
    cursor: pointer;
    font-size: 16px;
    font-weight: 600;
    transition: all 0.3s ease;
    display: inline-flex; /* Changed back to inline-flex */
    align-items: center;
    gap: 10px;
    margin: 0; /* The new wrapper will handle margins */
}

/* Add this new rule right after the one above */
.quiz-me-more-button:disabled {
    background: #e5e7eb; /* Light gray background */
    color: #9ca3af;   /* Muted text color */
    cursor: not-allowed;
}
        
                .tell-me-more-button:hover {
                    transform: translateY(-2px);
                    box-shadow: 0 5px 15px rgba(99, 102, 241, 0.4);
                }
        
                .chat-container {
                    margin-top: 20px; /* Adds space between the main content and this container */
                    border-radius: 20px; /* Rounds the corners of the container */
                    padding: 20px;
                    background: #ffffff;
                    border: 1px solid #e5e7eb; /* A full border looks better with rounded corners */
                    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05); /* A subtle shadow to match other elements */
                    flex-shrink: 0; 
                }
        
                .chat-input-wrapper {
                    max-width: 1200px;
                    margin: 0 auto;
                    display: flex;
                    gap: 15px;
                    align-items: center;
                }
        
                .chat-input {
                    flex: 1;
                    padding: 15px 20px;
                    /* CHANGE: Light border for chat input */
                    border: 2px solid #d1d5db;
                    border-radius: 12px;
                    font-size: 16px;
                    outline: none;
                    transition: all 0.3s ease;
                    /* CHANGE: Light gray background */
                    background: #f9fafb;
                    /* CHANGE: Dark text color */
                    color: #11182c;
                }
        
                .chat-input:focus {
                    border-color: #6366f1;
                    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
                }
        
                .chat-input::placeholder {
                    /* CHANGE: Medium gray for placeholder */
                    color: #9ca3af;
                }
        
                .send-button {
                    padding: 15px 30px;
                    background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
                    color: white;
                    border: none;
                    border-radius: 12px;
                    cursor: pointer;
                    font-size: 16px;
                    font-weight: 600;
                    transition: all 0.3s ease;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                }
        
                .send-button:hover {
                    transform: translateY(-2px);
                    box-shadow: 0 5px 15px rgba(99, 102, 241, 0.4);
                }
        
                .send-button:disabled {
                    background: #d1d5db;
                    cursor: not-allowed;
                    transform: none;
                    box-shadow: none;
                }
        
                .loading-spinner {
                    display: inline-block;
                    width: 16px;
                    height: 16px;
                    border: 2px solid transparent;
                    border-top-color: white;
                    border-radius: 50%;
                    animation: spin 0.8s linear infinite;
                }
        
                @keyframes spin {
                    to { transform: rotate(360deg); }
                }
        
                .error-message {
                    background: #dc2626;
                    color: white;
                    padding: 15px 20px;
                    border-radius: 8px;
                    margin-bottom: 15px;
                    display: none;
                    animation: shake 0.5s ease;
                }
        
                @keyframes shake {
                    0%, 100% { transform: translateX(0); }
                    25% { transform: translateX(-10px); }
                    75% { transform: translateX(10px); }
                }
        
                strong {
                    font-weight: 600;
                    /* CHANGE: Dark text for strong elements */
                    color: #11182c;
                }
        
                em {
                    font-style: italic;
                    /* CHANGE: Medium gray for emphasized text */
                    color: #6b7280;
                }
        
                ul, ol {
                    margin: 15px 0;
                    padding-left: 30px;
                    /* CHANGE: Dark gray text for lists */
                    color: #374151;
                }
        
                li {
                    margin: 8px 0;
                    line-height: 1.6;
                    /* CHANGE: Dark gray text for list items */
                    color: #374151;
                }
        
                /* --- NEW STYLES FOR TERM DEFINITIONS --- */
        
                .technical-term {
                    text-decoration: none; /* This removes the underline */
                    color: #a78bfa; /* This keeps the purple color you like */
                    cursor: help; /* Changes the mouse cursor to a question mark */
                    position: relative; /* Essential for positioning the tooltip */
                    display: inline-block; /* Ensures the position property works correctly */
                }
        
                .term-tooltip {
                    visibility: hidden; /* Hidden by default */
                    width: 300px;
                    /* CHANGE: White background for tooltip */
                    background-color: #ffffff;
                    /* CHANGE: Dark text for tooltip */
                    color: #1f2937;
                    text-align: left;
                    border-radius: 8px;
                    padding: 15px;
                    position: absolute;
                    z-index: 10;
                    bottom: 125%; /* Position above the term */
                    left: 50%;
                    margin-left: -150px; /* Center the tooltip */
                    opacity: 0;
                    transition: opacity 0.3s;
                    /* CHANGE: Light border for tooltip */
                    border: 1px solid #e5e7eb;
                    box-shadow: 0 5px 15px rgba(0,0,0,0.1);
                    font-size: 14px; /* Ensure tooltip text is readable */
                    line-height: 1.5;
                    text-decoration: none; /* Remove underline from the tooltip text */
                    pointer-events: none; /* Tooltip itself shouldn't be interactive */
                }
                
                /* Show the tooltip on hover */
                /* This class will be toggled by JavaScript to show the tooltip */
                .term-tooltip.visible {
                    visibility: visible;
                    opacity: 1;
                }
        
                /* --- END OF NEW STYLES --- */
                /* --- STYLES FOR RESIZABLE SIDEBAR --- */
        
                .resizer {
                    flex-shrink: 0;
                    width: 5px;
                    cursor: col-resize; /* The cursor indicates it can be resized horizontally */
                    /* CHANGE: Main background color */
                    background-color: #f9fafb; 
                    transition: background-color 0.2s ease;
                }
        
                .resizer:hover {
                    background-color: #6366f1; /* Highlight on hover */
                }
        
                .tree-sidebar {
                    /* This ensures the sidebar doesn't shrink on its own */
                    flex-shrink: 0;
                    width: 320px; /* This will be our default and minimum width */
                }
        
                /* --- END OF RESIZER STYLES --- */
                /* --- TREE STATUS INDICATOR STYLES --- */
        
                .tree-status-indicator {
                    display: inline-block; /* Allows it to sit next to text */
                    vertical-align: middle; /* Aligns it nicely with the text and emoji */
                    width: 14px;
                    height: 14px;
                    margin-right: 8px; /* Space between the circle and the emoji */
                    border-radius: 50%;
                    background-color: transparent;
                    /* CHANGE: Lighter border for indicator */
                    border: 1.5px solid #d1d5db; /* Unread hollow circle */
                    transition: all 0.3s ease;
                    flex-shrink: 0; /* Prevents it from being squished */
                }
        
                .tree-status-indicator.read {
                    background-color: #22c55e; /* Green for 'read' */
                    border-color: #22c55e;
                }
        
                .tree-status-indicator.read::before {
                    content: '';
                    display: block;
                    width: 100%;
                    height: 100%;
                    /* Same embedded SVG checkmark, will scale automatically */
                    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='4' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='20 6 9 17 4 12'%3E%3C/polyline%3E%3C/svg%3E");
                    background-size: 70%;
                    background-position: center;
                    background-repeat: no-repeat;
                }
                /* --- STYLES FOR QUIZ --- */
                .quiz-option {
                    padding: 15px;
                    /* CHANGE: Light border for quiz options */
                    border: 2px solid #d1d5db;
                    /* CHANGE: Light background for quiz options */
                    background: #f9fafb;
                    border-radius: 8px;
                    cursor: pointer;
                    transition: all 0.2s ease;
                }
                .quiz-option:hover {
                    border-color: #6366f1;
                    /* CHANGE: Lighter background on hover */
                    background: #f3f4f6;
                }
                .quiz-option.selected {
                    border-color: #a78bfa;
                    background: #4c1d95;
                    color: white;
                }
                .quiz-option.correct {
                    border-color: #22c55e;
                    background: #166534;
                    color: white; /* Ensure text is readable */
                }
                .quiz-option.incorrect {
                    border-color: #dc2626;
                    background: #991b1b;
                    color: white; /* Ensure text is readable */
                }
                #quizFeedback.correct { color: #16a34a; }
                #quizFeedback.incorrect { color: #ef4444; }

                /* --- ADD THESE NEW STYLES FOR THE CATEGORY TAG --- */
.topic-card .category-tag {
    display: inline-block;
    padding: 4px 12px;
    font-size: 12px;
    font-weight: 600;
    border-radius: 20px;
    margin-bottom: 12px; /* Adds space between the tag and the title */
    color: #ffffff; /* Default text color */
    background-color: #6b7280; /* Default background */
}

.topic-card h2 {
    /* We already had this, just ensure margin-bottom is set */
    margin-bottom: 8px; 
}

/* --- UNIVERSAL TAG STYLES (THE FIX) --- */

/* 1. General style for the container, making it flexible with a gap */
.tags-container {
    display: flex;
    gap: 8px;
}

/* 2. General style for the tags themselves, making them padded and rounded */
.tag {
    display: inline-block;
    padding: 4px 12px;
    font-size: 12px;
    font-weight: 600;
    border-radius: 20px;
    color: #ffffff; /* Default text is white */
}

/* --- LAYOUT-SPECIFIC TWEAKS --- */

/* 3. For tags inside a topic card, add space below them */
.topic-card .tags-container {
    margin-bottom: 12px;
}

/* 4. For tags inside the sidebar header, center them */
#sidebarTitle .tags-container {
    justify-content: center;
    padding-bottom: 5px;
}
/* --- Styles for the sidebar title spacing and border --- */
#sidebarTitle {
    margin-bottom: 10px;  /* This is the halved space below the border */
    padding-bottom: 10px; /* This is the space between the tags and the border */
    border-bottom: 1px solid #e5e7eb; /* The new thin grey border */
}

.topic-card .tag {
    display: inline-block;
    padding: 4px 12px;
    font-size: 12px;
    font-weight: 600;
    border-radius: 20px;
    color: #ffffff; /* Default text color is white */
}

/* We can remove the specific margin from the category-tag now */
.topic-card .category-tag {
    /* The .tag class now handles the shared styles */
}/* --- Styles for Sort Controls --- */
.sort-btn {
    background: #ffffff;
    border: 1px solid #d1d5db;
    color: #4b5563;
    padding: 6px 12px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 600;
    transition: all 0.2s ease;
}
.sort-btn:hover {
    background: #f3f4f6;
}
.sort-btn.active {
    background: #6366f1;
    color: white;
    border-color: #6366f1;
}

/* --- Styles for Category Sorting View --- */
#topicGrid.category-view {
    display: block; /* Change from grid to block to allow for headers */
}
.category-header {
    font-size: 22px;
    color: #11182c;
    margin-top: 30px;
    margin-bottom: 15px;
    padding-bottom: 10px;
    border-bottom: 1px solid #e5e7eb;
}
/* Remove margin for the very first header */
.category-header:first-of-type {
    margin-top: 0;
}
/* Re-applies the grid layout for topics within each category */
.topic-grid-layout {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 20px;
}/* --- Styles for the new header layout in the main content --- */
.topic-header {
    display: flex;
    justify-content: space-between; /* Pushes title and button to opposite ends */
    align-items: center;        /* Vertically aligns the title and button */
}

/* This is the new button style */
/* This is the new button style */
.quiz-me-button {
    background: #6366f1;
    color: white;
    border: none;
    padding: 12px 24px;   /* Increased padding for a bigger button */
    border-radius: 10px;  /* Slightly more rounded corners */
    cursor: pointer;
    font-size: 16px;      /* Larger font size */
    font-weight: 600;
    transition: all 0.2s ease;
    flex-shrink: 0;

    /* --- New Flexbox styles for the icon --- */
    display: inline-flex; /* Aligns items in a row */
    align-items: center;  /* Vertically centers the icon and text */
    gap: 10px;            /* Adds space between the icon and text */
}

.quiz-me-button:hover:not(:disabled) {
    background: #4f46e5;
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
}

/* This style grays out the button when it's disabled */
.quiz-me-button:disabled {
    background: #e5e7eb; /* Light gray background */
    color: #9ca3af;   /* Muted text color */
    cursor: not-allowed;
}

/* --- Styles for the tooltip on disabled hover --- */
.button-tooltip-wrapper {
    position: relative; /* Required for positioning the tooltip */
    display: inline-block;
}

.quiz-tooltip {
    visibility: hidden;
    width: max-content; /* Make width fit the text */
    background-color: #374151; /* Dark background */
    color: #fff;
    text-align: center;
    border-radius: 6px;
    padding: 8px 12px;
    font-size: 12px;
    font-weight: 500;
    
    /* Position the tooltip above the button */
    position: absolute;
    z-index: 10;
    bottom: 120%;
    left: 50%;
    transform: translateX(-50%);
    
    /* Fade in/out animation */
    opacity: 0;
    transition: opacity 0.2s;
}

/* This class is added by JavaScript to show the tooltip */
.quiz-tooltip.show {
    visibility: visible;
    opacity: 1;
}
/* --- NEW: SKELETON LOADER STYLES --- */
.skeleton-loader {
    padding: 40px;
}

@keyframes pulse {
    0% { background-color: #f3f4f6; }
    50% { background-color: #e5e7eb; }
    100% { background-color: #f3f4f6; }
}

.skeleton-title {
    width: 60%;
    height: 35px;
    border-radius: 8px;
    margin-bottom: 25px;
    animation: pulse 1.5s ease-in-out infinite;
}

.skeleton-text {
    width: 100%;
    height: 18px;
    border-radius: 6px;
    margin-bottom: 12px;
    animation: pulse 1.5s ease-in-out infinite;
}

.skeleton-text.short {
    width: 80%;
}
/* --- END OF SKELETON LOADER STYLES --- */

        /* Add these styles to your <style> block */
            .chart-container {
            width: 100%;
            border: 1px solid #e5e7eb;
            border-radius: 16px;
            background: #fdfdff;
            position: relative;
            overflow: hidden;
        }
        
        .bar-chart-container {
            height: 450px;
            padding: 20px;
        }
        
        .pie-chart-wrapper {
            display: flex;
            align-items: center;
            gap: 20px;
            height: 400px;
            padding: 20px;
        }
        .pie-chart-container {
            flex-grow: 1;
            height: 100%;
        }
        .pie-legend-container {
            flex-shrink: 0;
            width: 200px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
        }
        .legend-color-box {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }
        
        /* New generic styles for text areas */
        .input-wrapper {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .styled-textarea {
            width: 100%;
            padding: 15px 20px;
            border: 2px solid #d1d5db;
            border-radius: 12px;
            font-size: 16px;
            font-family: 'Courier New', Courier, monospace;
            outline: none;
            transition: all 0.3s ease;
            background: #f9fafb;
            color: #11182c;
            min-height: 150px;
            resize: vertical;
        }
        
        .styled-textarea:focus {
            border-color: #6366f1;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }
        /* --- CORE STYLES (Mirrored from your existing file) --- */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f9fafb;
            min-height: 100vh;
            color: #374151;
            /* This prevents the main body from ever scrolling, which is correct for this layout */
            overflow: hidden;
        }

        /* --- LAB CONTAINER STYLES --- */
        .lab-container {
            max-width: 800px;
            width: 100%;
            background: #ffffff; /* White background for main content */
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.05);
            border: 1px solid #e5e7eb; /* Light border */
            display: flex;
            flex-direction: column;
            gap: 25px; /* Space between graph and input */
        }
        
        .lab-container h1 {
            font-size: 28px;
            font-weight: 700;
            color: #11182c; /* Darker text for headers */
            text-align: center;
        }

        /* --- GRAPH STYLES --- */
        #graphContainer {
            width: 100%;
            height: 550px;
            border: 1px solid #e5e7eb;
            border-radius: 16px;
            background: #fdfdff;
            cursor: move; /* Change cursor to indicate pannable area */
            position: relative; /* Needed for canvas overlay */
            overflow: hidden; /* Hide anything drawn outside bounds */
        }
        
        #functionGraph {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        /* --- INPUT STYLES (Mirrored from chat-input) --- */
        .equation-input-wrapper {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .equation-input-wrapper label {
            font-size: 14px;
            color: #6b7280; /* Medium gray for labels */
            font-weight: 600;
        }
        
        .equation-input {
            width: 100%;
            padding: 15px 20px;
            border: 2px solid #d1d5db; /* Light border for input */
            border-radius: 12px;
            font-size: 16px;
            font-family: 'Courier New', Courier, monospace;
            outline: none;
            transition: all 0.3s ease;
            background: #f9fafb; /* Light gray background */
            color: #11182c; /* Dark text color */
        }
        
        .equation-input:focus {
            border-color: #6366f1; /* Purple focus color */
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }

        .equation-input::placeholder {
            color: #9ca3af; /* Medium gray for placeholder */
        }

        /* --- ERROR MESSAGE STYLE --- */
        #error-message {
            color: #dc2626; /* Strong red */
            font-size: 14px;
            height: 20px; /* Reserve space to prevent layout shifts */
            margin-top: 5px;
            text-align: center;
        }

        /* --- TIMELINE STYLES --- */
        .timeline-container-wrapper {
            width: 100%;
            position: relative;
            padding: 60px 0; /* Increased padding to accommodate staggered cards */
            overflow-x: auto;
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        .timeline-container-wrapper::-webkit-scrollbar {
            display: none;
        }

        .timeline-wrapper {
            position: relative;
            /* CHANGE THIS LINE */
            padding: 20px 80px; /* Was 'padding: 20px;' */
            min-height: 250px;
        }

        .timeline-line {
            position: absolute;
            top: 50%;
            left: 0;
            height: 4px;
            background-color: #e5e7eb;
            transform: translateY(-2px);
            border-radius: 2px;
        }

        .timeline-event {
            position: absolute; 
            background-color: #ffffff;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            padding: 10px 12px; 
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
            transition: all 0.3s ease;
            z-index: 5; /* Ensure card is above braces */
            /*text-align: center; *//* Add this line */
        }
        
        .timeline-event:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            border-color: #6366f1;
        }
        
        .timeline-event.top {
            bottom: 50%;
        }

        .timeline-event.bottom {
            top: 50%;
        }
        
        /* Event Timeline Connector */
       
        
        /* Re-added the vertical connector line */
        /* REPLACE your existing ::after rule with this one */
        .timeline-event.event-style::after {
            content: '';
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            width: 2px;
            /* Use the same color as the timeline bar */
            background-color: #e5e7eb; 
            z-index: 1;
            /* The height is now controlled by a variable from the script */
            height: var(--connector-height, 25px); 
        }
        
        .timeline-event.event-style.top::before { bottom: -15px; }
        .timeline-event.event-style.top::after { top: 100%; }

        .timeline-event.event-style.bottom::before { top: -15px; }
        .timeline-event.event-style.bottom::after { bottom: 100%; }
        
        .timeline-event-title {
            font-size: 15px;
            font-weight: 600;
            color: #11182c;
            margin-bottom: 4px;
        }

        .timeline-event-date {
            font-size: 12px;
            color: #6b7280;
        }

        /* Period Timeline Styles */
        .period-brace {
            position: absolute;
            height: 10px; /* Height of the horizontal part */
            /* CHANGE THIS COLOR */
            border-left: 2px solid #e5e7eb;
            /* CHANGE THIS COLOR */
            border-right: 2px solid #e5e7eb;
            z-index: 1;
        }
        .period-brace.top {
            bottom: 50%;
            /* CHANGE THIS COLOR */
            border-top: 2px solid #e5e7eb;
        }
        .period-brace.bottom {
            top: 50%;
            /* CHANGE THIS COLOR */
            border-bottom: 2px solid #e5e7eb;
        }
        /* Add these styles for the new zoom buttons */
        .zoom-controls {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            flex-direction: column;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
            border: 1px solid #d1d5db;
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            background-color: #ffffff;
            border: none;
            border-bottom: 1px solid #e5e7eb;
            cursor: pointer;
            font-size: 22px;
            font-weight: 300;
            color: #374151;
            transition: background-color 0.2s ease;
        }

        .zoom-btn:last-child {
            border-bottom: none;
        }

        .zoom-btn:hover {
            background-color: #f3f4f6;
        }
        /* --- HYBRID TIMELINE STYLES --- */
    .hybrid-event {
        position: absolute;
        text-align: center;
        z-index: 5;
    }

    .hybrid-event-title {
        font-size: 14px;
        font-weight: 600;
        color: #11182c;
    }

    .hybrid-event-date {
        font-size: 11px;
        color: #6b7280;
    }

    .hybrid-event-connector {
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        width: 2px;
        background-color: #11182c; /* Black connector line */
        z-index: 1;
        /* Height is set dynamically by the script */
        height: var(--connector-height, 25px);
    }

    .hybrid-event.top {
        bottom: 50%;
    }
    .hybrid-event.bottom {
        top: 50%;
    }

    .hybrid-event-connector.top {
        top: 100%;
    }

    .hybrid-event-connector.bottom {
        bottom: 100%;
    }
            </style>

<script>
    window.si = window.si || function () { (window.si.q = window.si.q || []).push(arguments); };
  </script>
  <script src="/_vercel/insights/script.js" defer></script>
  
  <script>
    window.va = window.va || function () { (window.va.q = window.va.q || []).push(arguments); };
  </script>
  <script src="/_vercel/analytics/script.js" defer></script>
</head>
<body>
    <div id="authView" style="display: flex; justify-content: center; align-items: center; height: 100vh;">
        <div style="background: #ffffff; padding: 40px; border-radius: 20px; width: 400px; border: 1px solid #e5e7eb;">
            <h2 style="margin-bottom: 30px;">Login or Sign Up</h2>
            
            <input type="email" id="emailInput" placeholder="Email" class="modal-input">
            <input type="password" id="passwordInput" placeholder="Password" class="modal-input">
            <p id="authError" style="color: #dc2626; margin-bottom: 15px;"></p>
            <div style="display: flex; gap: 15px;">
                <button id="loginBtn" class="modal-btn submit" style="flex: 1;">Login</button>
                <button id="signupBtn" class="modal-btn submit" style="flex: 1;">Sign Up</button>
            </div>
        
            <div style="margin: 20px 0; text-align: center; color: #71717a;">OR</div>
        
            <button id="googleSignInBtn" class="modal-btn" style="width: 100%; background: #fff; color: #000; display: flex; align-items: center; justify-content: center; gap: 10px;">
                <svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="18px" height="18px" viewBox="0 0 48 48"><g><path fill="#EA4335" d="M24 9.5c3.54 0 6.71 1.22 9.21 3.6l6.85-6.85C35.9 2.38 30.47 0 24 0 14.62 0 6.51 5.38 2.56 13.22l7.98 6.19C12.43 13.72 17.74 9.5 24 9.5z"></path><path fill="#4285F4" d="M46.98 24.55c0-1.57-.15-3.09-.42-4.55H24v9.02h12.94c-.58 2.96-2.26 5.48-4.78 7.18l7.73 6c4.51-4.18 7.09-10.36 7.09-17.65z"></path><path fill="#FBBC05" d="M10.53 28.59c-.48-1.45-.76-2.99-.76-4.59s.27-3.14.76-4.59l-7.98-6.19C.92 16.46 0 20.12 0 24c0 3.88.92 7.54 2.56 10.78l7.97-6.19z"></path><path fill="#34A853" d="M24 48c6.48 0 11.93-2.13 15.89-5.81l-7.73-6c-2.15 1.45-4.92 2.3-8.16 2.3-6.26 0-11.57-4.22-13.47-9.91l-7.98 6.19C6.51 42.62 14.62 48 24 48z"></path><path fill="none" d="M0 0h48v48H0z"></path></g></svg>
                Sign in with Google
            </button>
        </div>
    </div>
    
    <div id="appContainer" style="display: none;">
        </div>
    <!-- This is the new Landing Page View -->
<div id="landingView" class="view active">
    <div class="landing-header">
        <div style="display: flex; align-items: center; gap: 30px;">
            <h1>Your Learning Topics</h1>
            <div id="sortControls">
                <span style="color: #6b7280; font-weight: 500; font-size: 14px; margin-right: 10px;">Sort by:</span>
                <button class="sort-btn active" data-sort="recent">Most Recent</button>
                <button class="sort-btn" data-sort="category">By Category</button>
            </div>
        </div>
        <div style="display: flex; gap: 15px;">
            <button class="new-topic-btn" id="newTopicBtn">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14m-7-7h14"/></svg>
                Learn a new topic
            </button>
            <button class="nav-button" id="signOutBtn" style="border-width: 2px;">
                Sign Out
            </button>
        </div>
    </div>
    <div id="topicGrid">
        <!-- Topic cards will be added here later -->
    </div>
</div>
<div id="learningView" class="view">

    <div class="app-wrapper">
        <div class="tree-sidebar" id="treeSidebar">
            <div id="sidebarTitle" style="margin-bottom: 0px; min-height: 27px;">Learning Journey Map</div>               
            <div class="tree-container" id="treeContainer">
                <div class="tree-node">
                    <div class="tree-node-content active" onclick="navigateToNode('root')">
                        <span class="tree-node-icon">🏠</span>
                        <span class="tree-node-text">Home</span>
                    </div>
                </div>
            </div>
        </div>
        <div class="resizer" id="dragHandle"></div>

        <div class="main-container">
            <div class="app-container">
                <div class="navigation-controls">
                    <button class="nav-button" id="backButton" onclick="navigateBack()" disabled>
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M19 12H5m0 0l6-6m-6 6l6 6"/>
                        </svg>
                        Back
                    </button>
                    <button class="nav-button" id="forwardButton" onclick="navigateForward()" disabled>
                        Forward
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M5 12h14m0 0l-6-6m6 6l-6 6"/>
                        </svg>
                    </button>
                    <button class="nav-button" id="mainMenuBtn">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12h18M3 6h18M3 18h18"/></svg>
                        Main Menu
                    </button>
                    <div class="breadcrumb" id="breadcrumb">
                        <span class="breadcrumb-item active">Home</span>
                    </div>
                    <button class="nav-button" id="deleteTopicBtn" title="Delete this topic">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="3 6 5 6 21 6"></polyline>
                            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                            <line x1="10" y1="11" x2="10" y2="17"></line>
                            <line x1="14" y1="11" x2="14" y2="17"></line>
                        </svg>
                    </button>
                </div>

                <div class="main-content" id="mainContent">
                    <div class="welcome-message">
                        <h1>What do you want to learn?</h1>
                        <p>Explore finance and economics through an interactive learning journey</p>
                        <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap; margin-top: 40px;">
                            <button class="card" style="padding: 15px 25px; cursor: pointer;" onclick="askQuestion('How does the central bank work?')">
                                <span style="font-size: 16px;">🏦 Central Banking</span>
                            </button>
                            <button class="card" style="padding: 15px 25px; cursor: pointer;" onclick="askQuestion('What are securities and their types?')">
                                <span style="font-size: 16px;">📈 Securities</span>
                            </button>
                            <button class="card" style="padding: 15px 25px; cursor: pointer;" onclick="askQuestion('Explain bonds and how they work')">
                                <span style="font-size: 16px;">📊 Bonds</span>
                            </button>
                        </div>
                    </div>
                </div>
                <div class="chat-container">
                    <div class="error-message" id="errorMessage"></div>
                    <div class="chat-input-wrapper">
                        <input 
                            type="text" 
                            class="chat-input" 
                            id="chatInput" 
                            placeholder="Ask about finance or economics..."
                            autofocus
                        >
                        <button class="send-button" id="sendButton" onclick="sendMessage()">
                            <span id="buttonText">Send</span>
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M5 12h14m0 0l-6-6m6 6l-6 6"/>
                            </svg>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    
</div>
<div class="modal-overlay" id="deleteConfirmModal">
    <div class="modal-content">
        <h2>Confirm Deletion</h2>
        <p style="margin: 20px 0 40px; font-size: 16px; color: #4b5563; text-align: center;">
            Are you sure you want to permanently delete this topic and all of its content? This action cannot be undone.
        </p>        <div class="modal-actions">
            <button class="modal-btn cancel" id="cancelDeleteBtn">Cancel</button>
            <button class="modal-btn delete" id="confirmDeleteBtn">Confirm Delete</button>
        </div>
    </div>
</div>

<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore-compat.js"></script>
    <script>



/**
 * --- NEW: SKELETON LOADER FUNCTION ---
 * Clears the main content area and displays an animated skeleton loader
 * to indicate that content is being fetched.
 */
 function showSkeletonLoader() {
    const mainContent = document.getElementById('mainContent');
    mainContent.innerHTML = `
        <div class="skeleton-loader">
            <div class="skeleton-title"></div>
            <div class="skeleton-text"></div>
            <div class="skeleton-text"></div>
            <div class="skeleton-text short"></div>
            <br/>
            <div class="skeleton-text"></div>
            <div class="skeleton-text short"></div>
        </div>
    `;
}
        /**
 * --- NEW: PRE-FETCHING FUNCTION ---
 * Fetches the content for a given node in the background without showing a UI loading state.
 * This is used to pre-load content for cards before the user clicks on them.
 * @param {object} node - The tree node to fetch content for.
 */
async function prefetchNodeContent(node) {
    // Silently exit if content already exists or is being fetched.
    if (node.content || node.isPrefetching) return;

    // Mark as prefetching to avoid duplicate calls
    node.isPrefetching = true;
    console.log(`%cPrefetching: "${node.fullTitle}"`, 'color: #8b5cf6;');

    const topic = node.fullTitle;
    let contextPrompt = '';
    if (node.parent && node.parent.id !== 'root') {
        contextPrompt = `In the context of "${node.parent.fullTitle}", `;
    }

    const prefetchPrompt = `You are an expert educator. Your task is to explain the topic "${topic}"${contextPrompt}.
        
        Your response MUST be a single, valid JSON object with no other text before or after it.
        The JSON object must have two keys: "explanation" and "definitions".
        
        1.  In the "explanation" value, provide a detailed, two-paragraph explanation of the topic.
        2.  In the "definitions" value, provide an array of objects. For each object, identify a technical term from your explanation and provide a simple, one-sentence definition for it in the context of the topic.
        
        Example JSON structure:
        {
          "explanation": "A detailed two-paragraph explanation goes here...",
          "definitions": [
            { "term": "Technical Term 1", "definition": "A simple one-sentence definition." },
            { "term": "Technical Term 2", "definition": "Another simple definition." }
          ]
        }`;

    try {
        // Use a temporary, isolated conversation for this background task
        const prefetchConversation = [
            { role: "system", content: "You are an educational assistant." },
            { role: "user", content: prefetchPrompt }
        ];

        const response = await fetch(BACKEND_URL + '/chat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ messages: prefetchConversation })
        });

        if (!response.ok) throw new Error(`Prefetch API failed for "${topic}"`);

        const data = await response.json();
        const botResponseText = data.choices[0].message.content;

        const jsonMatch = botResponseText.match(/\{[\s\S]*\}/);
        if (!jsonMatch) throw new Error(`Prefetch found no JSON for "${topic}"`);

        const structuredResponse = JSON.parse(jsonMatch[0]);
        const explanation = structuredResponse.explanation || "No explanation provided.";
        const definitions = structuredResponse.definitions || [];

        const parsed = parseResponse(explanation, definitions);
        parsed.showTellMeMore = true;

        // --- Attach the content to the node ---
        node.content = parsed;
        console.log(`%c✅ Prefetch successful: "${node.fullTitle}"`, 'color: #22c55e;');

        // Save the newly added content to Firestore
        await saveTopicsToFirestore();

    } catch (error) {
        console.error("Prefetch error:", error);
    } finally {
        // Mark prefetching as complete regardless of outcome
        node.isPrefetching = false;
    }
}
        /**
 * Creates the HTML for the category and sophistication tags.
 * @param {object} topicNode The topic's main node containing category and sophistication.
 * @returns {string} The HTML string for the tags.
 */
/**
 * Creates the HTML for the category and sophistication tags.
 * @param {object} topicNode The topic's main node containing category and sophistication.
 * @returns {string} The HTML string for the tags.
 */
 function createTagsHTML(topicNode) {
    const category = topicNode.category || 'General';
    const sophistication = topicNode.sophistication || 'Simple';
    const categoryColor = getCategoryColor(category);

    // This now returns clean HTML, relying on the stylesheet for layout.
    return `
        <div class="tags-container">
            <div class="tag" style="background-color: ${categoryColor};">
                ${category}
            </div>
            <div class="tag" style="background-color: #e5e7eb; color: #4b5563;">
                ${sophistication}
            </div>
        </div>
    `;
}
/**
 * Returns a background color based on the category name.
 * @param {string} category The category name.
 * @returns {string} A CSS hex color code.
 */
 function getCategoryColor(category) {
    const colors = {
        "Finance & Economics": "#059669",
        "Literature & Language": "#7c3aed",
        "History": "#d97706",
        "Science": "#2563eb",
        "Mathematics": "#db2777",
        "Technology & Engineering": "#6d28d9",
        "Philosophy & Ethics": "#4f46e5",
        "Politics & Government": "#dc2626",
        "Art & Aesthetics": "#ea580c",
        "Culture & Anthropology": "#c026d3",
        "Psychology & Human Behavior": "#0891b2",
        "Health & Medicine": "#16a34a",
        "Education & Learning": "#65a30d",
        "Sports & Physical Training": "#f59e0b",
        "Life Skills & Personal Development": "#22d3ee",
        "default": "#4b5563"
    };
    return colors[category] || colors["default"];
}
        // --- START OF NEW JAVASCRIPT FOR DELETION ---

// Get references to all the new HTML elements we added
const deleteTopicBtn = document.getElementById('deleteTopicBtn');
const deleteConfirmModal = document.getElementById('deleteConfirmModal');
const confirmDeleteBtn = document.getElementById('confirmDeleteBtn');
const cancelDeleteBtn = document.getElementById('cancelDeleteBtn');

// Helper functions to show and hide the modal
function openDeleteModal() {
    deleteConfirmModal.classList.add('active');
}

function closeDeleteModal() {
    deleteConfirmModal.classList.remove('active');
}

// When the user clicks the trash can icon, open the confirmation modal
deleteTopicBtn.addEventListener('click', openDeleteModal);

// If the user clicks 'Cancel' or outside the modal, just close it
cancelDeleteBtn.addEventListener('click', closeDeleteModal);
deleteConfirmModal.addEventListener('click', (e) => {
    if (e.target === deleteConfirmModal) {
        closeDeleteModal();
    }
});

// This is the main logic for when the user confirms the deletion
confirmDeleteBtn.addEventListener('click', async () => {
    if (!currentTopicId) {
        alert("Error: No topic is currently loaded.");
        return;
    }

    // Step 1: Delete the topic from our local JavaScript object
    delete learningTopics[currentTopicId];
    console.log(`Locally deleted topic: ${currentTopicId}`);

    // Step 2: Save the updated (smaller) topics object to Firestore.
    // This overwrites the old data, effectively deleting the topic from the database.
    await saveTopicsToFirestore();
    console.log("Deletion saved to Firestore.");

    // Step 3: Close the modal
    closeDeleteModal();

    // Step 4: Go back to the main menu and refresh the list of topic cards
    renderTopicCards();
    switchView('landingView');
});

// --- END OF NEW JAVASCRIPT FOR DELETION ---
        /**
 * Converts a string to Title Case.
 * @param {string} str The string to convert.
 * @returns {string} The Title Cased string.
 */
function toTitleCase(str) {
    if (!str) return '';
    return str.replace(
        /\w\S*/g,
        (txt) => txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase()
    );
}
        // --- ADD THIS SNIPPET FOR SIGN OUT FUNCTIONALITY ---

// Get a reference to the new sign-out button
const signOutBtn = document.getElementById('signOutBtn');

// Add a click event listener to the button
signOutBtn.addEventListener('click', () => {
    // Use the Firebase auth object to sign the user out
    auth.signOut()
        .then(() => {
            // This .then() block runs on successful sign-out
            console.log("User signed out successfully.");
            // You don't need to do anything else here.
            // The `onAuthStateChanged` listener will automatically detect the sign-out
            // and show the login screen.
        })
        .catch((error) => {
            // This .catch() block runs if there was an error
            console.error("Sign-out error:", error);
        });
});
        // Import the functions you need from the SDKs you need

// TODO: Add SDKs for Firebase products that you want to use
// https://firebase.google.com/docs/web/setup#available-libraries

// Your web app's Firebase configuration
// For Firebase JS SDK v7.20.0 and later, measurementId is optional
const firebaseConfig = {
  apiKey: "AIzaSyBkDl26l4dEQWp5E3-i-Tg1NzkAYDC4ELE",
  authDomain: "my-learning-app-8b760.firebaseapp.com",
  projectId: "my-learning-app-8b760",
  storageBucket: "my-learning-app-8b760.firebasestorage.app",
  messagingSenderId: "449522463774",
  appId: "1:449522463774:web:3eb0d9e6bd9164e8972a0f",
  measurementId: "G-N4N54809FB"
};

// Initialize Fireba
const app = firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.firestore();
const googleProvider = new firebase.auth.GoogleAuthProvider();


// At the top of your script, get references to the new elements
const authView = document.getElementById('authView');
const appContainer = document.getElementById('appContainer');
const loginBtn = document.getElementById('loginBtn');
const signupBtn = document.getElementById('signupBtn');
const emailInput = document.getElementById('emailInput');
const passwordInput = document.getElementById('passwordInput');
const authError = document.getElementById('authError');

// --- Authentication Logic ---

// Listen for login/signup button clicks
loginBtn.addEventListener('click', () => {
    auth.signInWithEmailAndPassword(emailInput.value, passwordInput.value)
        .catch(error => { authError.textContent = error.message; });
});

signupBtn.addEventListener('click', () => {
    auth.createUserWithEmailAndPassword(emailInput.value, passwordInput.value)
        .catch(error => { authError.textContent = error.message; });
});

// This is the gatekeeper. It checks if a user is logged in or not.
auth.onAuthStateChanged(user => {
    if (user) {
        // User is signed in.
        authView.style.display = 'none'; // Hide login form
        appContainer.style.display = 'block'; // Show the main app

        // This is where we will load their saved data! (Phase 4)
        loadTopicsFromFirestore(user.uid); 
    } else {
        // User is signed out.
        authView.style.display = 'flex'; // Show login form
        appContainer.style.display = 'none'; // Hide the main app
    }
});
// Function to save the entire learningTopics object to Firestore
// Replace the existing function with this one
/**
 * Creates a deep copy of the learning topics object and removes the circular
 * 'parent' properties so it can be safely saved to Firestore.
 * @param {object} topicsObject - The original learningTopics object.
 * @returns {object} A clean copy of the object suitable for JSON stringification.
 */
 /**
 * Recursively creates a deep copy of a topic node and its children,
 * omitting the 'parent' property to make it safe for Firestore.
 * @param {object} originalNode The node to clean.
 * @returns {object} A clean, saveable copy of the node and its descendants.
 */
function createSaveableCopy(originalNode) {
    const newNode = {};

    // Copy all properties from the original node to the new one, EXCEPT 'parent'.
    for (const key in originalNode) {
        if (key !== 'parent' && Object.hasOwnProperty.call(originalNode, key)) {
            newNode[key] = originalNode[key];
        }
    }

    // If the original node has children, recursively clean them.
    if (originalNode.children && originalNode.children.length > 0) {
        newNode.children = originalNode.children.map(child => createSaveableCopy(child));
    }

    return newNode;
}


async function saveTopicsToFirestore() {
    console.log("Attempting to save topics...");
    const user = auth.currentUser;

    if (user) {
        console.log("User found:", user.uid);
        
        try {
            // --- THIS IS THE NEW FIX ---
            const topicsToSave = {};

            // Go through each main topic in your learningTopics object
            for (const topicId in learningTopics) {
                if (Object.hasOwnProperty.call(learningTopics, topicId)) {
                    // Create a clean, saveable copy of each topic's tree structure
                    topicsToSave[topicId] = createSaveableCopy(learningTopics[topicId]);
                }
            }
            // --------------------------

            console.log("Clean data to be saved:", topicsToSave);
            
            await db.collection('userTopics').doc(user.uid).set({
                topics: topicsToSave
            });
            
            console.log("SUCCESS: Topics saved to Firestore!");

        } catch (error) {
            console.error("FIRESTORE SAVE ERROR:", error);
        }
    } else {
        console.log("Save failed: No user is currently logged in.");
    }
}

// Function to load topics when a user logs in
async function loadTopicsFromFirestore(userId) {
    try {
        const doc = await db.collection('userTopics').doc(userId).get();
        if (doc.exists) {
            const data = doc.data();
            // Important: We need a way to restore the circular 'parent' references
            // that JSON.stringify removes.
            learningTopics = restoreParents(data.topics);
            console.log("Topics loaded successfully!");
        } else {
            console.log("No saved topics found for this user. Starting fresh.");
            learningTopics = {}; // Start with an empty object
        }
        // After loading, render the cards on the landing page
        renderTopicCards();
    } catch (error) {
        console.error("Error loading topics: ", error);
    }
}

// Helper function to restore the parent-child links in your tree
function restoreParents(topics) {
    Object.values(topics).forEach(topic => {
        function traverse(node, parent) {
            node.parent = parent;
            if (node.children) {
                node.children.forEach(child => traverse(child, node));
            }
        }
        traverse(topic, null);
    });
    return topics;
}
// You also need a logout button. Add this to your main app's navigation controls.
// <button id="logoutBtn" class="nav-button">Logout</button>
// And add the event listener for it:
// document.getElementById('logoutBtn').addEventListener('click', () => auth.signOut());

        /**
 * A universal "catch-all" parser that finds numbered list items
 * anywhere in a string, whether it's plain text or embedded in JSON.
 * @param {string} text - The raw text response from the AI.
 * @returns {Array<Object>} An array of section objects.
 */
function universalParseSyllabus(text) {
    const sections = [];
    // This regex looks for a digit(s), a period, optional space,
    // and then captures the text until it hits a quote, a comma, or the end of a line.
    const regex = /\d+\.\s*([^",\n\r]+)/g;
    let match;

    // Loop through all matches found in the entire string
    while ((match = regex.exec(text)) !== null) {
        // match[1] is the captured text (the module title)
        const title = match[1].trim(); 
        
        sections.push({
            title: title,
            content: "", 
            fullContent: "",
            isExpanded: false
        });
    }
    
    console.log("DEBUG: Universal parser found sections:", sections);
    return sections;
}
        let currentQuizQuestions = [];
        let currentQuestionIndex = 0;
        let userScore = 0;
        /**
 * Shows or hides a loading spinner on the new topic modal's submit button.
 * @param {boolean} isLoading - Whether to show the loading state.
 */
function showModalLoading(isLoading) {
    const submitBtn = document.getElementById('submitTopicBtn');
    if (isLoading) {
        submitBtn.disabled = true;
        submitBtn.innerHTML = '<span class="loading-spinner" style="width: 20px; height: 20px; border-width: 3px;"></span>Loading...';
    } else {
        submitBtn.disabled = false;
        submitBtn.innerHTML = 'Submit';
    }
}
/**
 * Parses the raw text response from the syllabus API call.
 * @param {string} text - The raw text from the AI.
 * @returns {Array<Object>} An array of section objects.
 */

 function gatherReadContent(node) {
    let compiledText = '';

    // A recursive inner function to traverse the tree
    function traverse(currentNode) {
        if (!currentNode) return;

        // If the node is read and has content, add it to our "study guide"
        if (currentNode.isRead && currentNode.content && currentNode.content.overview) {
            // Strip HTML tags for a cleaner text to send to the AI
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = currentNode.content.overview;
            compiledText += (tempDiv.textContent || tempDiv.innerText || "") + "\n\n";
        }

        // Recurse for all children
        if (currentNode.children && currentNode.children.length > 0) {
            currentNode.children.forEach(child => traverse(child));
        }
    }

    traverse(node);
    return compiledText;
}
async function fetchQuiz(textContent) {
    showModalLoading(true); // Re-using your existing modal loader
    const prompt = `Based *only* on the following text, create a multiple-choice quiz with 4 questions. The questions must be answerable solely from the provided text.

    Your response MUST be a valid JSON object. Do not include any other text or explanations. The JSON object should follow this exact structure:
    {
      "questions": [
        {
          "questionText": "A question based on the text.",
          "options": ["Option A", "Option B", "Option C", "Option D"],
          "correctAnswerIndex": 1 
        }
      ]
    }

    TEXT:
    ---
    ${textContent}
    ---
    `;

    try {
        // Using a temporary history for this specific, one-off request
        const quizConversation = [
            { role: "system", content: "You are a quiz generation assistant." },
            { role: "user", content: prompt }
        ];

        const response = await fetch(BACKEND_URL + '/chat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ messages: quizConversation })
        });

        if (!response.ok) throw new Error('API request failed');

        const result = await response.json();
        const botResponseText = result.choices[0].message.content;
        
        // Find the JSON part of the response and parse it
        const jsonMatch = botResponseText.match(/\{[\s\S]*\}/);
        if (!jsonMatch) throw new Error("No valid JSON object found in the AI response.");
        
        const parsedJson = JSON.parse(jsonMatch[0]);
        return parsedJson.questions || [];

    } catch (error) {
        console.error("Error fetching or parsing quiz:", error);
        showError("Could not generate the quiz. The AI may have returned an invalid format.");
        return [];
    } finally {
        showModalLoading(false);
    }
}
let selectedOptionIndex = null; // Track which option is selected

function displayQuestion() {
    selectedOptionIndex = null;
    const question = currentQuizQuestions[currentQuestionIndex];
    const quizOptionsContainer = document.getElementById('quizOptions');
    
    document.getElementById('quizTitle').textContent = `Question ${currentQuestionIndex + 1} of ${currentQuizQuestions.length}`;
    document.getElementById('quizQuestionText').textContent = question.questionText;
    document.getElementById('quizFeedback').textContent = '';
    quizOptionsContainer.innerHTML = '';

    question.options.forEach((option, index) => {
        const optionEl = document.createElement('div');
        optionEl.className = 'quiz-option';
        optionEl.textContent = option;
        optionEl.onclick = () => {
            // Remove 'selected' from any other option
            document.querySelectorAll('.quiz-option').forEach(el => el.classList.remove('selected'));
            // Add 'selected' to the clicked one
            optionEl.classList.add('selected');
            selectedOptionIndex = index;
        };
        quizOptionsContainer.appendChild(optionEl);
    });

    const submitBtn = document.getElementById('quizSubmitBtn');
    submitBtn.textContent = 'Submit';
    submitBtn.onclick = checkAnswer;
    submitBtn.disabled = false;
}

function checkAnswer() {
    if (selectedOptionIndex === null) {
        alert("Please select an answer.");
        return;
    }

    const question = currentQuizQuestions[currentQuestionIndex];
    const feedbackEl = document.getElementById('quizFeedback');
    const options = document.querySelectorAll('.quiz-option');
    
    // Disable all options after submission
    options.forEach(opt => opt.onclick = null);

    if (selectedOptionIndex === question.correctAnswerIndex) {
        userScore++;
        feedbackEl.textContent = "Correct!";
        feedbackEl.className = 'correct';
        options[selectedOptionIndex].classList.add('correct');
    } else {
        feedbackEl.textContent = "Incorrect. The correct answer is highlighted.";
        feedbackEl.className = 'incorrect';
        options[selectedOptionIndex].classList.add('incorrect');
        options[question.correctAnswerIndex].classList.add('correct');
    }

    const submitBtn = document.getElementById('quizSubmitBtn');
    if (currentQuestionIndex < currentQuizQuestions.length - 1) {
        submitBtn.textContent = 'Next Question';
        submitBtn.onclick = () => {
            currentQuestionIndex++;
            displayQuestion();
        };
    } else {
        submitBtn.textContent = 'Show Results';
        submitBtn.onclick = displayResults;
    }
}

function displayResults() {
    document.getElementById('quizArea').style.display = 'none';
    document.getElementById('quizSubmitBtn').style.display = 'none';

    const resultsEl = document.getElementById('quizResults');
    document.getElementById('quizScoreText').textContent = `Your Score: ${userScore} / ${currentQuizQuestions.length}`;
    resultsEl.style.display = 'block';
}

function closeQuizModal() {
    document.getElementById('quizModal').classList.remove('active');
    // Reset for next time
    document.getElementById('quizArea').style.display = 'block';
    document.getElementById('quizSubmitBtn').style.display = 'block';
    document.getElementById('quizResults').style.display = 'none';
}
async function startQuiz() {
    // 1. Gather Content
    const quizMeBtn = document.getElementById('quizMeBtn');
    quizMeBtn.disabled = true;
    quizMeBtn.textContent = 'Generating...';

    const textContent = gatherReadContent(currentTreeNode);
    if (textContent.length < 100) { // Require a minimum amount of text
        alert("You need to read more content before a quiz can be generated.");
        quizMeBtn.disabled = false;
        quizMeBtn.textContent = 'Quiz Me On This Topic';
        return;
    }

    // 2. Fetch Quiz Questions
    const questions = await fetchQuiz(textContent);
    
    quizMeBtn.disabled = false;
    quizMeBtn.textContent = 'Quiz Me On This Topic';

    if (!questions || questions.length === 0) {
        return; // Error is already shown by fetchQuiz
    }

    // 3. Initialize and Display Quiz
    currentQuizQuestions = questions;
    currentQuestionIndex = 0;
    userScore = 0;

    document.getElementById('quizModal').classList.add('active');
    displayQuestion();
}
 // REPLACE the old parseSyllabusResponse function with this new one.

function parseSyllabusResponse(text) {
    const sections = [];
    
    // This new, more flexible regex handles multiple list formats:
    // - Numbered lists (e.g., "1. Title")
    // - Hyphenated lists (e.g., "- Title")
    // - Asterisk lists (e.g., "* Title")
    // It also ignores leading whitespace.
    const flexibleRegex = /^\s*(?:\d+\.|\-|\*)\s+(.+)$/gm;
    let match;

    while ((match = flexibleRegex.exec(text)) !== null) {
        // The captured title is in match[1].
        // We still trim it and remove any markdown bolding.
        console.log("DEBUG: Regex found a match:", match[0]);

        const title = match[1].replace(/\*\*/g, '').trim(); 
        
        sections.push({
            title: title,
            content: "", 
            fullContent: "",
            isExpanded: false
        });
    }
    
    // This ensures that even if the AI's response has extra text, 
    // we can still extract the list items.
    return sections;
}
        // --- NEW: In-Memory Storage for Topics ---
let learningTopics = {};
let currentTopicId = null; // <-- ADD THIS LINE
/**
 * Clears and redraws the topic cards on the landing page from our storage.
 */
 /**
 * Clears and redraws the topic cards on the landing page from our storage.
 */
/**
 * Clears and redraws the topic cards on the landing page from our storage.
 */
 // --- NEW SORTING AND RENDERING LOGIC ---

// Add this state variable near the top of your script
let currentSort = 'recent';

/**
 * Creates the DOM element for a single topic card.
 * @param {object} topic The topic data object, including its ID.
 * @returns {HTMLElement} The card element.
 */
function createTopicCardDOM(topic) {
    const card = document.createElement('div');
    card.className = 'topic-card';
    
    // This logic is extracted from the old renderTopicCards function
    const category = topic.category || 'General';
    const categoryColor = getCategoryColor(category);
    const sophistication = topic.sophistication || 'Simple';

    card.innerHTML = `
        <div class="tags-container">
            <div class="tag" style="background-color: ${categoryColor};">
                ${category}
            </div>
            <div class="tag" style="background-color: #e5e7eb; color: #4b5563;">
                ${sophistication}
            </div>
        </div>
        <h2>${toTitleCase(topic.fullTitle || topic.title)}</h2>
        <p>Click to continue learning.</p>
    `;

    // Use the topic's ID for the click handler
    card.onclick = () => loadLearningTopic(topic.id);
    return card;
}


/**
 * Clears and redraws the topic cards on the landing page based on the current sort order.
 */
function renderTopicCards() {
    const grid = document.getElementById('topicGrid');
    grid.innerHTML = ''; 

    // Convert topics object to a usable array, making sure to include the ID
    const topicsArray = Object.entries(learningTopics).map(([id, data]) => ({ ...data, id: id }));

    if (topicsArray.length === 0) {
        grid.className = 'empty topic-grid-layout'; 
        grid.innerHTML = '<p style="color: #71717a; font-size: 16px; text-align: center;">You haven\'t started any topics yet. Click "Learn a new topic" to begin!</p>';
        return;
    }

    if (currentSort === 'recent') {
        grid.className = 'topic-grid-layout'; // Use the standard grid layout
        // Sort by most recently opened
        topicsArray.sort((a, b) => (b.lastOpened || 0) - (a.lastOpened || 0));
        
        topicsArray.forEach(topic => {
            const card = createTopicCardDOM(topic);
            grid.appendChild(card);
        });

    } else if (currentSort === 'category') {
        grid.className = 'category-view'; // Use the new block layout for headers
        
        // Group topics by their category
        const grouped = topicsArray.reduce((acc, topic) => {
            const category = topic.category || 'General';
            if (!acc[category]) acc[category] = [];
            acc[category].push(topic);
            return acc;
        }, {});

        // Sort the category names alphabetically
        const sortedCategories = Object.keys(grouped).sort();

        sortedCategories.forEach(category => {
            // Add category header
            const header = document.createElement('h2');
            header.className = 'category-header';
            header.textContent = category;
            grid.appendChild(header);

            // Create a sub-grid for this category's topics
            const categoryGrid = document.createElement('div');
            categoryGrid.className = 'topic-grid-layout';
            grid.appendChild(categoryGrid);

            // Sort topics within this category by most recent
            const topicsInCategory = grouped[category];
            topicsInCategory.sort((a, b) => (b.lastOpened || 0) - (a.lastOpened || 0));
            
            topicsInCategory.forEach(topic => {
                const card = createTopicCardDOM(topic);
                categoryGrid.appendChild(card);
            });
        });
    }
}


// --- Add this event listener setup inside your main script execution area ---
// (e.g., inside the DOMContentLoaded listener)

document.getElementById('sortControls').addEventListener('click', (e) => {
    if (e.target.matches('.sort-btn')) {
        // Ignore click if the button is already active
        if (e.target.classList.contains('active')) return;

        // Update the active state on buttons
        document.querySelectorAll('.sort-btn').forEach(btn => btn.classList.remove('active'));
        e.target.classList.add('active');

        // Get the new sort preference and re-render the topic cards
        currentSort = e.target.dataset.sort;
        renderTopicCards();
    }
});

/**
 * Loads a specific topic's data into the learning view.
 * @param {string} topicId - The ID of the topic to load.
 */
// Find and replace this entire function
function loadLearningTopic(topicId) {
    currentTopicId = topicId; // This line is the issue
    const topicData = learningTopics[topicId];
    if (!topicData) {
        console.error("Topic not found:", topicId);
        return;
    }
    topicData.lastOpened = Date.now(); // ADD THIS LINE

    treeStructure = topicData;
    navigationHistory = [];
    currentHistoryIndex = -1;

    // Applied here for the sidebar title when loading a topic
    document.getElementById('sidebarTitle').innerHTML = createTagsHTML(treeStructure);
    navigateToNode('root');
    switchView('learningView');
}
       /**
 * Resets the learning view and displays the initial syllabus for a new topic.
 * @param {string} topicTitle - The title of the new topic.
 * @param {Array<Object>} syllabusSections - An array of section objects for the syllabus.
 * @param {string} topicId - The unique ID for this new topic.
 */
 // Find and replace this entire function
/**
 * Resets the learning view and displays the initial syllabus for a new topic.
 * @param {string} topicTitle - The title of the new topic.
 * @param {Array<Object>} syllabusSections - An array of section objects for the syllabus.
 * @param {string} topicId - The unique ID for this new topic.
 * @param {string} category - The category assigned to this topic.
 */
 /**
 * Resets the learning view and displays the initial syllabus for a new topic.
 * @param {string} topicTitle - The title of the new topic.
 * @param {Array<Object>} syllabusSections - An array of section objects for the syllabus.
 * @param {string} topicId - The unique ID for this new topic.
 * @param {string} category - The category assigned to this topic.
 * @param {string} sophistication - The sophistication level for the topic.
 */
function startLearningTopic(topicTitle, syllabusSections, topicId, category, sophistication) {
    currentTopicId = topicId;
    navigationHistory = [];
    currentHistoryIndex = -1;

    treeStructure = createTreeNode(topicTitle, null, null);
    treeStructure.id = 'root';
    treeStructure.category = category; 
    treeStructure.sophistication = sophistication; // <-- STORE THE SOPHISTICATION LEVEL
    treeStructure.lastOpened = Date.now(); // ADD THIS LINE
    currentTreeNode = treeStructure;

    const topicContent = {
        overview: `An introduction to the key areas of ${toTitleCase(topicTitle)}. Select a card to begin.`,
        sections: syllabusSections,
        definitions: []
    };
    treeStructure.content = topicContent;

    syllabusSections.forEach(section => {
        createTreeNode(section.title, null, treeStructure, false); 
    });

    learningTopics[topicId] = treeStructure; 
    
    document.getElementById('sidebarTitle').innerHTML = createTagsHTML(treeStructure);
    navigateToNode('root');
    switchView('learningView');
    saveTopicsToFirestore();

    treeStructure.children.forEach(childNode => {
        prefetchNodeContent(childNode);
    });
}

        const BACKEND_URL = '/api';
        
        // Navigation and content management
        let navigationHistory = [];
        let currentHistoryIndex = -1;
        let treeStructure = {
            id: 'root',
            title: 'Home',
            content: null,
            children: [],
            isUserQuestion: false,
            sectionIndex: null
        };
        let currentTreeNode = treeStructure;
        let nodeIdCounter = 0;

        // Current context tracking
        let currentContext = {
            topic: null,
            subtopic: null,
            fullContent: null
        };

        // Initialize conversation history
        // Initialize conversation history
// Initialize conversation history
// Initialize conversation history

// --- NEW: View and Modal Management Functions ---

/**
 * Hides all views and shows the one with the specified ID.
 * @param {string} viewId - The ID of the view to show ('landingView' or 'learningView').
 */
 function switchView(viewId) {
    // Hide all views first
    document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
    // Show the requested view
    document.getElementById(viewId).classList.add('active');
}

/**
 * Opens the "New Topic" modal dialog.
 */
function openNewTopicModal() {
    newTopicModal.classList.add('active');
}

/**
 * Closes the "New Topic" modal dialog.
 */
function closeNewTopicModal() {
    newTopicModal.classList.remove('active');
    document.getElementById('topicInput').value = ''; // Clear input on close
}

/**
 * Handles the submission of a new topic from the modal.
 */
/**
 * Handles the submission of a new topic from the modal.
 */
 /**
 * Handles the submission of a new topic from the modal.
 */
/**
 * Handles the submission of a new topic from the modal by calling the Gemini API.
 */
 /**
 * Handles the submission of a new topic from the modal by calling the Gemini API.
 */
/**
 * Handles the submission of a new topic from the modal by calling the local backend server.
 */
 async function handleNewTopicSubmit() {
    const topic = document.getElementById('topicInput').value.trim();
    const sophistication = document.querySelector('.sophistication-option.active').dataset.level;

    if (!topic) {
        alert('Please enter a topic to learn about.');
        return;
    }

    showModalLoading(true);

    const categories = [
        "Finance & Economics", "Literature & Language", "History", "Science", 
        "Mathematics", "Technology & Engineering", "Philosophy & Ethics", 
        "Politics & Government", "Art & Aesthetics", "Culture & Anthropology", 
        "Psychology & Human Behavior", "Health & Medicine", "Education & Learning", 
        "Sports & Physical Training", "Life Skills & Personal Development"
    ];

    // This new prompt asks for a JSON object with two keys: "category" and "syllabus".
    const prompt = `You are an expert, rigorous and intellectual curriculum designer who follows tasks they have been set with precision and speed. Your task is to design a unique syllabus for "${topic}" for a "${sophistication}" audience.

Your task is to perform two steps:
1.  Categorize this topic into ONE of the following predefined categories: ${categories.join(', ')}.
2.  Design a syllabus as a numbered list of 4-8 unique and compelling module titles for the topic. These modules should be specific to the topic and not generic at all. Provide only the titles. Avoid generic titles like "Introduction" or "Key Concepts.", 'historical context'

Your response MUST be a single, valid JSON object with NO other text before or after it.
The JSON object must have two keys: "category" and "syllabus". The "syllabus" value should be your numbered list as a single string.

Example format:
{
  "category": "Science",
  "syllabus": "1. Core Principles of Relativity\\n2. Spacetime and Gravity\\n3. Black Holes and Singularities"
}`;

    try {
        const syllabusConversation = [
            { role: "system", content: "You are an educational assistant specializing in creating and categorizing a syllabus." },
            { role: "user", content: prompt }
        ];

        const response = await fetch(BACKEND_URL + '/chat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ messages: syllabusConversation })
        });

        if (!response.ok) {
            throw new Error(`API response was not ok. Status: ${response.status}`);
        }

        const result = await response.json();
        const botResponseText = result.choices[0].message.content;
        console.log("DEBUG: Raw AI response:", botResponseText);

        const jsonMatch = botResponseText.match(/\{[\s\S]*\}/);
        if (!jsonMatch) {
            throw new Error("The AI didn't return a valid JSON object. Please try again.");
        }
        
        const parsedResponse = JSON.parse(jsonMatch[0]);
        const { category, syllabus } = parsedResponse;
        
        if (!category || !syllabus) {
            throw new Error("AI response was missing 'category' or 'syllabus'.");
        }

        const syllabusSections = universalParseSyllabus(syllabus);

        if (syllabusSections.length === 0) {
             throw new Error("The AI didn't return a valid syllabus list. Please try a different topic.");
        }

        const newTopicId = `topic-${Date.now()}`;
        closeNewTopicModal();
        // Pass the new category to the startLearningTopic function
        startLearningTopic(topic, syllabusSections, newTopicId, category, sophistication);

    } catch (error) {
        console.error("Error fetching syllabus:", error);
        alert(`An error occurred: ${error.message}`);
    } finally {
        showModalLoading(false);
    }
}

let conversationHistory = [
            {
                role: "system",
                content: `You are an educational assistant specializing in finance and economics. 
                Your response MUST be plain text with markdown formatting for bolding and lists.
                You MUST NOT use JSON, code blocks, or backticks in your response.
                Do not add any conversational fluff or introductory sentences.`
            }
        ];
        // Parse response with markdown support
        // Parse response with markdown support and definitions
// Parse response which is now a full JSON object
// This function now receives the answer text and definitions array directly
// Replace the entire parseResponse function

function parseResponse(mainContentText, definitionsArray) {
    console.log("LOG #1 - Combining answer with definitions:", { mainContentText, definitionsArray });

    const result = {
        overview: '',
        sections: [],
        definitions: definitionsArray || []
    };

    // 1. First, process the entire text for markdown and paragraphs.
    // This regex converts **text** to <strong>text</strong>
    let processedText = mainContentText.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>'); 

    // This regex finds blocks of text separated by two newlines (a paragraph)
    // and wraps each block in <p> tags for proper spacing.
    processedText = processedText
        .split(/\n\s*\n/) // Split by one or more empty lines
        .map(p => p.trim()) // Trim whitespace from each paragraph
        .filter(p => p) // Remove any empty paragraphs
        .map(p => `<p>${p.replace(/\n/g, '<br>')}</p>`) // Wrap in <p> and convert single newlines to <br>
        .join('');

    // 2. Now, assign the fully processed text to the overview.
    // The rest of the function is simpler now.
    result.overview = processedText;

    // The old logic for splitting into sections can be removed,
    // as we are now treating the AI response as a single block of formatted content.
    
    return result;
}
// Create a new helper function to wrap terms in special HTML
// In your <script> tag...

    function applyTermHighlighting(text, definitions) {
            console.log("LOG #3 - Highlighting function called.");
            if (!definitions || definitions.length === 0) {
                return text; // If there are no definitions, return the text as is
            }

            // --- THIS IS THE FIX ---
            // Sort definitions by the length of the term, longest first.
            // This ensures "private equity" is processed before "equity".
            const sortedDefinitions = definitions.sort((a, b) => b.term.length - a.term.length);

            // Now, loop through the correctly sorted definitions
            sortedDefinitions.forEach(def => {
                // The regex looks for whole words to avoid replacing text inside other HTML tags
                const regex = new RegExp(`\\b${def.term}\\b(?![^<]*?>)`, 'gi');
                
                const sanitizedDefinition = def.definition.replace(/"/g, '&quot;');
                const replacement = `<span class="technical-term">${def.term}<span class="term-tooltip">${sanitizedDefinition}</span></span>`;

                text = text.replace(regex, replacement);
            });

            return text;
        }
        // Create tree node
        function createTreeNode(title, content, parent, isUserQuestion = false) {
            const node = {
                id: `node-${++nodeIdCounter}`,
                title: title.length > 30 ? title.substring(0, 30) + '...' : title,
                fullTitle: title,
                content: content,
                parent: parent,
                children: [],
                isUserQuestion: isUserQuestion,
                sectionIndex: null,
                isRead: false
            };
            
            if (parent) {
                parent.children.push(node);
                // Update section indices for all non-question siblings
                updateSectionIndices(parent);
            }
            
            return node;
        }

        // Update section indices for children
        function updateSectionIndices(parent) {
            let sectionCount = 0;
            parent.children.forEach(child => {
                if (!child.isUserQuestion) {
                    sectionCount++;
                    child.sectionIndex = sectionCount;
                }
            });
        }

        // Update tree visualization
        function updateTreeVisualization() {
            const container = document.getElementById('treeContainer');
            container.innerHTML = renderTreeNode(treeStructure);
            
            // Auto-scroll to show the active node
            setTimeout(() => {
                const activeNode = container.querySelector('.tree-node-content.active');
                if (activeNode) {
                    activeNode.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'end' });
                }
            }, 100);
        }

        // Render tree node
        // Find and replace this entire function
// Find and replace this entire function
function renderTreeNode(node, level = 0) {
    const icon = node.id === 'root' ? '' :
                node.isUserQuestion ? '❓' :
                node.sectionIndex ? `${node.sectionIndex}.` : '';
    
    const statusIndicatorHTML = node.id !== 'root' ? 
        `<div class="tree-status-indicator ${node.isRead ? 'read' : ''}"></div>` : 
        '';

    // The comment is now outside of the HTML string
    let html = `
        <div class="tree-node" style="margin-left: ${level * 25}px;">
            <div class="tree-node-content ${node === currentTreeNode ? 'active' : ''}" 
                 onclick="navigateToNode('${node.id}')"
                 title="${toTitleCase(node.fullTitle || node.title)}"> 
                
                ${statusIndicatorHTML}

                <span class="tree-node-icon">${icon}</span>
                <span class="tree-node-text">${toTitleCase(node.title)}</span>
            </div>
    `;
    
    if (node.children.length > 0) {
        html += '<div class="tree-children">';
        node.children.forEach(child => {
            html += renderTreeNode(child, level + 1);
        });
        html += '</div>';
    }
    
    html += '</div>';
    return html;
}
        // Navigate to tree node
        async function navigateToNode(nodeId) {
            const node = findNodeById(treeStructure, nodeId);
            if (node) {
                if (node.children.length === 0 && !node.content && node.id !== 'root') {
            
            // This function fetches the content from the API. It will then call
            // navigateToNode again, but the second time the content will exist.
            await elaborateOnTopic(node, false);             
            // Stop the rest of this function from running, because elaborateOnTopic
            // has already handled the navigation.
            return; 
        }
                // *** LOGIC TO MARK NODE AS READ IS ADDED HERE ***
                // We only mark it as read if it's a content node (doesn't have children).
                // The status of parent nodes is determined by the `updateParentReadStatus` function.
                if (node.children.length === 0) {
                    node.isRead = true;
                    // After marking this node, check if its parent is now fully read.
                    updateParentReadStatus(node.parent);
                }
                saveTopicsToFirestore(); // Save the change in the node's "read" status

                // Add to navigation history
                navigationHistory = navigationHistory.slice(0, currentHistoryIndex + 1);
                navigationHistory.push({
                    node: node,
                    content: JSON.parse(JSON.stringify(node.content)), // Deep copy
                    context: {
                        topic: node.fullTitle || node.title,
                        subtopic: null,
                        fullContent: node.content
                    }
                });
                currentHistoryIndex = navigationHistory.length - 1;
                
                currentTreeNode = node;
                currentContext = navigationHistory[currentHistoryIndex].context;
                
                updateNavigation();
                displayContent(node);
                updateTreeVisualization(); // This will redraw the tree with the new 'read' status
            }
        }

        // Find node by ID
        function findNodeById(node, id) {
            if (node.id === id) return node;
            for (let child of node.children) {
                const found = findNodeById(child, id);
                if (found) return found;
            }
            return null;
        }

        // Update navigation buttons and breadcrumb
        function updateNavigation() {
            const backButton = document.getElementById('backButton');
            const forwardButton = document.getElementById('forwardButton');
            
            backButton.disabled = currentHistoryIndex <= 0;
            forwardButton.disabled = currentHistoryIndex >= navigationHistory.length - 1;
            
            updateBreadcrumb();
        }

        // Update breadcrumb
        // Find and replace this entire function
function updateBreadcrumb() {
    const breadcrumb = document.getElementById('breadcrumb');
    breadcrumb.innerHTML = '';
    
    let path = [];
    let node = currentTreeNode;
    while (node) {
        path.unshift(node);
        node = node.parent;
    }
    
    path.forEach((node, index) => {
        const crumb = document.createElement('span');
        crumb.className = 'breadcrumb-item';
        if (node === currentTreeNode) {
            crumb.classList.add('active');
        }
        crumb.textContent = toTitleCase(node.title); // Applied here

        breadcrumb.appendChild(crumb);
        
        if (index < path.length - 1) {
            const separator = document.createElement('span');
            separator.className = 'breadcrumb-separator';
            separator.textContent = '›';
            breadcrumb.appendChild(separator);
        }
    });
}

        // Navigate back
        function navigateBack() {
            if (currentHistoryIndex > 0) {
                currentHistoryIndex--;
                const historyItem = navigationHistory[currentHistoryIndex];
                currentTreeNode = historyItem.node;
                currentContext = historyItem.context;
                displayContent(historyItem.node, historyItem.content);
                updateNavigation();
                updateTreeVisualization();
            }
        }

        // Navigate forward
        function navigateForward() {
            if (currentHistoryIndex < navigationHistory.length - 1) {
                currentHistoryIndex++;
                const historyItem = navigationHistory[currentHistoryIndex];
                currentTreeNode = historyItem.node;
                currentContext = historyItem.context;
                displayContent(historyItem.node, historyItem.content);
                updateNavigation();
                updateTreeVisualization();
            }
        }

        // Display content
        function displayContent(node, preservedContent = null) {
            const mainContent = document.getElementById('mainContent');
            
            if (node.id === 'root' && !node.content) {
                mainContent.innerHTML = `
                    <div class="welcome-message">
                        <h1>What do you want to learn?</h1>
                        <p>Explore topics through an interactive learning journey</p>
                        <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap; margin-top: 40px;">
                            <button class="card" style="padding: 15px 25px; cursor: pointer;" onclick="askQuestion('How does the central bank work?')">
                                <span style="font-size: 16px;">🏦 Central Banking</span>
                            </button>
                            <button class="card" style="padding: 15px 25px; cursor: pointer;" onclick="askQuestion('What are securities and their types?')">
                                <span style="font-size: 16px;">📈 Securities</span>
                            </button>
                            <button class="card" style="padding: 15px 25px; cursor: pointer;" onclick="askQuestion('Explain bonds and how they work')">
                                <span style="font-size: 16px;">📊 Bonds</span>
                            </button>
                        </div>
                    </div>
                `;
                updatePlaceholder(false);
            } else if (node.content || preservedContent) {
                renderContent(preservedContent || node.content, node.fullTitle || node.title);
                updatePlaceholder(true);
            }
        }

        // Render content
       // Render content
       function renderContent(parsedContent, userQuestion = null) {
            const mainContent = document.getElementById('mainContent');
            mainContent.innerHTML = '';
            
            // Render the main text explanation (overview)
            if (parsedContent.overview) {
                const overviewDiv = document.createElement('div');
                overviewDiv.className = 'topic-overview';
                
                let formattedOverview = parsedContent.overview.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                    .split(/\n\s*\n/)
                    .map(p => p.trim())
                    .filter(p => p)
                    .map(p => `<p>${p.replace(/\n/g, '<br>')}</p>`)
                    .join('');

                const highlightedOverview = applyTermHighlighting(formattedOverview, parsedContent.definitions);
                overviewDiv.innerHTML = `<h2>${toTitleCase(currentTreeNode.fullTitle || currentTreeNode.title)}</h2><div>${highlightedOverview}</div>`;
                mainContent.appendChild(overviewDiv);
            }

            // Render the sub-topic cards
            if (parsedContent.sections && parsedContent.sections.length > 0) {
                const cardsGrid = document.createElement('div');
                cardsGrid.className = 'cards-grid';
                const parentNodeId = currentTreeNode.id;

                parsedContent.sections.forEach((section, index) => {
                    if (!section.isExpanded) {
                        const childNode = currentTreeNode.children.find(child => child.fullTitle === section.title || child.title === section.title);
                        const isNodeRead = childNode ? childNode.isRead : false;
                        const childNodeId = childNode ? childNode.id : null;
                        const card = createCard(section, index, isNodeRead, childNodeId, parentNodeId);
                        cardsGrid.appendChild(card);
                    }
                });
                mainContent.appendChild(cardsGrid);
            }

            // --- NEW: VISUAL ASSET DISPATCHER ---
            if (parsedContent.visualAssets && parsedContent.visualAssets.length > 0) {
                parsedContent.visualAssets.forEach(asset => {
                    // Create a container for the asset to keep things tidy
                    const assetContainer = document.createElement('div');
                    assetContainer.className = 'lab-container'; // Use the same styling as our other assets
                    assetContainer.style.marginTop = '40px'; // Add some space above the asset
                    
                    const assetId = 'asset-' + Date.now() + Math.random().toString(36).substring(2, 9);

                    switch (asset.type) {
                        case 'implicit_plotter':
                            // The new helper function handles everything for the plotter
                            renderImplicitPlotter(assetContainer, asset.data);
                            break;
                            
                        case 'hybrid_timeline':
                            assetContainer.innerHTML = `
                                <h1>Timeline</h1>
                                <p style="text-align: center; color: #9ca3af; font-size: 14px; margin-top: -15px; margin-bottom: 10px;">Scroll horizontally to see more of the timeline</p>
                                <div class="timeline-container-wrapper">
                                    <div class="timeline-wrapper" id="${assetId}">
                                         <div class="timeline-line"></div>
                                    </div>
                                </div>`;
                            mainContent.appendChild(assetContainer);
                            // Call the parameterized function
                            renderHybridTimeline(assetId, asset.data);
                            break;

                        case 'bar_chart':
                            assetContainer.innerHTML = `
                                <h1>Bar Chart</h1>
                                <div class="chart-container bar-chart-container">
                                    <canvas id="${assetId}"></canvas>
                                </div>`;
                            mainContent.appendChild(assetContainer);
                            // Call the parameterized function
                            renderBarChart(assetId, asset.data);
                            break;

                        case 'pie_chart':
                            const legendId = 'legend-' + assetId;
                            assetContainer.innerHTML = `
                                <h1>Pie Chart</h1>
                                <div class="chart-container pie-chart-wrapper">
                                    <div class="pie-chart-container">
                                        <canvas id="${assetId}"></canvas>
                                    </div>
                                    <div class="pie-legend-container" id="${legendId}"></div>
                                </div>`;
                            mainContent.appendChild(assetContainer);
                            // Call the parameterized function
                            renderPieChart(assetId, legendId, asset.data);
                            break;
                    }
                    mainContent.appendChild(assetContainer);
                });
            }

            // Render the "Tell me more" button if applicable
            if (parsedContent.showTellMeMore) {
                const tellMeMoreBtn = document.createElement('button');
                tellMeMoreBtn.className = 'tell-me-more-button';
                tellMeMoreBtn.innerHTML = `Tell me more about this <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14m0 0l-7-7m7 7l7-7"/></svg>`;
                tellMeMoreBtn.onclick = () => elaborateOnCurrent();
                mainContent.appendChild(tellMeMoreBtn);
            }
        }


        // Create card element
        // Update the function signature to accept isRead
        // Create card element
        // Update the function signature to accept isRead and childNodeId
        // Create card element
        // Update the function signature to accept isRead and childNodeId
        function createCard(section, index, isRead, childNodeId, parentNodeId) { 
            const card = document.createElement('div');
            card.className = 'card';
            
            const displayContent = section.content ? 
                (section.content.length > 80 ? section.content.substring(0, 80) + '...' : section.content) : '';
            
            card.innerHTML = `
                <div class="status-indicator ${isRead ? 'read' : ''}"></div>

                <h3>
                    ${section.title}
                </h3>
                ${displayContent ? `<p>${displayContent}</p>` : ''}
            `;
            
            // This now calls a new, more reliable function using the unique node ID
            if (childNodeId) {
                card.onclick = () => expandCardById(parentNodeId, childNodeId);
            }
            return card;
        }

        // Expand card
       // Replace the entire expandCard function
 // REPLACE the entire function
// Expand card by its unique ID, replacing the old title-based lookup
// Expand card
       // Replace the entire expandCard function
 // REPLACE the entire function
// Expand card by its unique ID, replacing the old title-based lookup
// Expand card by its unique ID, replacing the old title-based lookup
async function expandCardById(parentNodeId, nodeId) {
            // Find the parent node first to ensure we are in the correct context
            const parentNode = findNodeById(treeStructure, parentNodeId);
            if (!parentNode) {
                console.error("Could not find the parent node for the clicked card:", parentNodeId);
                showError("An error occurred: Cannot find the card's context.");
                return;
            }

            // Now, find the child node directly within that parent's children
            const childNodeToLoad = parentNode.children.find(child => child.id === nodeId);

            if (childNodeToLoad) {
                // Set the context based on the reliably found node
                currentContext.subtopic = childNodeToLoad.fullTitle;

                // This logic remains the same: check if content exists or fetch it
                if (childNodeToLoad.content) {
                    console.log("Content already exists. Navigating directly.");
                    navigateToNode(childNodeToLoad.id);
                } else {
                    console.log("Content does not exist. Fetching from API.");
                    await elaborateOnTopic(childNodeToLoad, false);
                }
            } else {
                console.error("Could not find the tree node corresponding to the clicked card ID:", nodeId, "within parent:", parentNodeId);
                showError("An error occurred trying to load this section.");
            }
        }

        // Update placeholder text
        function updatePlaceholder(hasQuestion) {
            const chatInput = document.getElementById('chatInput');
            chatInput.placeholder = hasQuestion ? "Any further questions?" : "Ask about finance or economics...";
        }

        // Elaborate on current context
        // This is the new, corrected function
async function elaborateOnCurrent() {
    // Get the full title of the current node we are viewing
    const currentTitle = currentTreeNode.fullTitle || currentTreeNode.title;

    if (currentTitle) {
        const question = `More about ${currentTitle}`;
        
        // Use the existing askQuestion function, which correctly creates a child node
        await askQuestion(question);
    }
}

        // Ask for elaboration
        // Elaborate on a specific topic, creating new sub-nodes in the tree
        // REPIACE the entire function
        async function elaborateOnTopic(targetNode, generateNewCards = false) {
    showSkeletonLoader(); // <-- ADD THIS LINE

    // The topic is now derived from the node we passed in.
    const topic = targetNode.fullTitle; 

    let contextPrompt = '';
    // Use the node's parent to establish context, which is more reliable.
    if (targetNode.parent && targetNode.parent.id !== 'root') {
        contextPrompt = `In the context of "${targetNode.parent.fullTitle}", `;
    }

    const elaborationPrompt = generateNewCards 
        ? `${contextPrompt}break down the sub-topic "${topic}" into a numbered list of 3-7 unique and compelling follow-up areas. Provide only the titles in a simple numbered list format. Do not add descriptions or bolding.`
        : `You are an expert educator who carries out tasks with precision and speed. Your task is to explain the topic "${topic}"${contextPrompt}.
        
Your response MUST be a single, valid JSON object with no other text before or after it.
The JSON object must have three keys: "explanation", "definitions", and an optional "visualAssets".

1.  In the "explanation" value, provide a detailed, explanation of the topic with at least 2 paragraphs.
2.  In the "definitions" value, provide an array of objects. For each object, identify a technical term from your explanation and provide a simple, one-sentence definition for it in the context of the topic. Only add/define these technical terms if they are truly technical and not straightforward, and their definition is specific to the context. Terms like focus, endurance, mental toughness which are obvious should not be included. 
3.  In the "visualAssets" value, (this key is optional), analyze your explanation. If a visual aid would enhance understanding, add this key. If not, OMIT this key entirely.
    * If included, it must be an array of objects. Each object represents one visual asset.
    * For each asset, provide a "type" and "data".

Here are the available asset types and their required data formats:

* **For a function graph (e.g., for math equations):**
    * "type": "implicit_plotter"
    * "data": (String) A single string with one or more equations separated by semicolons (e.g., "y=x^2; y=sin(x)").

* **For a timeline (for historical events, periods, or both):**
    * "type": "hybrid_timeline"
    * "data": (Array of Objects) An array of items. Each item must have a "type" key ('period' or 'event').
        * If type is 'period', include "name", "startStr", and "endStr".
        * If type is 'event', include "name" and "dateStr".
        * Example: [{ "type": "period", "name": "Roman Republic", "startStr": "509 BC", "endStr": "27 BC" }, { "type": "event", "name": "Caesar's Assassination", "dateStr": "44 BC" }]

* **For a bar chart:**
    * "type": "bar_chart"
    * "data": (String) A multi-line string with each line in "Label: Value" format.

* **For a pie chart:**
    * "type": "pie_chart"
    * "data": (String) A multi-line string with each line in "Label: Percentage" format.

Example JSON structure for a history topic:
{
  "explanation": "The Roman Republic was a significant era in ancient history...",
  "definitions": [{"term": "Senate", "definition": "The governing and advisory assembly of the aristocracy."}],
  "visualAssets": [
    {
      "type": "hybrid_timeline",
      "data": [
        { "type": "period", "name": "Roman Republic", "startStr": "509 BC", "endStr": "27 BC" },
        { "type": "event", "name": "Punic Wars", "dateStr": "264 BC" }
      ]
    }
  ]
}`;
    showLoading(true);

    try {
        conversationHistory.push({ role: "user", content: elaborationPrompt });
        pruneConversationHistory();

        const response = await fetch(BACKEND_URL + '/chat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ messages: conversationHistory })
        });

        if (!response.ok) throw new Error('Failed to get response');

        const data = await response.json();
        const botResponse = data.choices[0].message.content;
        conversationHistory.push({ role: "assistant", content: botResponse });

        // There is NO MORE GUESSWORK. We are working directly on the targetNode.
        
        let parsed;
        if (generateNewCards) {
            parsed = { overview: `Here are some deeper areas to explore.`, sections: parseSyllabusResponse(botResponse), definitions: [] };
            targetNode.children = [];
            parsed.sections.forEach(section => {
                createTreeNode(section.title, null, targetNode, false);
            });
            // --- START PRE-FETCHING FOR NEW QUESTION CARDS ---
            targetNode.children.forEach(childNode => {
                prefetchNodeContent(childNode);
            });
            // -----------------------------------------------

        } else {
            // --- REPLACE the old 'else' block content with this ---
            try {
                // The AI response should be a JSON string.
                const botResponseText = data.choices[0].message.content;
                const jsonMatch = botResponseText.match(/\{[\s\S]*\}/);
                if (!jsonMatch) throw new Error("No valid JSON object found in the AI response.");
                
                // Parse the JSON to get the explanation and definitions
                const structuredResponse = JSON.parse(jsonMatch[0]);
                const explanation = structuredResponse.explanation || "No explanation provided.";
                const definitions = structuredResponse.definitions || [];

                // Use our existing parseResponse function to format the text and package the data
                parsed = parseResponse(explanation, definitions);
                parsed.showTellMeMore = true;

            } catch (e) {
                console.error("Failed to parse structured response from AI:", e);
                // Fallback to plain text display if JSON fails
                parsed = parseResponse(data.choices[0].message.content, []);
            }
            // --- END OF REPLACEMENT ---
        }

        targetNode.content = parsed;
        navigateToNode(targetNode.id);
        saveTopicsToFirestore(); // Save the newly added content and children to Firestore


    } catch (error) {
        console.error("Error in elaborateOnTopic:", error);
        showError('Failed to get more information. Please try again.');
    } finally {
        showLoading(false);
    }
}

        // Send message
        async function sendMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            
            if (!message) return;
            
            await askQuestion(message);
            input.value = '';
        }

        // Ask question
        async function askQuestion(question) {
            showLoading(true);
            
            try {
                                // Create a new top-level node for the user's question
                const newNode = createTreeNode(
                    question.length > 50 ? question.substring(0, 50) + '...' : question,
                    null, // Content is initially null
                    currentTreeNode,
                    true
                );
                newNode.fullTitle = question;

                // Set the context immediately
                currentContext = { topic: question, subtopic: null, fullContent: null };

                // Now, call elaborateOnTopic to get the sub-topic cards for the question.
                // The "true" flag tells it to generate new cards.
                await elaborateOnTopic(newNode, true);

                updatePlaceholder(true);
                } catch (error) {
                console.error("Error in askQuestion:", error);
                // Display the specific error message we created in our check.
                showError(error.message || 'Failed to get response. Please check your connection.');
            } finally {
                showLoading(false);
            }
        }

        // Show loading state
        function showLoading(isLoading) {
            const sendButton = document.getElementById('sendButton');
            const buttonText = document.getElementById('buttonText');
            const input = document.getElementById('chatInput');
            
            if (isLoading) {
                sendButton.disabled = true;
                input.disabled = true;
                buttonText.textContent = 'Loading';
                if (!sendButton.querySelector('.loading-spinner')) {
                    const spinner = document.createElement('span');
                    spinner.className = 'loading-spinner';
                    sendButton.insertBefore(spinner, buttonText);
                }
            } else {
                sendButton.disabled = false;
                input.disabled = false;
                buttonText.textContent = 'Send';
                const spinner = sendButton.querySelector('.loading-spinner');
                if (spinner) spinner.remove();
            }
        }

        // Show error
        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            setTimeout(() => {
                errorDiv.style.display = 'none';
            }, 5000);
        }

        // Event listeners
        document.getElementById('chatInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });

        // Check backend connection
        // Check backend connection
// Check backend connection
async function checkConnection() {
            try {
                // This message is now created here and NOT added to the main conversation history.
                const testMessage = [{
                    role: "system",
                    content: "You are a health check assistant. If you receive the message 'test', respond with 'ok'."
                }, {
                    role: "user",
                    content: "test"
                }];

                const response = await fetch(BACKEND_URL + '/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        messages: testMessage
                    })
                });

                if (!response.ok) {
                    showError('Backend not connected. Please start your server.');
                }
            } catch (error) {
                showError('Backend not connected. Please start your server at ' + BACKEND_URL);
            }
        }

        // Initialize
        checkConnection();
        updateTreeVisualization();
        
        // Add initial navigation entry
        navigationHistory.push({
            node: treeStructure,
            content: null,
            context: {
                topic: 'Home',
                subtopic: null,
                fullContent: null
            }
        });
    
        currentHistoryIndex = 0;

        // New function to keep the conversation history from getting too long
        function pruneConversationHistory() {
            const maxHistoryLength = 5; // Keeps the system prompt + the last 2 Q&A pairs
            if (conversationHistory.length > maxHistoryLength) {
                // It keeps the first item (system prompt) and takes the last few items
                const keptHistory = conversationHistory.slice(-maxHistoryLength + 1);
                conversationHistory = [conversationHistory[0], ...keptHistory];
            }
        }
        // --- RESIZABLE SIDEBAR LOGIC ---

        // Wait until the document is fully loaded to run this script
        document.addEventListener('DOMContentLoaded', function () {
            // --- COLOR PALETTE FOR MULTI-LINE PLOTS ---
    const PLOT_COLORS = ['#6366f1', '#f59e0b', '#14b8a6', '#ef4444', '#8b5cf6', '#3b82f6'];


// --- ADVANCED DATE PARSING & SCALING (No Changes) ---
const isLeapYear = (year) => (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);
const getDayOfYear = (date) => {
    const start = new Date(date.getFullYear(), 0, 0);
    const diff = date.getTime() - start.getTime();
    const oneDay = 1000 * 60 * 60 * 24;
    return Math.floor(diff / oneDay);
};

const parseDateToFractionalYear = (dateStr) => {
    let cleanedStr = dateStr.replace(/c\.|ca\./, '').trim();
    const bcMatch = cleanedStr.match(/(\d+)\s*BC/i);
    if (bcMatch) return -parseInt(bcMatch[1], 10);
    
    cleanedStr = cleanedStr.replace(/AD/i, '').trim();

    const date = new Date(cleanedStr);
    if (!isNaN(date.getTime())) {
        const year = date.getFullYear();
        const daysInYear = isLeapYear(year) ? 366 : 365;
        const dayOfYear = getDayOfYear(date);
        return year + (dayOfYear / daysInYear);
    }
    
    const yearMatch = cleanedStr.match(/^-?\d+/);
    if (yearMatch) return parseInt(yearMatch[0], 10);

    return null;
};

            function renderPeriodTimeline() {
                const timelineWrapper = document.getElementById('period-timeline-wrapper');
                const timelineLine = timelineWrapper.querySelector('.timeline-line');
                timelineWrapper.innerHTML = '';
                timelineWrapper.appendChild(timelineLine);

                const dynastyData = [ { name: 'Xia', startStr: 'c. 2070 BC', endStr: 'c. 1600 BC' }, { name: 'Shang', startStr: 'c. 1600 BC', endStr: '1046 BC' }, { name: 'Zhou', startStr: '1046 BC', endStr: '256 BC' }, { name: 'Qin', startStr: '221 BC', endStr: '206 BC' }, { name: 'Han', startStr: '206 BC', endStr: '220 AD' }, { name: 'Three Kingdoms', startStr: '220 AD', endStr: '280 AD' }, { name: 'Jin', startStr: '266 AD', endStr: '420 AD' }, { name: 'Sui', startStr: '581 AD', endStr: '618 AD' }, { name: 'Tang', startStr: '618 AD', endStr: '907 AD' }, { name: 'Song', startStr: '960 AD', endStr: '1279 AD' }, { name: 'Yuan', startStr: '1271 AD', endStr: '1368 AD' }, { name: 'Ming', startStr: '1368 AD', endStr: '1644 AD' }, { name: 'Qing', startStr: '1644 AD', endStr: '1912 AD' }];
                
                const dynasties = dynastyData.map(d => ({
                    ...d,
                    startYear: parseDateToFractionalYear(d.startStr),
                    endYear: parseDateToFractionalYear(d.endStr),
                })).filter(d => d.startYear !== null && d.endYear !== null)
                   .map((d, i, arr) => ({
                    ...d,
                    duration: d.endYear - d.startYear,
                    gap: i > 0 ? d.startYear - arr[i-1].endYear : 0
                }));

                if (dynasties.length === 0) return;

                const compressionExponent = 0.5;
                const totalCompressedSpan = dynasties.reduce((sum, d) => {
                    return sum + Math.pow(Math.max(0, d.gap), compressionExponent) + Math.pow(Math.max(0, d.duration), compressionExponent);
                }, 0);

                const targetPixelWidth = 2000;
                const pixelsPerUnit = totalCompressedSpan > 0 ? targetPixelWidth / totalCompressedSpan : 0;
                const scaleValue = (value) => Math.pow(Math.max(0, value), compressionExponent) * pixelsPerUnit;

                let currentPos = 40;
                let lastTopEnd = -Infinity, lastBottomEnd = -Infinity;
                const verticalLevels = [25, 60, 95];
                let topLevel = 0, bottomLevel = 0;

                dynasties.forEach((dynasty) => {
                    const scaledGap = scaleValue(dynasty.gap);
                    const minCardWidth = 130;

                    const braceWidth = scaleValue(dynasty.duration);
                    const cardWidth = Math.max(braceWidth, minCardWidth);
                    
                    const braceStartPos = currentPos + scaledGap;
                    const cardStartPos = braceStartPos + (braceWidth - cardWidth) / 2;
                    
                    const endPos = braceStartPos + braceWidth;
                    const isTop = dynasties.indexOf(dynasty) % 2 === 0;

                    const eventElement = document.createElement('div');
                    eventElement.className = `timeline-event ${isTop ? 'top' : 'bottom'}`;
                    eventElement.innerHTML = `<div class="timeline-event-title">${dynasty.name}</div><div class="timeline-event-date">${dynasty.startStr} - ${dynasty.endStr}</div>`;
                    eventElement.style.left = `${cardStartPos}px`;
                    eventElement.style.width = `${cardWidth}px`;
                    
                    if (isTop) {
                        if (braceStartPos < lastTopEnd + 10) topLevel = (topLevel + 1) % verticalLevels.length;
                        eventElement.style.marginBottom = `${verticalLevels[topLevel]}px`;
                        lastTopEnd = endPos;
                    } else {
                        if (braceStartPos < lastBottomEnd + 10) bottomLevel = (bottomLevel + 1) % verticalLevels.length;
                        eventElement.style.marginTop = `${verticalLevels[bottomLevel]}px`;
                        lastBottomEnd = endPos;
                    }
                    timelineWrapper.appendChild(eventElement);

                    const brace = document.createElement('div');
                    brace.className = `period-brace ${isTop ? 'top' : 'bottom'}`;
                    brace.style.left = `${braceStartPos}px`;
                    brace.style.width = `${braceWidth}px`;
                    timelineWrapper.appendChild(brace);
                    
                    currentPos = endPos;
                });
                
                const totalWidth = currentPos + 40;
                timelineWrapper.style.width = `${totalWidth}px`;
                timelineLine.style.width = `${totalWidth}px`;
            }

            function renderHybridTimeline(wrapperId, hybridData) {
                    const timelineWrapper = document.getElementById(wrapperId);
                    if (!timelineWrapper) return; // Exit if the element doesn't exist
                    
                    const timelineLine = document.createElement('div');
                    timelineLine.className = 'timeline-line';
                    timelineWrapper.innerHTML = ''; // Clear previous content
                    timelineWrapper.appendChild(timelineLine);

                    // The rest of the function is the same, but it now uses the 'hybridData' parameter
                    const processedData = hybridData.map(d => {
                        if (d.type === 'period') {
                            const startYear = parseDateToFractionalYear(d.startStr);
                            const endYear = parseDateToFractionalYear(d.endStr);
                            return { ...d, startYear, endYear, duration: endYear - startYear };
                        } else { // type === 'event'
                            const year = parseDateToFractionalYear(d.dateStr);
                            return { ...d, year };
                        }
                    }).filter(d => {
                        return d.type === 'period' ? (d.startYear !== null && d.endYear !== null) : d.year !== null;
                    }).sort((a, b) => {
                        const yearA = a.type === 'period' ? a.startYear : a.year;
                        const yearB = b.type === 'period' ? b.startYear : b.year;
                        return yearA - yearB;
                    });

                    if (processedData.length === 0) return;

                    const compressionExponent = 0.5;
                    const scaleValue = (value) => Math.pow(Math.max(0, value), compressionExponent) * 4;

                    const periodVerticalLevel = 25;
                    const eventVerticalLevels = [85, 110, 150];
                    
                    let lastTopEnd = -Infinity, lastBottomEnd = -Infinity;
                    let eventTopLevel = 0, eventBottomLevel = 0;

                    let lastItemStartPos = 40;
                    let lastItemStartYear = processedData.length > 0 ? (processedData[0].type === 'period' ? processedData[0].startYear : processedData[0].year) : 0;
                    
                    let activePeriod = null;

                    processedData.forEach((item, index) => {
                        const isTop = index % 2 === 0;
                        let itemStartPos = 0;
                        const currentItemStartYear = item.type === 'period' ? item.startYear : item.year;

                        if (activePeriod && currentItemStartYear < activePeriod.endYear && currentItemStartYear > activePeriod.startYear) {
                            const timeFromPeriodStart = currentItemStartYear - activePeriod.startYear;
                            const periodDuration = activePeriod.endYear - activePeriod.startYear;
                            const percentageThrough = periodDuration > 0 ? timeFromPeriodStart / periodDuration : 0;
                            itemStartPos = activePeriod.startPos + (percentageThrough * activePeriod.braceWidth);
                        } else {
                            const timeFromLastItem = currentItemStartYear - lastItemStartYear;
                            itemStartPos = lastItemStartPos + scaleValue(timeFromLastItem);
                            activePeriod = null;
                        }

                        if (item.type === 'period') {
                            const minCardWidth = 130;
                            const braceWidth = scaleValue(item.duration);
                            const cardWidth = Math.max(braceWidth, minCardWidth);
                            const cardStartPos = itemStartPos + (braceWidth - cardWidth) / 2;
                            const itemEndPos = itemStartPos + braceWidth;

                            const eventElement = document.createElement('div');
                            eventElement.className = `timeline-event ${isTop ? 'top' : 'bottom'}`;
                            eventElement.innerHTML = `<div class="timeline-event-title">${item.name}</div><div class="timeline-event-date">${item.startStr} - ${item.endStr}</div>`;
                            eventElement.style.left = `${cardStartPos}px`;
                            eventElement.style.width = `${cardWidth}px`;

                            if (isTop) {
                                eventElement.style.marginBottom = `${periodVerticalLevel}px`;
                                lastTopEnd = itemEndPos;
                            } else {
                                eventElement.style.marginTop = `${periodVerticalLevel}px`;
                                lastBottomEnd = itemEndPos;
                            }
                            timelineWrapper.appendChild(eventElement);
                            
                            const brace = document.createElement('div');
                            brace.className = `period-brace ${isTop ? 'top' : 'bottom'}`;
                            brace.style.left = `${itemStartPos}px`;
                            brace.style.width = `${braceWidth}px`;
                            timelineWrapper.appendChild(brace);

                            activePeriod = { startYear: item.startYear, endYear: item.endYear, startPos: itemStartPos, braceWidth: braceWidth };

                        } else { // type === 'event'
                            const cardWidth = 140;

                            const eventElement = document.createElement('div');
                            eventElement.className = `hybrid-event ${isTop ? 'top' : 'bottom'}`;
                            eventElement.style.left = `${itemStartPos}px`;
                            eventElement.style.transform = 'translateX(-50%)';
                            eventElement.innerHTML = `<div class="hybrid-event-title">${item.name}</div><div class="hybrid-event-date">${item.dateStr}</div>`;
                            
                            const connector = document.createElement('div');
                            connector.className = `hybrid-event-connector ${isTop ? 'top' : 'bottom'}`;

                            let currentEventLevel;
                            if (isTop) {
                                if (itemStartPos - cardWidth / 2 < lastTopEnd + 10) eventTopLevel = (eventTopLevel + 1) % eventVerticalLevels.length;
                                currentEventLevel = eventVerticalLevels[eventTopLevel];
                                eventElement.style.marginBottom = `${currentEventLevel}px`;
                                lastTopEnd = itemStartPos + cardWidth / 2;
                            } else {
                                if (itemStartPos - cardWidth / 2 < lastBottomEnd + 10) eventBottomLevel = (eventBottomLevel + 1) % eventVerticalLevels.length;
                                currentEventLevel = eventVerticalLevels[eventBottomLevel];
                                eventElement.style.marginTop = `${currentEventLevel}px`;
                                lastBottomEnd = itemStartPos + cardWidth / 2;
                            }
                            
                            connector.style.setProperty('--connector-height', `${currentEventLevel}px`);
                            eventElement.appendChild(connector);
                            timelineWrapper.appendChild(eventElement);
                        }

                        lastItemStartPos = itemStartPos;
                        lastItemStartYear = currentItemStartYear;
                    });

                    const totalWidth = lastItemStartPos + 200;
                    timelineWrapper.style.width = `${totalWidth}px`;
                    timelineLine.style.width = `${totalWidth}px`;
                }
            
            function renderEventTimeline() {
                const timelineWrapper = document.getElementById('event-timeline-wrapper');
                const timelineLine = timelineWrapper.querySelector('.timeline-line');
                timelineWrapper.innerHTML = ''; 
                timelineWrapper.appendChild(timelineLine);
                
                const inventionData = [ { name: 'The Wheel', dateStr: 'c. 3500 BC' }, { name: 'Written Language', dateStr: 'c. 3200 BC' }, { name: 'Iron Smelting', dateStr: 'c. 1200 BC' }, { name: 'Compass', dateStr: 'c. 200 BC' }, { name: 'Paper', dateStr: 'c. 105 AD' }, { name: 'Printing Press', dateStr: '1440 AD' }, { name: 'Telescope', dateStr: '1608 AD' }, { name: 'Steam Engine', dateStr: '1712 AD' }, { name: 'Telephone', dateStr: '1876 AD' }, { name: 'Light Bulb', dateStr: '1879 AD' }, { name: 'Computer', dateStr: '1943 AD' }, { name: 'Internet (ARPANET)', dateStr: '1969 AD' }];
                
                const inventions = inventionData.map(d => ({
                    ...d,
                    year: parseDateToFractionalYear(d.dateStr)
                })).filter(d => d.year !== null)
                   .map((d, i, arr) => ({
                    ...d,
                    gap: i > 0 ? d.year - arr[i-1].year : 0
                }));

                if (inventions.length < 2) return;
                
                const compressionExponent = 0.75;
                const totalCompressedSpan = inventions.reduce((sum, d) => {
                    return sum + Math.pow(Math.max(0, d.gap), compressionExponent);
                }, 0);
                
                const targetPixelWidth = 2000;
                const pixelsPerUnit = totalCompressedSpan > 0 ? targetPixelWidth / totalCompressedSpan : 0;
                const scaleValue = (value) => Math.pow(Math.max(0, value), compressionExponent) * pixelsPerUnit;
                
                let currentPos = 80;
                let lastTopEnd = -Infinity, lastBottomEnd = -Infinity;
                const verticalLevels = [25, 65, 105];
                let topLevel = 0, bottomLevel = 0;

                inventions.forEach((invention, index) => {
                    const scaledGap = scaleValue(invention.gap);
                    const eventPosition = currentPos + scaledGap;
                    const isTop = index % 2 === 0;
                    const cardWidth = 140;

                    const eventElement = document.createElement('div');
                    eventElement.className = `timeline-event event-style ${isTop ? 'top' : 'bottom'}`;
                    eventElement.innerHTML = `<div class="timeline-event-title">${invention.name}</div><div class="timeline-event-date">${invention.dateStr}</div>`;
                    eventElement.style.left = `${eventPosition}px`;
                    eventElement.style.transform = 'translateX(-50%)';

                    let currentLevel;
                    if (isTop) {
                        if (eventPosition - cardWidth / 2 < lastTopEnd + 10) topLevel = (topLevel + 1) % verticalLevels.length;
                        currentLevel = verticalLevels[topLevel];
                        eventElement.style.marginBottom = `${currentLevel}px`;
                        lastTopEnd = eventPosition + cardWidth / 2;
                    } else {
                        if (eventPosition - cardWidth / 2 < lastBottomEnd + 10) bottomLevel = (bottomLevel + 1) % verticalLevels.length;
                        currentLevel = verticalLevels[bottomLevel];
                        eventElement.style.marginTop = `${currentLevel}px`;
                        lastBottomEnd = eventPosition + cardWidth / 2;
                    }

                    eventElement.style.setProperty('--connector-height', `${currentLevel}px`);
                    timelineWrapper.appendChild(eventElement);
                    
                    currentPos = eventPosition;
                });
                
                const totalWidth = currentPos + 80;
                timelineWrapper.style.width = `${totalWidth}px`;
                timelineLine.style.width = `${totalWidth}px`;
            }

            let barChartInstance;
                function renderBarChart(canvasId, dataString) {
                    const ctx = document.getElementById(canvasId).getContext('2d');
                    
                    const lines = dataString.trim().split('\n');
                    const labels = [];
                    const data = [];
                    let maxValue = 0;
    
                    lines.forEach(line => {
                        const parts = line.split(':');
                        if (parts.length === 2) {
                            const label = parts[0].trim();
                            const value = parseFloat(parts[1].trim());
                            if (label && !isNaN(value)) {
                                labels.push(label);
                                data.push(value);
                                if (value > maxValue) {
                                    maxValue = value;
                                }
                            }
                        }
                    });
                    
                    const suggestedMax = maxValue * 1.1;
    
                    if (barChartInstance) { barChartInstance.destroy(); }
    
                    barChartInstance = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: labels,
                            datasets: [{
                                label: 'Value',
                                data: data,
                                backgroundColor: 'rgba(99, 102, 241, 0.6)',
                                borderColor: 'rgba(99, 102, 241, 1)',
                                borderWidth: 1,
                                borderRadius: 4
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false },
                                tooltip: { callbacks: { label: (context) => ` ${context.raw}` } }
                            },
                            scales: {
                                y: { beginAtZero: true, suggestedMax: suggestedMax, grid: { color: '#e5e7eb' } },
                                x: { grid: { display: false } }
                            }
                        }
                    });
                }

                let pieChartInstance;
                function renderPieChart(canvasId, legendId, dataString) {
                    const legendContainer = document.getElementById(legendId);
                    const ctx = document.getElementById(canvasId).getContext('2d');
                    
                    const lines = dataString.trim().split('\n');
                    const labels = [];
                    let data = [];
                    
                    lines.forEach(line => {
                        const parts = line.split(':');
                        if (parts.length === 2) {
                            const label = parts[0].trim();
                            const value = parseFloat(parts[1].trim());
                            if (label && !isNaN(value)) {
                                labels.push(label);
                                data.push(value);
                            }
                        }
                    });
    
                    const total = data.reduce((sum, val) => sum + val, 0);
                    if (total > 0) { data = data.map(val => (val / total) * 100); }
                    
                    const backgroundColors = [ '#8b5cf6', '#6366f1', '#3b82f6', '#14b8a6', '#f59e0b', '#ef4444', '#ec4899'];
    
                    if (pieChartInstance) { pieChartInstance.destroy(); }
    
                    pieChartInstance = new Chart(ctx, {
                        type: 'pie',
                        data: {
                            labels: labels,
                            datasets: [{ data: data, backgroundColor: backgroundColors, borderColor: '#ffffff', borderWidth: 2 }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false },
                                tooltip: { callbacks: { label: (context) => ` ${context.label}: ${context.raw.toFixed(1)}%` } }
                            }
                        }
                    });
    
                    legendContainer.innerHTML = '';
                    labels.forEach((label, index) => {
                        const item = document.createElement('div');
                        item.className = 'legend-item';
                        const colorBox = document.createElement('div');
                        colorBox.className = 'legend-color-box';
                        colorBox.style.backgroundColor = backgroundColors[index % backgroundColors.length];
                        const text = document.createElement('span');
                        text.textContent = label;
                        item.appendChild(colorBox);
                        item.appendChild(text);
                        legendContainer.appendChild(item);
                    });
                }

          
            
            

            // --- Z-INDEX MANAGEMENT FOR OVERLAPPING CARDS ---
            let highestZIndex = 10;
            function bringCardToFront(event) {
                const card = event.target.closest('.timeline-event');
                if (card) {
                    highestZIndex++;
                    card.style.zIndex = highestZIndex;
                }
            }
            
        
            const handle = document.getElementById('dragHandle');
            const sidebar = document.getElementById('treeSidebar');
            
            // A flag to check if we are currently dragging
            let isDragging = false;
            let startX;
            let startWidth;

            // When the mouse button is pressed down on the handle
            handle.addEventListener('mousedown', function (e) {
                // Prevent default browser actions, like text selection
                e.preventDefault();
                
                isDragging = true;
                startX = e.clientX; // Record the initial mouse X position
                startWidth = parseInt(document.defaultView.getComputedStyle(sidebar).width, 10); // Record the initial width of the sidebar
                
                // Add listeners to the whole document to track mouse movement and release
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
                
                // Add a style to the body to prevent text selection during drag
                document.body.style.userSelect = 'none';
                document.body.style.pointerEvents = 'none'; // Prevents other elements from interfering
            });

            // When the mouse is moved anywhere on the page
            function handleMouseMove(e) {
                if (!isDragging) return;
                
                // Calculate the distance the mouse has moved
                const dx = e.clientX - startX;
                
                // Calculate the new width and apply it.
                // We enforce a minimum and maximum width to prevent the layout from breaking.
                const newWidth = Math.max(200, Math.min(600, startWidth + dx));
                sidebar.style.width = newWidth + 'px';
            }

            // When the mouse button is released
            function handleMouseUp() {
                if (!isDragging) return;
                
                isDragging = false;
                
                // IMPORTANT: Remove the listeners from the document
                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);

                // Restore the default body styles
                document.body.style.userSelect = '';
                document.body.style.pointerEvents = '';
            }
             // --- NEW: DOM Element References ---
         const landingView = document.getElementById('landingView');
        const learningView = document.getElementById('learningView');
        const newTopicModal = document.getElementById('newTopicModal');
        // --- NEW: Event Listeners ---
document.getElementById('newTopicBtn').addEventListener('click', openNewTopicModal);
document.getElementById('cancelTopicBtn').addEventListener('click', closeNewTopicModal);
document.getElementById('submitTopicBtn').addEventListener('click', handleNewTopicSubmit);
document.getElementById('mainMenuBtn').addEventListener('click', () => {
    renderTopicCards(); // Redraw the landing page

    switchView('landingView');
});
// Handle clicks on the sophistication slider
document.getElementById('sophisticationSlider').addEventListener('click', (e) => {
    if (e.target.classList.contains('sophistication-option')) {
        // Remove 'active' from all options
        document.querySelectorAll('.sophistication-option').forEach(opt => opt.classList.remove('active'));
        // Add 'active' to the clicked option
        e.target.classList.add('active');
    }
});

// Close modal if user clicks on the overlay background
newTopicModal.addEventListener('click', (e) => {
    if (e.target === newTopicModal) {
        closeNewTopicModal();
    }
});

// Initialize the app on the landing page
switchView('landingView');
// --- FINAL REVISION: Tooltip Repositioning Logic ---
const mainContent = document.getElementById('mainContent');

mainContent.addEventListener('mouseover', (event) => {
    const term = event.target.closest('.technical-term');
    if (!term) return;

    const tooltip = term.querySelector('.term-tooltip');
    if (!tooltip) return;

    // Make the tooltip visible
    tooltip.classList.add('visible');

    // Defer the measurement to prevent timing issues, ensuring the element is rendered.
    requestAnimationFrame(() => {
        // **THE FIX**: Get the bounding box of the main content area, which is the actual boundary.
        const containerRect = mainContent.getBoundingClientRect();
        const tooltipRect = tooltip.getBoundingClientRect();
        const PADDING = 15; // A little more space from the edge

        let deltaX = 0;
        
        // Check for overflow against the CONTAINER's right edge
        if (tooltipRect.right > containerRect.right - PADDING) {
            deltaX = (containerRect.right - PADDING) - tooltipRect.right;
        } 
        // Check for overflow against the CONTAINER's left edge
        else if (tooltipRect.left < containerRect.left + PADDING) {
            deltaX = (containerRect.left + PADDING) - tooltipRect.left;
        }

        // Apply the calculated shift if necessary
        if (deltaX !== 0) {
            tooltip.style.transform = `translateX(${deltaX}px)`;
        }
    });
});

mainContent.addEventListener('mouseout', (event) => {
    const term = event.target.closest('.technical-term');
    if (!term) return;

    const tooltip = term.querySelector('.term-tooltip');
    if (tooltip) {
        // Hide the tooltip
        tooltip.classList.remove('visible');
        // Reset the transform so it can be recalculated on the next hover
        tooltip.style.transform = '';
    }
});
// --- END OF FINAL REVISION ---


        });
        // Checks if all children of a node are read and updates the parent's status
        function updateParentReadStatus(parentNode) {
            // Do nothing if there's no parent or the parent has no children
            if (!parentNode || !parentNode.children || parentNode.children.length === 0) {
                return;
            }

            // Check if every child node is marked as read
            const allChildrenAreRead = parentNode.children.every(child => child.isRead);

            // Update the parent's read status
            parentNode.isRead = allChildrenAreRead;
        }
        // --- STAGE 1 & 2: Get the button and listen for a click ---

// Get a reference to the HTML button with the id 'googleSignInBtn'
const googleSignInBtn = document.getElementById('googleSignInBtn');

// Tell the button to listen for a 'click' and run the code inside when it happens
googleSignInBtn.addEventListener('click', () => {
    
    // --- STAGE 3: Define the action to perform on click ---

    // Clear out any old error messages from previous attempts
    authError.textContent = ''; 

    // This command opens the Google Sign-in popup window
    auth.signInWithPopup(googleProvider)

        // --- STAGE 4: Handle the result (Success or Failure) ---

        // The .then() block runs ONLY if the sign-in was successful
        .then((result) => {
            console.log("Google Sign-in successful!", result.user.displayName);

            // IMPORTANT: You don't need to do anything else here to show the app.
            // The 'onAuthStateChanged' function is always listening in the background.
            // It will automatically detect this successful login and show your app.
        })

        // The .catch() block runs ONLY if there was an error
        .catch((error) => {
            console.error("Google Sign-in error:", error.message);
            
            // It's helpful to show the error message to the user on the screen.
            authError.textContent = error.message; 
        });
});
function renderImplicitPlotter(container, dataString) {
                // Create the plotter's HTML structure
                container.innerHTML = `
                    <h1>Implicit Function Plotter</h1>
                    <div id="graphContainer">
                        <canvas id="functionGraph"></canvas>
                        <div class="zoom-controls">
                            <button id="zoomInBtn" class="zoom-btn" title="Zoom in">+</button>
                            <button id="zoomOutBtn" class="zoom-btn" title="Zoom out">-</button>
                        </div>
                    </div>
                    <div class="equation-input-wrapper">
                        <label for="equationInput">Enter one or more implicit equations, separated by a semicolon (;)</label>
                        <input type="text" id="equationInput" class="equation-input" placeholder="x^2+y^2=16; y=sin(x)">
                        <p id="error-message"></p>
                    </div>
                `;

                // --- Re-initialize the plotter logic for this specific instance ---
                const canvas = container.querySelector('#functionGraph');
                const ctx = canvas.getContext('2d');
                const equationInput = container.querySelector('#equationInput');
                const errorMessage = container.querySelector('#error-message');
                const graphContainer = container.querySelector('#graphContainer');
                
                // Set the initial equation from the AI
                equationInput.value = dataString;

                let scale = 40, origin = { x: 0, y: 0 }, view = { minX: -10, maxX: 10, minY: -10, maxY: 10 };
                let isGraphDragging = false, lastMousePos = { x: 0, y: 0 };
                let plotObjects = [];
                let plotTimeout;

                const resizeObserver = new ResizeObserver(entries => {
                    if (!entries || !entries.length) return;
                    const { width, height } = entries[0].contentRect;
                    canvas.width = width; canvas.height = height;
                    if(width === 0 || height === 0) return;
                    origin.x = width / 2; origin.y = height / 2;
                    updateView();
                    calculateAndDrawEquations();
                });
                resizeObserver.observe(graphContainer);
                
                const toScreenX = (x) => origin.x + x * scale;
                const toScreenY = (y) => origin.y - y * scale;
                const toGraphX = (x) => (x - origin.x) / scale;
                const toGraphY = (y) => (y - origin.y) / -scale;
                
                function updateView() {
                    view.minX = toGraphX(0); view.maxX = toGraphX(canvas.width);
                    view.minY = toGraphY(canvas.height); view.maxY = toGraphY(0);
                }

                function drawGrid() {
                    if (!ctx) return;
                    ctx.beginPath(); ctx.strokeStyle = '#e5e7eb'; ctx.lineWidth = 1;
                    const step = Math.pow(10, Math.floor(Math.log10(70 / scale)));
                    for (let x = Math.floor(view.minX / step) * step; x < view.maxX; x += step) {
                        const screenX = Math.round(toScreenX(x));
                        ctx.moveTo(screenX, 0); ctx.lineTo(screenX, canvas.height);
                    }
                    for (let y = Math.floor(view.minY / step) * step; y < view.maxY; y += step) {
                        const screenY = Math.round(toScreenY(y));
                        ctx.moveTo(0, screenY); ctx.lineTo(canvas.width, screenY);
                    }
                    ctx.stroke();
                }

                function drawAxes() { /* ... same as before ... */ }
                function drawLabels() { /* ... same as before ... */ }
                function drawPlot(objects) { /* ... same as before ... */ }
                function calculatePaths(expression) { /* ... same as before ... */ }
                function tracePath(startPoint, func, derivX, derivY, visited, dx, dy) { /* ... same as before ... */ }
                
                function draw() { requestAnimationFrame(() => { if(!ctx) return; ctx.clearRect(0, 0, canvas.width, canvas.height); drawGrid(); drawAxes(); drawLabels(); drawPlot(plotObjects); }); }
                
                function zoomOnPoint(zoomFactor, centerX, centerY) {
                    const graphX = toGraphX(centerX);
                    const graphY = toGraphY(centerY);
                    scale *= zoomFactor;
                    origin.x = centerX - graphX * scale;
                    origin.y = centerY + graphY * scale;
                    updateView();
                    draw();
                    clearTimeout(plotTimeout);
                    plotTimeout = setTimeout(calculateAndDrawEquations, 150);
                }

                function calculateAndDrawEquations() {
                    errorMessage.textContent = '';
                    const equationStrings = equationInput.value.split(';').filter(s => s.trim() !== '');
                    plotObjects = [];
                    equationStrings.forEach((eq, index) => {
                        const paths = calculatePaths(eq);
                        if (paths.length > 0) {
                            plotObjects.push({
                                paths: paths,
                                color: PLOT_COLORS[index % PLOT_COLORS.length]
                            });
                        }
                    });
                    draw();
                }

                canvas.addEventListener('mousedown', (e) => { isGraphDragging = true; lastMousePos = { x: e.offsetX, y: e.offsetY }; });
                canvas.addEventListener('mousemove', (e) => { if (!isGraphDragging) return; const dx = e.offsetX - lastMousePos.x, dy = e.offsetY - lastMousePos.y; origin.x += dx; origin.y += dy; lastMousePos = { x: e.offsetX, y: e.offsetY }; updateView(); draw(); });
                canvas.addEventListener('mouseup', () => { if (!isGraphDragging) return; isGraphDragging = false; calculateAndDrawEquations(); });
                canvas.addEventListener('mouseleave', () => { if(isGraphDragging) { isGraphDragging = false; calculateAndDrawEquations(); } });
                canvas.addEventListener('wheel', (e) => { e.preventDefault(); const zoomFactor = e.deltaY < 0 ? 1.2 : 1 / 1.2; zoomOnPoint(zoomFactor, e.offsetX, e.offsetY); });
                
                container.querySelector('#zoomInBtn').addEventListener('click', () => { zoomOnPoint(1.3, canvas.width / 2, canvas.height / 2); });
                container.querySelector('#zoomOutBtn').addEventListener('click', () => { zoomOnPoint(1 / 1.3, canvas.width / 2, canvas.height / 2); });
                
                equationInput.addEventListener('input', () => {
                    clearTimeout(plotTimeout);
                    plotTimeout = setTimeout(calculateAndDrawEquations, 300);
                });

                // Initial calculation
                calculateAndDrawEquations();
            }
    </script>
    <!-- New Topic Modal -->
<div class="modal-overlay" id="newTopicModal">
    <div class="modal-content">
        <h2>Start a New Topic</h2>
        <label for="topicInput">I want to learn about:</label>
        <input type="text" id="topicInput" class="modal-input" placeholder="e.g., 'Quantum Physics' or 'Ancient Rome'">

        <label>Sophistication Level:</label>
        <div class="sophistication-slider" id="sophisticationSlider">
            <div class="sophistication-option active" data-level="Simple">Simple</div>
            <div class="sophistication-option" data-level="Detailed">Detailed</div>
            <div class="sophistication-option" data-level="Expert">Expert</div>
        </div>

        <div class="modal-actions">
            <button class="modal-btn cancel" id="cancelTopicBtn">Cancel</button>
            <button class="modal-btn submit" id="submitTopicBtn">Submit</button>
        </div>
    </div>
</div>
<div class="modal-overlay" id="quizModal">
    <div class="modal-content" style="max-width: 700px;">
        <h2 id="quizTitle">Topic Quiz</h2>
        <div id="quizArea">
            <p id="quizQuestionText" style="font-size: 18px; margin-bottom: 25px;"></p>
            <div id="quizOptions" class="cards-grid" style="grid-template-columns: 1fr; gap: 10px;">
                </div>
            <p id="quizFeedback" style="margin-top: 20px; font-weight: 600;"></p>
        </div>
        <div id="quizResults" style="display: none;">
            <h3>Quiz Complete!</h3>
            <p id="quizScoreText" style="font-size: 24px; margin: 20px 0;"></p>
        </div>
        <div class="modal-actions" style="margin-top: 30px;">
             <button class="modal-btn cancel" onclick="closeQuizModal()">Close</button>
             <button class="modal-btn submit" id="quizSubmitBtn">Submit</button>
        </div>
    </div>
</div>
<div class="modal-overlay" id="deleteConfirmModal">
    <div class="modal-content">
        <h2>Confirm Deletion</h2>
        <p style="margin-bottom: 30px; font-size: 16px; color: #4b5563; text-align: center;">
            Are you sure you want to permanently delete this topic and all of its content? This action cannot be undone.
        </p>
        <div class="modal-actions">
            <button class="modal-btn cancel" id="cancelDeleteBtn">Cancel</button>
            <button class="modal-btn delete" id="confirmDeleteBtn">Confirm Delete</button>
        </div>
    </div>
</div>
</body>
</html>
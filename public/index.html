<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Learning Tool</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css" integrity="sha384-wcIxkf4k558AjM3Yz3BBFQUbk/zgIYC2R0QpeeYb+TwlBVMrlgLqwRjRtGZiK7ww" crossorigin="anonymous" defer>    
    
    <script  src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js" integrity="sha384-hIoBPJpTUs74ddyc4bFZSM1TVlQDA60VBbJS0oA934VSz82sBx1X7kSx2ATBDIyd" crossorigin="anonymous" defer></script> 
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js" integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk" crossorigin="anonymous" defer></script>    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.4.2/math.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js" defer></script>

            <style>
                
                * {
                    margin: 0;
                    padding: 0;
                    box-sizing: border-box;
                }
        
                body {
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    /* CHANGE: Switched to a light gray background */
                    background: #f9fafb;
                    min-height: 100vh;
                    /* CHANGE: Switched to a dark gray for primary text */
                    color: #374151;
                    overflow: hidden;
                }
                /* --- NEW: View & Landing Page Styles --- */
                .view {
                    width: 100%;
                    height: 100vh;
                    display: none; /* Keep hidden by default */
                }
        
                .view.active {
                    display: flex; /* Show the active view */
                }

                /* --- CHANGE 1: BREADCRUMB HEIGHT ADJUSTMENT --- */
.breadcrumb {
    /* We reduce the vertical padding from 15px to 10px to match the nav buttons */
    padding: 10px 25px; 
}

/* --- CHANGE 2: STYLES FOR THE NEW DELETE BUTTON --- */

/* Style for the new delete button in the nav bar */
#deleteTopicBtn {
    background: #ffffff;
    color: #ef4444; /* A nice red color for the icon */
    border: 2px solid #e5e7eb;
    padding: 10px; /* Make padding equal for a square look */
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    margin-left: 15px; /* Add some space between it and the breadcrumb */
}

#deleteTopicBtn:hover {
    background: #fee2e2; /* A light red background on hover */
    border-color: #ef4444;
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(239, 68, 68, 0.2);
}

/* Style for the 'Confirm Delete' button in the modal */
.modal-btn.delete {
    background: #dc2626; /* A strong red for the confirmation button */
    color: white;
}
.modal-btn.delete:hover {
    background: #b91c1c; /* A darker red on hover */
}
        
                #landingView {
                    flex-direction: column;
                    align-items: center;
                    padding: 40px;
                    overflow-y: auto;
                }
        
                .landing-header {
                    width: 100%;
                    max-width: 1200px;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    margin-bottom: 40px;
                    flex-shrink: 0;
                }
        
                .landing-header h1 {
                    font-size: 32px;
                    font-weight: 700;
                    /* CHANGE: Darker text for headers */
                    color: #11182c;
                }
        
                .new-topic-btn {
                    background: linear-gradient(135deg, #191970 0%, #34495e 100%);
                    color: white;
                    border: none;
                    padding: 12px 24px;
                    border-radius: 10px;
                    cursor: pointer;
                    font-size: 16px;
                    font-weight: 600;
                    transition: all 0.3s ease;
                    display: inline-flex;
                    align-items: center;
                    gap: 8px;
                }
        
                .new-topic-btn:hover {
                    transform: translateY(-2px);
                    box-shadow: 0 5px 15px rgba(93, 109, 126, 0.4);
                }
        
                #topicGrid {
                    width: 100%;
                    max-width: 1200px;
                    display: grid;
                    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
                    gap: 20px;
                }
                #topicGrid {
    width: 100%;
    max-width: 1200px;
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 20px;
}
/* --- Add this new rule to your <style> block --- */
    #topicGrid.empty {
    display: flex;
    justify-content: center;
    align-items: center;
    /* Sets the grid to take up a significant portion of the view height */
    min-height: 60vh; 
}

/* --- ADD THESE NEW STYLES FOR THE TOPIC CARD --- */
.topic-card {
    background: #ffffff; /* White background for the card */
    border: 1px solid #e5e7eb; /* Light gray border for the outline */
    border-radius: 16px; /* Rounded corners */
    padding: 25px; /* Space inside the card */
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05); /* Subtle shadow */
}

.topic-card:hover {
    transform: translateY(-5px); /* Lifts the card up on hover */
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1); /* Stronger shadow on hover */
    border-color: #191970; /* Purple border on hover */
}

.topic-card h2 {
    font-size: 20px;
    color: #11182c; /* Dark text for the title */
    margin-bottom: 8px;
}

.topic-card p {
    font-size: 14px;
    color: #6b7280; /* Medium gray for the description */
    line-height: 1.4;
}
        
                /* --- NEW: Modal Styles --- */
                .modal-overlay {
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.5); /* Kept dark overlay for contrast */
                    backdrop-filter: blur(5px);
                    display: none; /* Use display instead of visibility */
                    justify-content: center;
                    align-items: center;
                    z-index: 2000;
                    animation: fadeIn 0.3s ease;
                }
        
                .modal-overlay.active {
                    display: flex; /* Use flex to center the content */
                }
        
                .modal-content {
                    /* CHANGE: White modal background */
                    background: #ffffff;
                    padding: 40px;
                    border-radius: 20px;
                    width: 90%;
                    max-width: 500px;
                    /* CHANGE: Light border */
                    border: 1px solid #e5e7eb;
                    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
                    animation: fadeIn 0.3s ease; /* Match existing fadeIn */
                }
        
                .modal-content h2 {
                    font-size: 24px;
                    margin-bottom: 15px;
                    text-align: center;
                    /* CHANGE: Darker text for modal headers */
                    color: #11182c;
                }
        
                .modal-content label {
                    display: block;
                    font-size: 14px;
                    /* CHANGE: Medium gray for labels */
                    color: #6b7280;
                    margin-bottom: 8px;
                }
        
                .modal-input {
                    width: 100%;
                    padding: 12px 15px;
                    /* CHANGE: Lighter background for input */
                    background: #f3f4f6;
                    /* CHANGE: Light border */
                    border: 1px solid #d1d5db;
                    /* CHANGE: Dark text for input */
                    color: #11182c;
                    border-radius: 8px;
                    font-size: 16px;
                    margin-bottom: 25px;
                    transition: all 0.2s ease;
                }
        
                .modal-input:focus {
                    outline: none;
                    border-color: #191970;
                    box-shadow: 0 0 0 3px rgba(93, 109, 126, 0.1);
                }
        
                .sophistication-slider {
                    display: flex;
                    border-radius: 8px;
                    overflow: hidden;
                    /* CHANGE: Light border */
                    border: 1px solid #d1d5db;
                    margin-bottom: 30px;
                }
        
                .sophistication-option {
                    flex: 1;
                    text-align: center;
                    padding: 12px;
                    cursor: pointer;
                    /* CHANGE: Lighter background for sophistication options */
                    background: #f3f4f6;
                    /* CHANGE: Medium gray text */
                    color: #6b7280;
                    transition: background 0.2s ease;
                    font-weight: 500;
                }
        
                .sophistication-option.active {
                    background: #191970;
                    color: white;
                    font-weight: 600;
                }
        
                .modal-actions {
                    display: flex;
                    justify-content: center;
                    gap: 15px;
                }
        
                .modal-btn {
                    padding: 10px 20px;
                    border: none;
                    border-radius: 8px;
                    font-size: 16px;
                    font-weight: 600;
                    cursor: pointer;
                    transition: background 0.2s ease;
                }
        
                .modal-btn.cancel {
                    /* CHANGE: Light gray background for cancel button */
                    background: #e5e7eb;
                    /* CHANGE: Dark gray text */
                    color: #374151;
                }
                .modal-btn.cancel:hover {
                    /* CHANGE: Slightly darker gray on hover */
                    background: #d1d5db;
                }
        
                .modal-btn.submit {
                    background: #191970;
                    color: white;
                }
                .modal-btn.submit:hover {
                    background: #34495e;
                }
        
                .app-wrapper {
                    display: flex;
                    width: 100%;
                    height: 100vh;
                }
        
                .tree-sidebar {
                    width: 320px;
                    /* CHANGE: White background for sidebar */
                    background: #ffffff;
                    box-shadow: 4px 0 20px rgba(0, 0, 0, 0.05);
                    padding: 10px;
                    overflow-x: auto;
                    overflow-y: auto;
                    /* CHANGE: Light border */
                    border-right: 1px solid #e5e7eb;
                    display: flex;
                    flex-direction: column;
                }
        
                .tree-sidebar h3 {
                    font-size: 18px;
                    margin-bottom: 20px;
                    /* CHANGE: Dark text for sidebar title */
                    color: #11182c;
                    font-weight: 600;
                    flex-shrink: 0;
                }
        
                .tree-container {
                    padding: 10px;
                    overflow-x: auto;
                    overflow-y: auto;
                    flex: 1;
                }
        
                .tree-node {
                    margin: 5px 0;
                    position: relative;
                    white-space: nowrap;
                }
        
                .tree-node::before {
                    content: '';
                    position: absolute;
                    left: -15px;
                    top: 16px;
                    width: 10px;
                    height: 1px;
                    /* CHANGE: Light gray for tree lines */
                    background: #d1d5db;
                }
        
                .tree-node-content {
                    cursor: pointer;
                    padding: 8px 15px;
                    border-radius: 8px;
                    font-size: 14px;
                    transition: all 0.2s ease;
                    display: inline-flex;
                    align-items: center;
                    gap: 8px;
                    /* CHANGE: Lighter background for tree nodes */
                    background: #f3f4f6;
                    /* CHANGE: Light border */
                    border: 1px solid #e5e7eb;
                    max-width: 250px;
                    overflow: hidden;
                    text-overflow: ellipsis;
                    white-space: nowrap;
                    /* CHANGE: Medium gray text for tree nodes */
                    color: #4b5563;
                }
        
                .tree-node-content:hover {
                    /* CHANGE: Lighter background on hover */
                    background: #e5e7eb;
                    /* CHANGE: Slightly darker border on hover */
                    border-color: #d1d5db;
                    transform: translateX(3px);
                    /* CHANGE: Darker text on hover */
                    color: #11182c;
                }
        
                .tree-node-content.active {
                    background: #191970;
                    color: white;
                    border-color: transparent;
                }
        
                .tree-node-icon {
                    flex-shrink: 0;
                    font-size: 16px;
                }
        
                .tree-node-text {
                    overflow: hidden;
                    text-overflow: ellipsis;
                    white-space: nowrap;
                }
        
                .tree-children {
                    margin-left: 25px;
                    margin-top: 5px;
                    /* CHANGE: Light gray border for tree children */
                    border-left: 1px solid #d1d5db;
                    padding-left: 15px;
                }
        
                .main-container {
                    flex: 1;
                    display: flex;
                    flex-direction: column;
                    padding: 20px;
                    overflow: hidden;
                    height: 100vh;
                }
        
                .app-container {
                    flex: 1;
                    display: flex;
                    flex-direction: column;
                    max-width: 1000px;
                    width: 100%;
                    margin: 0 auto;
                    overflow: hidden;
                }
        
                .navigation-controls {
                    display: flex;
                    gap: 15px;
                    margin-bottom: 20px;
                    align-items: center;
                    flex-shrink: 0;
                }
        
                .nav-button {
                    /* CHANGE: Lighter background for nav buttons */
                    background: #ffffff;
                    /* CHANGE: Dark gray text */
                    color: #4b5563;
                    /* CHANGE: Light border */
                    border: 2px solid #e5e7eb;
                    padding: 10px 20px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-size: 16px;
                    font-weight: 600;
                    transition: all 0.3s ease;
                    display: inline-flex;
                    align-items: center;
                    gap: 8px;
                }
        
                .nav-button:hover:not(:disabled) {
                    /* CHANGE: Lighter background on hover */
                    background: #f3f4f6;
                    /* CHANGE: Darker text on hover */
                    color: #11182c;
                    transform: translateY(-2px);
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
                }
        
                .nav-button:disabled {
                    opacity: 0.5;
                    cursor: not-allowed;
                }
        
                .breadcrumb {
                    flex: 1;
                    /* CHANGE: White background for breadcrumb */
                    background: #ffffff;
                    padding: 10px 25px;
                    border-radius: 12px;
                    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
                    display: flex;
                    align-items: center;
                    gap: 10px;
                    overflow-x: auto;
                    white-space: nowrap;
                    /* CHANGE: Light border */
                    border: 1px solid #e5e7eb;
                }
        
                .breadcrumb-item {
                    /* CHANGE: Medium gray for breadcrumb items */
                    color: #6b7280;
                    font-size: 14px;
                    padding: 5px 10px;
                    border-radius: 6px;
                    flex-shrink: 0;
                }
        
                .breadcrumb-separator {
                    /* CHANGE: Lighter gray for separator */
                    color: #9ca3af;
                    font-size: 18px;
                    flex-shrink: 0;
                }
        
                .breadcrumb-item.active {
                    /* CHANGE: Dark text for active item */
                    color: #11182c;
                    font-weight: 600;
                    /* CHANGE: Light gray background for active item */
                    background: #f3f4f6;
                }
        
                .main-content {
                    flex: 1;
                    /* CHANGE: White background for main content */
                    background: #ffffff;
                    border-radius: 20px;
                    padding: 40px;
                    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.05);
                    overflow-y: auto;
                    overflow-x: hidden;
                    animation: fadeIn 0.5s ease;
                    /* CHANGE: Light border */
                    border: 1px solid #e5e7eb;
                }
        
                @keyframes fadeIn {
                    from {
                        opacity: 0;
                        transform: translateY(20px);
                    }
                    to {
                        opacity: 1;
                        transform: translateY(0);
                    }
                }
        
                .welcome-message {
                    text-align: center;
                    padding: 60px 20px;
                }
        
                .welcome-message h1 {
                    font-size: 48px;
                    background: linear-gradient(135deg, #191970 0%, #34495e 100%);
                    -webkit-background-clip: text;
                    -webkit-text-fill-color: transparent;
                    margin-bottom: 20px;
                    font-weight: 800;
                }
        
                .welcome-message p {
                    font-size: 20px;
                    /* CHANGE: Medium gray for welcome message paragraph */
                    color: #6b7280;
                    margin-bottom: 40px;
                }
        
                .topic-overview {
                    margin-bottom: 30px;
                    padding: 25px;
                    /* CHANGE: Very light, almost white background for topic overview */
                    background: #f9fafb;
                    /* CHANGE: Dark text */
                    color: #1f2937;
                    border-radius: 16px;
                    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
                    /* CHANGE: Light border */
                    border: 1px solid #e5e7eb;
                }
        
                .topic-overview h2 {
                    font-size: 28px;
                    margin-bottom: 15px;
                    font-weight: 700;
                }
        
                .topic-overview p, .topic-overview div {
                    font-size: 18px;
                    line-height: 1.6;
                    /* CHANGE: Standard dark gray text */
                    color: #374151;
                }
        
                .topic-overview ul {
                    list-style-type: disc;
                    margin: 15px 0;
                    padding-left: 30px;
                }
        
                .topic-overview li {
                    margin: 8px 0;
                    line-height: 1.6;
                    /* CHANGE: Standard dark gray text */
                    color: #374151;
                }
        
                .cards-grid {
                    display: grid;
                    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
                    gap: 20px;
                    margin-top: 30px;
                }
        
                .card {
                    /* CHANGE: White background for cards */
                    background: #ffffff;
                    border-radius: 16px;
                    padding: 25px;
                    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
                    cursor: pointer;
                    transition: all 0.3s ease;
                    /* CHANGE: Light border */
                    border: 2px solid #e5e7eb;
                    position: relative;
                    overflow: hidden;
                }
        
                /* --- CARD STATUS INDICATOR STYLES --- */
        
                .status-indicator {
                    position: absolute;
                    top: 15px;
                    right: 15px;
                    width: 20px;
                    height: 20px;
                    border-radius: 50%;
                    background-color: transparent;
                    /* CHANGE: Lighter border for indicator */
                    border: 2px solid #d1d5db; /* Hollow circle style */
                    transition: all 0.3s ease;
                }
        
                .status-indicator.read {
                    background-color: #22c55e; /* Green background for 'read' state */
                    border-color: #22c55e;
                }
        
                /* The white checkmark icon */
                .status-indicator.read::before {
                    content: '';
                    display: block;
                    width: 100%;
                    height: 100%;
                    /* Embedded SVG for the checkmark - clean and scalable */
                    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='3' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='20 6 9 17 4 12'%3E%3C/polyline%3E%3C/svg%3E");
                    background-size: 60%;
                    background-position: center;
                    background-repeat: no-repeat;
                }
        
                .card::before {
                    content: '';
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 4px;
                    background: linear-gradient(135deg, #191970 0%, #34495e 100%);
                    transform: scaleX(0);
                    transform-origin: left;
                    transition: transform 0.3s ease;
                }
        
                .card:hover {
                    transform: translateY(-5px);
                    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
                    border-color: #191970;
                    /* CHANGE: No background change needed on hover, or a very subtle one */
                }
        
                .card:hover::before {
                    transform: scaleX(1);
                }
        
                .card h3 {
                    font-size: 20px;
                    margin-bottom: 8px;
                    color: #11182c;
                    display: flex;
                    align-items: center;
                    justify-content: space-between;
                    /* ADD THIS LINE to prevent text from flowing under the icon */
                    padding-right: 25px; 
                }
        
                .card-icon {
                    width: 20px;
                    height: 20px;
                    color: #191970;
                    transition: transform 0.3s ease;
                }
        
                .card:hover .card-icon {
                    transform: translateX(5px);
                }
        
                .card p {
                    /* CHANGE: Medium gray for card paragraphs */
                    color: #6b7280;
                    line-height: 1.4;
                    font-size: 14px;
                }
        
                .content-section {
                    margin-bottom: 30px;
                }
        
                .content-section h3 {
                    font-size: 24px;
                    /* CHANGE: Darker text for section headers */
                    color: #11182c;
                    margin-bottom: 15px;
                    font-weight: 600;
                }
        
                .content-section p {
                    font-size: 16px;
                    line-height: 1.8;
                    /* CHANGE: Standard dark gray for paragraphs */
                    color: #374151;
                    margin-bottom: 15px;
                    white-space: pre-wrap;
                }
        
                .tell-me-more-button {
                    background: linear-gradient(135deg, #191970 0%, #34495e 100%);
                    color: white;
                    border: none;
                    padding: 15px 30px;
                    border-radius: 12px;
                    cursor: pointer;
                    font-size: 16px;
                    font-weight: 600;
                    transition: all 0.3s ease;
                    display: inline-flex;
                    align-items: center;
                    gap: 10px;
                    margin: 20px 0;
                }
                .quiz-me-more-button {
    background: linear-gradient(135deg, #191970 0%, #34495e 100%);
    color: white;
    border: none;
    padding: 15px 10px;
    border-radius: 12px;
    cursor: pointer;
    font-size: 16px;
    font-weight: 600;
    transition: all 0.3s ease;
    display: inline-flex; /* Changed back to inline-flex */
    align-items: center;
    gap: 10px;
    margin: 0; /* The new wrapper will handle margins */
}

/* Add this new rule right after the one above */
.quiz-me-more-button:disabled {
    background: #e5e7eb; /* Light gray background */
    color: #9ca3af;   /* Muted text color */
    cursor: not-allowed;
}
        
                .tell-me-more-button:hover {
                    transform: translateY(-2px);
                    box-shadow: 0 5px 15px rgba(93, 109, 126, 0.4);
                }
        
                .chat-container {
                    margin-top: 20px; /* Adds space between the main content and this container */
                    border-radius: 20px; /* Rounds the corners of the container */
                    padding: 20px;
                    background: #ffffff;
                    border: 1px solid #e5e7eb; /* A full border looks better with rounded corners */
                    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05); /* A subtle shadow to match other elements */
                    flex-shrink: 0; 
                }
        
                .chat-input-wrapper {
                    max-width: 1200px;
                    margin: 0 auto;
                    display: flex;
                    gap: 15px;
                    align-items: center;
                }
        
                .chat-input {
                    flex: 1;
                    padding: 15px 20px;
                    /* CHANGE: Light border for chat input */
                    border: 2px solid #d1d5db;
                    border-radius: 12px;
                    font-size: 16px;
                    outline: none;
                    transition: all 0.3s ease;
                    /* CHANGE: Light gray background */
                    background: #f9fafb;
                    /* CHANGE: Dark text color */
                    color: #11182c;
                }
        
                .chat-input:focus {
                    border-color: #191970;
                    box-shadow: 0 0 0 3px rgba(93, 109, 126, 0.1);
                }
        
                .chat-input::placeholder {
                    /* CHANGE: Medium gray for placeholder */
                    color: #9ca3af;
                }
        
                .send-button {
                    padding: 15px 30px;
                    background: linear-gradient(135deg, #191970 0%, #34495e 100%);
                    color: white;
                    border: none;
                    border-radius: 12px;
                    cursor: pointer;
                    font-size: 16px;
                    font-weight: 600;
                    transition: all 0.3s ease;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                }
        
                .send-button:hover {
                    transform: translateY(-2px);
                    box-shadow: 0 5px 15px rgba(93, 109, 126, 0.4);
                }
        
                .send-button:disabled {
                    background: #d1d5db;
                    cursor: not-allowed;
                    transform: none;
                    box-shadow: none;
                }
        
                .loading-spinner {
                    display: inline-block;
                    width: 16px;
                    height: 16px;
                    border: 2px solid transparent;
                    border-top-color: white;
                    border-radius: 50%;
                    animation: spin 0.8s linear infinite;
                }
        
                @keyframes spin {
                    to { transform: rotate(360deg); }
                }
        
                .error-message {
                    background: #dc2626;
                    color: white;
                    padding: 15px 20px;
                    border-radius: 8px;
                    margin-bottom: 15px;
                    display: none;
                    animation: shake 0.5s ease;
                }
        
                @keyframes shake {
                    0%, 100% { transform: translateX(0); }
                    25% { transform: translateX(-10px); }
                    75% { transform: translateX(10px); }
                }
        
                strong {
                    font-weight: 600;
                    /* CHANGE: Dark text for strong elements */
                    color: #11182c;
                }
        
                em {
                    font-style: italic;
                    /* CHANGE: Medium gray for emphasized text */
                    color: #6b7280;
                }
        
                ul, ol {
                    margin: 15px 0;
                    padding-left: 30px;
                    /* CHANGE: Dark gray text for lists */
                    color: #374151;
                }
        
                li {
                    margin: 8px 0;
                    line-height: 1.6;
                    /* CHANGE: Dark gray text for list items */
                    color: #374151;
                }
        
                /* --- NEW STYLES FOR TERM DEFINITIONS --- */
        
                .technical-term {
                    text-decoration: none; /* This removes the underline */
                    color: #a78bfa; /* This keeps the purple color you like */
                    cursor: help; /* Changes the mouse cursor to a question mark */
                    position: relative; /* Essential for positioning the tooltip */
                    display: inline-block; /* Ensures the position property works correctly */
                }
        
                .term-tooltip {
                    visibility: hidden; /* Hidden by default */
                    width: 300px;
                    /* CHANGE: White background for tooltip */
                    background-color: #ffffff;
                    /* CHANGE: Dark text for tooltip */
                    color: #1f2937;
                    text-align: left;
                    border-radius: 8px;
                    padding: 15px;
                    position: absolute;
                    z-index: 10;
                    bottom: 125%; /* Position above the term */
                    left: 50%;
                    margin-left: -150px; /* Center the tooltip */
                    opacity: 0;
                    transition: opacity 0.3s;
                    /* CHANGE: Light border for tooltip */
                    border: 1px solid #e5e7eb;
                    box-shadow: 0 5px 15px rgba(0,0,0,0.1);
                    font-size: 14px; /* Ensure tooltip text is readable */
                    line-height: 1.5;
                    text-decoration: none; /* Remove underline from the tooltip text */
                    pointer-events: none; /* Tooltip itself shouldn't be interactive */
                }
                
                /* Show the tooltip on hover */
                /* This class will be toggled by JavaScript to show the tooltip */
                .term-tooltip.visible {
                    visibility: visible;
                    opacity: 1;
                }
        
                /* --- END OF NEW STYLES --- */
                /* --- STYLES FOR RESIZABLE SIDEBAR --- */
        
                .resizer {
                    flex-shrink: 0;
                    width: 5px;
                    cursor: col-resize; /* The cursor indicates it can be resized horizontally */
                    /* CHANGE: Main background color */
                    background-color: #f9fafb; 
                    transition: background-color 0.2s ease;
                }
        
                .resizer:hover {
                    background-color: #191970; /* Highlight on hover */
                }
        
                .tree-sidebar {
                    /* This ensures the sidebar doesn't shrink on its own */
                    flex-shrink: 0;
                    width: 320px; /* This will be our default and minimum width */
                }
        
                /* --- END OF RESIZER STYLES --- */
                /* --- TREE STATUS INDICATOR STYLES --- */
        
                .tree-status-indicator {
                    display: inline-block; /* Allows it to sit next to text */
                    vertical-align: middle; /* Aligns it nicely with the text and emoji */
                    width: 14px;
                    height: 14px;
                    margin-right: 8px; /* Space between the circle and the emoji */
                    border-radius: 50%;
                    background-color: transparent;
                    /* CHANGE: Lighter border for indicator */
                    border: 1.5px solid #d1d5db; /* Unread hollow circle */
                    transition: all 0.3s ease;
                    flex-shrink: 0; /* Prevents it from being squished */
                }
        
                .tree-status-indicator.read {
                    background-color: #22c55e; /* Green for 'read' */
                    border-color: #22c55e;
                }
        
                .tree-status-indicator.read::before {
                    content: '';
                    display: block;
                    width: 100%;
                    height: 100%;
                    /* Same embedded SVG checkmark, will scale automatically */
                    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='4' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='20 6 9 17 4 12'%3E%3C/polyline%3E%3C/svg%3E");
                    background-size: 70%;
                    background-position: center;
                    background-repeat: no-repeat;
                }
                /* --- STYLES FOR QUIZ --- */
                .quiz-option {
                    padding: 15px;
                    /* CHANGE: Light border for quiz options */
                    border: 2px solid #d1d5db;
                    /* CHANGE: Light background for quiz options */
                    background: #f9fafb;
                    border-radius: 8px;
                    cursor: pointer;
                    transition: all 0.2s ease;
                }
                .quiz-option:hover {
                    border-color: #191970;
                    /* CHANGE: Lighter background on hover */
                    background: #f3f4f6;
                }
                .quiz-option.selected {
                    border-color: #a78bfa;
                    background: #4c1d95;
                    color: white;
                }
                .quiz-option.correct {
                    border-color: #22c55e;
                    background: #166534;
                    color: white; /* Ensure text is readable */
                }
                .quiz-option.incorrect {
                    border-color: #dc2626;
                    background: #991b1b;
                    color: white; /* Ensure text is readable */
                }
                #quizFeedback.correct { color: #16a34a; }
                #quizFeedback.incorrect { color: #ef4444; }

                /* --- ADD THESE NEW STYLES FOR THE CATEGORY TAG --- */
.topic-card .category-tag {
    display: inline-block;
    padding: 4px 12px;
    font-size: 12px;
    font-weight: 600;
    border-radius: 20px;
    margin-bottom: 12px; /* Adds space between the tag and the title */
    color: #ffffff; /* Default text color */
    background-color: #6b7280; /* Default background */
}

.topic-card h2 {
    /* We already had this, just ensure margin-bottom is set */
    margin-bottom: 8px; 
}

/* --- UNIVERSAL TAG STYLES (THE FIX) --- */

/* 1. General style for the container, making it flexible with a gap */
.tags-container {
    display: flex;
    gap: 8px;
}

/* 2. General style for the tags themselves, making them padded and rounded */
.tag {
    display: inline-block;
    padding: 4px 12px;
    font-size: 12px;
    font-weight: 600;
    border-radius: 20px;
    color: #ffffff; /* Default text is white */
}

/* --- LAYOUT-SPECIFIC TWEAKS --- */

/* 3. For tags inside a topic card, add space below them */
.topic-card .tags-container {
    margin-bottom: 12px;
}

/* 4. For tags inside the sidebar header, center them */
#sidebarTitle .tags-container {
    justify-content: center;
    padding-bottom: 5px;
}
/* --- Styles for the sidebar title spacing and border --- */
#sidebarTitle {
    margin-bottom: 10px;  /* This is the halved space below the border */
    padding-bottom: 10px; /* This is the space between the tags and the border */
    border-bottom: 1px solid #e5e7eb; /* The new thin grey border */
}

.topic-card .tag {
    display: inline-block;
    padding: 4px 12px;
    font-size: 12px;
    font-weight: 600;
    border-radius: 20px;
    color: #ffffff; /* Default text color is white */
}

/* We can remove the specific margin from the category-tag now */
.topic-card .category-tag {
    /* The .tag class now handles the shared styles */
}/* --- Styles for Sort Controls --- */
.sort-btn {
    background: #ffffff;
    border: 1px solid #d1d5db;
    color: #4b5563;
    padding: 6px 12px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 600;
    transition: all 0.2s ease;
}
.sort-btn:hover {
    background: #f3f4f6;
}
.sort-btn.active {
    background: #191970;
    color: white;
    border-color: #191970;
}

/* --- Styles for Category Sorting View --- */
#topicGrid.category-view {
    display: block; /* Change from grid to block to allow for headers */
}
.category-header {
    font-size: 22px;
    color: #11182c;
    margin-top: 30px;
    margin-bottom: 15px;
    padding-bottom: 10px;
    border-bottom: 1px solid #e5e7eb;
}
/* Remove margin for the very first header */
.category-header:first-of-type {
    margin-top: 0;
}
/* Re-applies the grid layout for topics within each category */
.topic-grid-layout {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 20px;
}/* --- Styles for the new header layout in the main content --- */
.topic-header {
    display: flex;
    justify-content: space-between; /* Pushes title and button to opposite ends */
    align-items: center;        /* Vertically aligns the title and button */
}

/* This is the new button style */
/* This is the new button style */
.quiz-me-button {
    background: #191970;
    color: white;
    border: none;
    padding: 12px 24px;   /* Increased padding for a bigger button */
    border-radius: 10px;  /* Slightly more rounded corners */
    cursor: pointer;
    font-size: 16px;      /* Larger font size */
    font-weight: 600;
    transition: all 0.2s ease;
    flex-shrink: 0;

    /* --- New Flexbox styles for the icon --- */
    display: inline-flex; /* Aligns items in a row */
    align-items: center;  /* Vertically centers the icon and text */
    gap: 10px;            /* Adds space between the icon and text */
}

.quiz-me-button:hover:not(:disabled) {
    background: #c2410c;
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(93, 109, 126, 0.3);
}

/* This style grays out the button when it's disabled */
.quiz-me-button:disabled {
    background: #e5e7eb; /* Light gray background */
    color: #9ca3af;   /* Muted text color */
    cursor: not-allowed;
}

/* --- Styles for the tooltip on disabled hover --- */
.button-tooltip-wrapper {
    position: relative; /* Required for positioning the tooltip */
    display: inline-block;
}

.quiz-tooltip {
    visibility: hidden;
    width: max-content; /* Make width fit the text */
    background-color: #374151; /* Dark background */
    color: #fff;
    text-align: center;
    border-radius: 6px;
    padding: 8px 12px;
    font-size: 12px;
    font-weight: 500;
    
    /* Position the tooltip above the button */
    position: absolute;
    z-index: 10;
    bottom: 120%;
    left: 50%;
    transform: translateX(-50%);
    
    /* Fade in/out animation */
    opacity: 0;
    transition: opacity 0.2s;
}

/* This class is added by JavaScript to show the tooltip */
.quiz-tooltip.show {
    visibility: visible;
    opacity: 1;
}
/* --- NEW: SKELETON LOADER STYLES --- */
.skeleton-loader {
    padding: 40px;
}

@keyframes pulse {
    0% { background-color: #f3f4f6; }
    50% { background-color: #e5e7eb; }
    100% { background-color: #f3f4f6; }
}

.skeleton-title {
    width: 60%;
    height: 35px;
    border-radius: 8px;
    margin-bottom: 25px;
    animation: pulse 1.5s ease-in-out infinite;
}

.skeleton-text {
    width: 100%;
    height: 18px;
    border-radius: 6px;
    margin-bottom: 12px;
    animation: pulse 1.5s ease-in-out infinite;
}

.skeleton-text.short {
    width: 80%;
}
/* --- END OF SKELETON LOADER STYLES --- */

        /* Add these styles to your <style> block */
            .chart-container {
            width: 100%;
            border: 1px solid #e5e7eb;
            border-radius: 16px;
            background: #fdfdff;
            position: relative;
            overflow: hidden;
        }
        
        .bar-chart-container {
            height: 450px;
            padding: 20px;
        }
        
        .pie-chart-wrapper {
            display: flex;
            align-items: center;
            gap: 20px;
            height: 400px;
            padding: 20px;
        }
        .pie-chart-container {
            flex-grow: 1;
            height: 100%;
        }
        .pie-legend-container {
            flex-shrink: 0;
            width: 200px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
        }
        .legend-color-box {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }
        
        /* New generic styles for text areas */
        .input-wrapper {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .styled-textarea {
            width: 100%;
            padding: 15px 20px;
            border: 2px solid #d1d5db;
            border-radius: 12px;
            font-size: 16px;
            font-family: 'Courier New', Courier, monospace;
            outline: none;
            transition: all 0.3s ease;
            background: #f9fafb;
            color: #11182c;
            min-height: 150px;
            resize: vertical;
        }
        
        .styled-textarea:focus {
            border-color: #191970;
            box-shadow: 0 0 0 3px rgba(93, 109, 126, 0.1);
        }
        /* --- CORE STYLES (Mirrored from your existing file) --- */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f9fafb;
            min-height: 100vh;
            color: #374151;
            /* This prevents the main body from ever scrolling, which is correct for this layout */
            overflow: hidden;
        }

        /* --- LAB CONTAINER STYLES --- */
        .lab-container {
            max-width: 800px;
            width: 100%;
            background: #ffffff; /* White background for main content */
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.05);
            border: 1px solid #e5e7eb; /* Light border */
            display: flex;
            flex-direction: column;
            gap: 25px; /* Space between graph and input */
            margin: 40px auto 0; /* ADD THIS LINE: Centers the card and adds top margin */
        }
        
        .lab-container h1 {
            font-size: 28px;
            font-weight: 700;
            color: #11182c; /* Darker text for headers */
            text-align: center;
        }

        /* --- GRAPH STYLES --- */
        #graphContainer {
            width: 100%;
            height: 450px;
            border: 1px solid #e5e7eb;
            border-radius: 16px;
            background: #fdfdff;
            cursor: move; /* Change cursor to indicate pannable area */
            position: relative; /* Needed for canvas overlay */
            overflow: hidden; /* Hide anything drawn outside bounds */
        }
        
        #functionGraph {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        /* --- INPUT STYLES (Mirrored from chat-input) --- */
        .equation-input-wrapper {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .equation-input-wrapper label {
            font-size: 14px;
            color: #6b7280; /* Medium gray for labels */
            font-weight: 600;
        }
        
        .equation-input {
            width: 100%;
            padding: 15px 20px;
            border: 2px solid #d1d5db; /* Light border for input */
            border-radius: 12px;
            font-size: 16px;
            font-family: 'Courier New', Courier, monospace;
            outline: none;
            transition: all 0.3s ease;
            background: #f9fafb; /* Light gray background */
            color: #11182c; /* Dark text color */
        }
        
        .equation-input:focus {
            border-color: #191970; /* Purple focus color */
            box-shadow: 0 0 0 3px rgba(93, 109, 126, 0.1);
        }

        .equation-input::placeholder {
            color: #9ca3af; /* Medium gray for placeholder */
        }

        /* --- ERROR MESSAGE STYLE --- */
        #error-message {
            color: #dc2626; /* Strong red */
            font-size: 14px;
            height: 20px; /* Reserve space to prevent layout shifts */
            margin-top: 5px;
            text-align: center;
        }

        /* --- TIMELINE STYLES --- */
        /* --- In your <style> block --- */

        .timeline-container-wrapper {
            width: 100%;
            position: relative;
            padding: 15px 0;
            overflow: hidden; /* Changed to hide overflow on BOTH axes */
            height: 300px; /* ADDED: This sets a fixed height */
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        .timeline-container-wrapper::-webkit-scrollbar {
            display: none;
        }

        .timeline-wrapper {
            position: relative;
            /* CHANGE THIS LINE */
            padding: 20px 80px; /* Was 'padding: 20px;' */
            min-height: 250px;
            margin: 0 auto; /* Centers the timeline horizontally */
        }

        .timeline-line {
            position: absolute;
            top: 50%;
            left: 0;
            height: 4px;
            background-color: #e5e7eb;
            transform: translateY(-2px);
            border-radius: 2px;
        }

        .timeline-event {
            position: absolute; 
            background-color: #ffffff;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            padding: 10px 12px; 
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
            transition: all 0.3s ease;
            z-index: 5; /* Ensure card is above braces */
            /*text-align: center; *//* Add this line */
        }
        
        .timeline-event:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            border-color: #191970;
        }
        
        .timeline-event.top {
            bottom: 50%;
        }

        .timeline-event.bottom {
            top: 50%;
        }
        
        /* Event Timeline Connector */
       
        
        /* Re-added the vertical connector line */
        /* REPLACE your existing ::after rule with this one */
        .timeline-event.event-style::after {
            content: '';
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            width: 2px;
            /* Use the same color as the timeline bar */
            background-color: #11182c; 
            z-index: 1;
            /* The height is now controlled by a variable from the script */
            height: var(--connector-height, 25px); 
        }
        
        .timeline-event.event-style.top::before { bottom: -15px; }
        .timeline-event.event-style.top::after { top: 100%; }

        .timeline-event.event-style.bottom::before { top: -15px; }
        .timeline-event.event-style.bottom::after { bottom: 100%; }
        
        .timeline-event-title {
            font-size: 15px;
            font-weight: 600;
            color: #11182c;
            margin-bottom: 4px;
        }

        .timeline-event-date {
            font-size: 12px;
            color: #6b7280;
        }

        /* Period Timeline Styles */
        .period-brace {
            position: absolute;
            height: 10px; /* Height of the horizontal part */
            /* CHANGE THIS COLOR */
            border-left: 2px solid #e5e7eb;
            /* CHANGE THIS COLOR */
            border-right: 2px solid #e5e7eb;
            z-index: 1;
        }
        .period-brace.top {
            bottom: 50%;
            /* CHANGE THIS COLOR */
            border-top: 2px solid #e5e7eb;
        }
        .period-brace.bottom {
            top: 50%;
            /* CHANGE THIS COLOR */
            border-bottom: 2px solid #e5e7eb;
        }
        /* Add these styles for the new zoom buttons */
        .zoom-controls {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            flex-direction: column;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
            border: 1px solid #d1d5db;
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            background-color: #ffffff;
            border: none;
            border-bottom: 1px solid #e5e7eb;
            cursor: pointer;
            font-size: 22px;
            font-weight: 300;
            color: #374151;
            transition: background-color 0.2s ease;
        }

        .zoom-btn:last-child {
            border-bottom: none;
        }

        .zoom-btn:hover {
            background-color: #f3f4f6;
        }
       /* --- REVISED HYBRID TIMELINE STYLES --- */

/* This is the main positioning wrapper. It has no visual styles. */
.hybrid-event {
    position: absolute;
    z-index: 5;
    display: flex;
    flex-direction: column; /* Stacks the card and connector vertically */
    align-items: center;
    transition: all 0.2s ease-in-out; /* Moved from old shared rule */
}
/* For events on top, this reverses the order to show the card above the connector */
.hybrid-event.top {
    flex-direction: column; /* This ensures the card is visually on top of its connector */
}

.hybrid-event.bottom {
    flex-direction: column-reverse; /* This reverses the order to put the card below its connector */
}

/* This is the visible card that gets the hover effect */
.timeline-event-card {
    background-color: #ffffff;
    border: 1px solid #11182c; /* The user-requested black border */
    border-radius: 12px;
    padding: 10px 12px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.05);
    transition: all 0.2s ease-in-out;
    width: 140px; /* A fixed width for event cards */
    text-align: center;
    cursor: default;
}

/* The hover effect is now ONLY on the card, not the whole wrapper */
.timeline-event-card:hover {
    transform: scale(1.04);
    z-index: 10;
    box-shadow: 0 8px 25px rgba(0,0,0,0.15);
    border-color: #191970; /* Keeps the purple hover color for consistency */
}

/* This is the dedicated, non-scaling connector line */
.timeline-connector {
    width: 2px;
    background-color: #11182c; /* The black connector line */
    height: var(--connector-height, 25px); /* Height is set by JavaScript */
}

    .visual-asset-row {
    display: flex;
    flex-wrap: wrap; /* Allows columns to wrap on smaller screens if needed */
    gap: 20px;
    margin: 25px 0;
    align-items: stretch; /* Make columns same height */
}

.visual-asset-column {
    flex: 1; /* Each column takes up equal space */
    min-width: 300px; /* Prevents columns from getting too squished */
    display: flex;
    flex-direction: column;
}

/* Ensure lab containers inside columns behave correctly */
.visual-asset-column .lab-container {
    padding: 15px; /* Reduce padding for smaller containers */
    height: 100%;
}

.visual-asset-column .lab-container h1 {
    font-size: 18px; /* Smaller title for inline graphs */
    margin-bottom: 10px;
}
/* --- NEW: Styles for the Plotter Legend --- */
.plot-legend-container {
    display: flex;
    justify-content: center; /* Center the legend items horizontally */
    align-items: center;
    flex-wrap: wrap; /* Allow items to wrap to the next line on small screens */
    gap: 15px 25px; /* Vertical and horizontal gap between items */
    padding: 10px 0;
    font-family: 'Courier New', Courier, monospace;
}

.plot-legend-item {
    display: flex;
    align-items: center;
    gap: 10px; /* Space between the color swatch and the equation */
    font-size: 16px;
}

.plot-legend-color-swatch {
    width: 20px;
    height: 20px;
    border-radius: 4px;
    border: 1px solid rgba(0,0,0,0.1); /* A subtle border for light colors */
    flex-shrink: 0; /* Prevents the swatch from shrinking */
}
/* --- ADD THIS NEW RULE --- */
.timeline-event.event-style {
    border-color: #11182c; /* A dark, almost black color for the border */
    text-align: center; /* Center the text inside the new event card */
}
.timeline-event:hover,
.hybrid-event:hover {
    z-index: 10;
}
.timeline-subtitle {
    text-align: center;
    font-size: 14px;
    color: #6b7280; /* Medium grey, consistent with other text */
    margin-top: -5px; /* Pulls it slightly closer to the main title */
    margin-bottom: 10px; /* Adds a little space before the timeline */
}
/* --- ADD THIS RULE TO PREVENT EQUATIONS FROM BREAKING ACROSS LINES --- */
.katex {
    display: inline-block;
    white-space: nowrap; /* Add this for extra safety */
}
/* --- New styles for the 'What's the difference' button --- */
.difference-button {
    background: none;
    border: none;
    color: #6b7280; /* A nice grey color */
    cursor: pointer;
    font-size: 14px;
    font-weight: 500;
    padding: 0;
    margin-left: 15px; /* Adds some space from the other buttons */
    transition: color 0.2s ease;
}

.difference-button:hover {
    text-decoration: underline;
    color: #c2410c; /* A bit of color on hover */
}

/* --- New styles for the difference modal --- */
.close-modal-btn {
    position: absolute;
    top: 15px;
    right: 20px;
    font-size: 28px;
    font-weight: bold;
    color: #9ca3af;
    cursor: pointer;
    transition: color 0.2s ease;
}

.close-modal-btn:hover {
    color: #374151;
}

.difference-container {
    display: flex;
    justify-content: space-between;
    margin-top: 25px;
    gap: 20px;
}

.difference-column {
    flex: 1;
    text-align: center;
}

.difference-column h3 {
    font-size: 20px;
    color: #11182c;
    margin-bottom: 10px;
}

.difference-column p {
    font-size: 15px;
    line-height: 1.6;
    color: #4b5563;
}

.vertical-separator {
    width: 1px;
    background-color: #e5e7eb; /* A thin grey vertical line */
}

.icon-placeholder {
    margin-top: 20px;
    color: #191970; /* Purple icon color to match your theme */
}
/* --- Add this new rule for the forgot password button --- */
.forgot-password-button {
    background: none;
    border: none;
    color: #191970; /* Use your theme's purple color */
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    padding: 0;
    transition: color 0.2s ease;
}

.forgot-password-button:hover {
    text-decoration: underline;
    color: #c2410c; /* A slightly darker purple on hover */
}
            </style>

<script>
    window.si = window.si || function () { (window.si.q = window.si.q || []).push(arguments); };
  </script>
  <script src="/_vercel/insights/script.js" defer></script>
  
  <script>
    window.va = window.va || function () { (window.va.q = window.va.q || []).push(arguments); };
  </script>
  <script src="/_vercel/analytics/script.js" defer></script>
</head>
<body>
    <div id="authView" style="display: flex; justify-content: center; align-items: center; height: 100vh;">
        <div style="background: #ffffff; padding: 40px; border-radius: 20px; width: 400px; border: 1px solid #e5e7eb; text-align: center;">
    
          <!--  <div style="margin-bottom: 25px; display: flex; justify-content: center;">
                <svg width="130" height="50" viewBox="0 0 130 50" fill="none" xmlns="http://www.w3.org/2000/svg" style="display: block;">
                    <defs>
                        <linearGradient id="logoGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" style="stop-color:#191970;stop-opacity:1"></stop>
                            <stop offset="100%" style="stop-color:#34495e;stop-opacity:1"></stop>
                        </linearGradient>
                    </defs>
                    <text x="0" y="25" font-family="Inter, sans-serif" font-size="24" font-weight="bold" fill="#374151" dominant-baseline="middle" text-anchor="start">
                        Curi
                    </text>
                    <g transform="translate(58, 0)">
                        <circle cx="0" cy="25" r="8" fill="url(#logoGradient)"></circle>
                        <line x1="6.3" y1="31.3" x2="12.5" y2="37.5" stroke="#374151" stroke-width="2.5" stroke-linecap="round"></line>
                    </g>
                    <text x="67" y="25" font-family="Inter, sans-serif" font-size="24" font-weight="bold" fill="#374151" dominant-baseline="middle" text-anchor="start">
                        sity
                    </text>
                </svg>
            </div>-->
    
            <h2 style="font-size: 24px; color: #11182c; font-weight: 700; margin-bottom: 8px;">Welcome</h2>
            <p style="color: #6b7280; font-size: 16px; margin-bottom: 30px;">
                Sign in to continue your learning journey.
            </p>
            
            <div style="text-align: left;">
                <input type="email" id="emailInput" placeholder="Email" class="modal-input">
                <input type="password" id="passwordInput" placeholder="Password" class="modal-input">
            </div>
    
            <div style="text-align: center; margin-bottom: 20px;">
                <button id="forgotPasswordBtn" class="forgot-password-button">Forgot your password?</button>
            </div>
    
            <p id="authError" style="color: #dc2626; margin-bottom: 15px; height: 20px;"></p>
    
            <div style="display: flex; gap: 15px; flex-direction: column;">
                <button id="loginBtn" class="modal-btn submit" style="width: 100%;">Login</button>
                <button id="signupBtn" class="modal-btn submit" style="width: 100%; background: #e5e7eb; color: #374151;">Sign Up</button>
            </div>
            <div style="margin: 20px 0; text-align: center; color: #71717a;">OR</div>
            <button id="googleSignInBtn" class="modal-btn" style="width: 100%; background: #fff; color: #000; border: 1px solid #d1d5db; display: flex; align-items: center; justify-content: center; gap: 10px;">
                <svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="18px" height="18px" viewBox="0 0 48 48"><g><path fill="#EA4335" d="M24 9.5c3.54 0 6.71 1.22 9.21 3.6l6.85-6.85C35.9 2.38 30.47 0 24 0 14.62 0 6.51 5.38 2.56 13.22l7.98 6.19C12.43 13.72 17.74 9.5 24 9.5z"></path><path fill="#4285F4" d="M46.98 24.55c0-1.57-.15-3.09-.42-4.55H24v9.02h12.94c-.58 2.96-2.26 5.48-4.78 7.18l7.73 6c4.51-4.18 7.09-10.36 7.09-17.65z"></path><path fill="#FBBC05" d="M10.53 28.59c-.48-1.45-.76-2.99-.76-4.59s.27-3.14.76-4.59l-7.98-6.19C.92 16.46 0 20.12 0 24c0 3.88.92 7.54 2.56 10.78l7.97-6.19z"></path><path fill="#34A853" d="M24 48c6.48 0 11.93-2.13 15.89-5.81l-7.73-6c-2.15 1.45-4.92 2.3-8.16 2.3-6.26 0-11.57-4.22-13.47-9.91l-7.98 6.19C6.51 42.62 14.62 48 24 48z"></path><path fill="none" d="M0 0h48v48H0z"></path></g></svg>
                Sign in with Google
            </button>
        </div>
    </div>
    <div id="verifyEmailView" style="display: none; justify-content: center; align-items: center; height: 100vh;">
        <div style="background: #ffffff; padding: 40px; border-radius: 20px; width: 450px; border: 1px solid #e5e7eb; text-align: center;">
            <h2 style="font-size: 24px; color: #11182c; font-weight: 700; margin-bottom: 15px;">Verify Your Email</h2>
            <p style="color: #4b5563; font-size: 16px; line-height: 1.6; margin-bottom: 25px;">
                We've sent a verification link to <strong id="verificationEmail" style="color: #11182c;"></strong>. Please check your inbox (and spam folder) to continue.
            </p>
            
            <p id="resendMessage" style="color: #16a34a; margin-bottom: 15px; height: 20px;"></p>
    
            <div style="display: flex; gap: 15px;">
                <button id="resendVerificationBtn" class="modal-btn submit" style="flex: 1;">Resend Email</button>
                <button id="checkVerificationBtn" class="modal-btn submit" style="flex: 1; background: #6b7280;">I've Verified, Continue</button>
            </div>
            <button id="signOutFromVerifyBtn" class="forgot-password-button" style="margin-top: 25px;">Sign Out</button>
        </div>
    </div>
    <div id="appContainer" style="display: none;">
        </div>
    <!-- This is the new Landing Page View -->
<div id="landingView" class="view active">
    <div class="landing-header">
        <div style="display: flex; align-items: center; gap: 30px;">
            <h1>Your Learning Topics</h1>
            <div id="sortControls">
                <span style="color: #6b7280; font-weight: 500; font-size: 14px; margin-right: 10px;">Sort by:</span>
                <button class="sort-btn active" data-sort="recent">Most Recent</button>
                <button class="sort-btn" data-sort="category">By Category</button>
            </div>
        </div>
        <div style="display: flex; gap: 15px;">
            <button class="new-topic-btn" id="graphLabBtn" style="background: linear-gradient(135deg, #10b981 0%, #059669 100%);">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 3v18h18"/><path d="M18.7 8a6 6 0 0 0-8.4 0L3 18"/><path d="M12 12a3 3 0 0 0 4.2 0L21 6"/></svg>
                Graph Lab
            </button>
            <button class="new-topic-btn" id="newTopicBtn">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14m-7-7h14"/></svg>
                Learn a new topic
            </button>
            <button class="nav-button" id="signOutBtn" style="border-width: 2px;">
                Sign Out
            </button>
        </div>
    </div>
    <div id="topicGrid">
        <!-- Topic cards will be added here later -->
    </div>
</div>
<div id="learningView" class="view">

    <div class="app-wrapper">
        <div class="tree-sidebar" id="treeSidebar">
            <div id="sidebarTitle" style="margin-bottom: 0px; min-height: 27px;">Learning Journey Map</div>               
            <div class="tree-container" id="treeContainer">
                <div class="tree-node">
                    <div class="tree-node-content active" onclick="navigateToNode('root')">
                        <span class="tree-node-icon"></span>
                        <span class="tree-node-text">Home</span>
                    </div>
                </div>
            </div>
        </div>
        <div class="resizer" id="dragHandle"></div>

        <div class="main-container">
            <div class="app-container">
                <div class="navigation-controls">
                    <button class="nav-button" id="backButton" onclick="navigateBack()" disabled>
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M19 12H5m0 0l6-6m-6 6l6 6"/>
                        </svg>
                        Back
                    </button>
                    <button class="nav-button" id="forwardButton" onclick="navigateForward()" disabled>
                        Forward
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M5 12h14m0 0l-6-6m6 6l-6 6"/>
                        </svg>
                    </button>
                    <button class="nav-button" id="mainMenuBtn">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12h18M3 6h18M3 18h18"/></svg>
                        Main Menu
                    </button>
                    <div class="breadcrumb" id="breadcrumb">
                        <span class="breadcrumb-item active">Home</span>
                    </div>
                    <button class="nav-button" id="deleteTopicBtn" title="Delete this topic">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="3 6 5 6 21 6"></polyline>
                            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                            <line x1="10" y1="11" x2="10" y2="17"></line>
                            <line x1="14" y1="11" x2="14" y2="17"></line>
                        </svg>
                    </button>
                </div>

                <div class="main-content" id="mainContent">
                    <div class="welcome-message">
                        <h1>What do you want to learn?</h1>
                        <p>Explore finance and economics through an interactive learning journey</p>
                        <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap; margin-top: 40px;">
                            <button class="card" style="padding: 15px 25px; cursor: pointer;" onclick="askQuestion('How does the central bank work?')">
                                <span style="font-size: 16px;"> Central Banking</span>
                            </button>
                            <button class="card" style="padding: 15px 25px; cursor: pointer;" onclick="askQuestion('What are securities and their types?')">
                                <span style="font-size: 16px;"> Securities</span>
                            </button>
                            <button class="card" style="padding: 15px 25px; cursor: pointer;" onclick="askQuestion('Explain bonds and how they work')">
                                <span style="font-size: 16px;"> Bonds</span>
                            </button>
                        </div>
                    </div>
                </div>
                <div class="chat-container">
                    <div class="error-message" id="errorMessage"></div>
                    <div class="chat-input-wrapper">
                        <input 
                            type="text" 
                            class="chat-input" 
                            id="chatInput" 
                            placeholder="Ask about finance or economics..."
                            autofocus
                        >
                        <button class="send-button" id="sendButton" onclick="sendMessage()">
                            <span id="buttonText">Send</span>
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M5 12h14m0 0l-6-6m6 6l-6 6"/>
                            </svg>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    
</div>
<div class="modal-overlay" id="deleteConfirmModal">
    <div class="modal-content">
        <h2>Confirm Deletion</h2>
        <p style="margin: 20px 0 40px; font-size: 16px; color: #4b5563; text-align: center;">
            Are you sure you want to permanently delete this topic and all of its content? This action cannot be undone.
        </p>        <div class="modal-actions">
            <button class="modal-btn cancel" id="cancelDeleteBtn">Cancel</button>
            <button class="modal-btn delete" id="confirmDeleteBtn">Confirm Delete</button>
        </div>
    </div>
</div>

<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore-compat.js"></script>
    <script type="module">
import { formatVisualAssetsForContext, getLineageContent, buildTreeStructureString, getInPlaceElaborationPrompt, getStandardElaborationPrompt, getStemElaborationPrompt, getNewSubtopicsPrompt, getSyllabusPrompt, getPrefetchPrompt, getTimelineElaborationPrompt, getQuestionDispatcherPrompt, getChartJsCodePrompt } from './prompt-builder.js';
function triggerMathRendering(element) {
    // This is a KaTeX function that will find and render math expressions.
    // We need to import an additional script for it to work.
    if (window.renderMathInElement) {
        window.renderMathInElement(element, {
            delimiters: [
                {left: '$$', right: '$$', display: true},  // For display math (on its own line)
                {left: '$', right: '$', display: false},   // For inline math
                {left: '\\(', right: '\\)', display: false},
                {left: '\\[', right: '\\]', display: true}
            ],
            throwOnError: false // Prevents errors from stopping the page
        });
    }
}


// --- ADVANCED DATE PARSING & SCALING (No Changes) ---
const isLeapYear = (year) => (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);
const getDayOfYear = (date) => {
    const start = new Date(date.getFullYear(), 0, 0);
    const diff = date.getTime() - start.getTime();
    const oneDay = 1000 * 60 * 60 * 24;
    return Math.floor(diff / oneDay);
};

const parseDateToFractionalYear = (dateStr) => {
    // --- NEW DYNAMIC LOGIC START ---
    // Check for variations of "Present", "Current", etc.
    if (/present|current|today|now/i.test(dateStr)) {
        // Get the actual current date
        const now = new Date();
        const currentYear = now.getFullYear();
        
        // Use your existing helper functions to calculate the fractional year
        const daysInYear = isLeapYear(currentYear) ? 366 : 365;
        const dayOfYear = getDayOfYear(now);
        
        return currentYear + (dayOfYear / daysInYear);
    }
    // --- NEW DYNAMIC LOGIC END ---
    let cleanedStr = dateStr.replace(/c\.|ca\./, '').trim();
    const bcMatch = cleanedStr.match(/(\d+)\s*BC/i);
    if (bcMatch) return -parseInt(bcMatch[1], 10);
    
    cleanedStr = cleanedStr.replace(/AD/i, '').trim();

    const date = new Date(cleanedStr);
    if (!isNaN(date.getTime())) {
        const year = date.getFullYear();
        const daysInYear = isLeapYear(year) ? 366 : 365;
        const dayOfYear = getDayOfYear(date);
        return year + (dayOfYear / daysInYear);
    }
    
    const yearMatch = cleanedStr.match(/^-?\d+/);
    if (yearMatch) return parseInt(yearMatch[0], 10);

    return null;
};
function renderHybridTimeline(container, hybridData) {
    // 1. Create the timeline's HTML frame (same as before)
    container.innerHTML = `
        <h1>Timeline</h1>
        <p class="timeline-subtitle">A dynamic timeline of key events and periods. Hover for detail, click to learn more.</p>
        <div class="timeline-container-wrapper">
            <div class="timeline-wrapper">
                 <div class="timeline-line"></div>
            </div>
        </div>`;

    const timelineContainerWrapper = container.querySelector('.timeline-container-wrapper');
    const timelineWrapper = container.querySelector('.timeline-wrapper');
    const timelineLine = container.querySelector('.timeline-line');
    if (!timelineWrapper || !timelineLine) return;

    // Use requestAnimationFrame to ensure the container has been rendered and has a width
    requestAnimationFrame(() => {
        // =================================================================
        // ALGORITHM IMPLEMENTATION START
        // =================================================================

        // --- BITESIZE STEP 1: Data Preparation & Segmentation ---
        // First, process all data points to have consistent numerical start and end years.
        const allItems = hybridData.map(d => {
            if (d.type === 'period') {
                const startYear = parseDateToFractionalYear(d.startStr);
                const endYear = parseDateToFractionalYear(d.endStr);
                return { ...d, startYear, endYear, midYear: startYear + (endYear - startYear) / 2 };
            } else { // type === 'event'
                const year = parseDateToFractionalYear(d.dateStr);
                return { ...d, startYear: year, endYear: year, midYear: year };
            }
        }).filter(d => d.startYear !== null)
          .sort((a, b) => a.startYear - b.startYear); // Sort all items chronologically

        if (allItems.length === 0) return;

        // Create a distinct list of all start and end points on the timeline.
        const boundaries = new Set();
        allItems.forEach(item => {
            boundaries.add(item.startYear);
            boundaries.add(item.endYear);
        });
        const sortedBoundaries = Array.from(boundaries).sort((a, b) => a - b);

        // Create "segments" - these are the gaps between each unique boundary point.
        // This is the key to correct scaling.
        const segments = [];
        for (let i = 0; i < sortedBoundaries.length - 1; i++) {
            const start = sortedBoundaries[i];
            const end = sortedBoundaries[i+1];
            const duration = end - start;
            if (duration >= 0) {
                 segments.push({ start, end, duration });
            }
        }

        // --- BITESIZE STEP 2: Hierarchical Non-Linear Scaling ---
        // Apply a non-linear compression function to each segment's duration.
        // This shrinks long, empty periods and gives more space to dense periods.
        // We use Math.sqrt as you suggested. A small epsilon (0.01) prevents zero-width gaps for touching periods.
        const compressionFunc = (duration) => Math.sqrt(duration + 0.01);
        
        let totalWeightedDuration = 0;
        segments.forEach(seg => {
            seg.weightedDuration = compressionFunc(seg.duration);
            totalWeightedDuration += seg.weightedDuration;
        });
        
        // Determine the total pixel width available for rendering.
        const containerWidth = timelineContainerWrapper.clientWidth;
        const HORIZONTAL_MARGIN = 40; // Reduced margin for more space
        const drawableWidth = containerWidth - (2 * HORIZONTAL_MARGIN);

        // Calculate the pixel width for each segment based on its "weight".
        segments.forEach(seg => {
            const proportion = totalWeightedDuration > 0 ? seg.weightedDuration / totalWeightedDuration : 0;
            seg.pixelWidth = proportion * drawableWidth;
        });

        // Calculate the absolute pixel start position for each segment.
        let currentPixelPos = HORIZONTAL_MARGIN;
        segments.forEach(seg => {
            seg.pixelStart = currentPixelPos;
            currentPixelPos += seg.pixelWidth;
        });
        timelineWrapper.style.width = `${containerWidth}px`;
        timelineLine.style.width = `${containerWidth}px`;


        // --- BITESIZE STEP 3 & 4: Period & Event Positioning ---
        let periodVerticalToggle = true; // A dedicated toggle for periods
        let eventVerticalToggle = true;  // A dedicated toggle for events

        allItems.forEach(item => {
            // Find the start and end segments for the current item.
            const startSegment = segments.find(s => Math.abs(s.start - item.startYear) < 0.001);
            const endSegment = segments.find(s => Math.abs(s.end - item.endYear) < 0.001);

            if (!startSegment) {
                console.warn(`Could not find start segment for item:`, item);
                return;
            }

            if (item.type === 'period') {
                const isTop = periodVerticalToggle;
                periodVerticalToggle = !periodVerticalToggle; // Alternate for the next period

                // For periods, the brace spans from the start of its first segment
                // to the end of its last segment.
                const endPixel = endSegment ? endSegment.pixelStart + endSegment.pixelWidth : startSegment.pixelStart;
                const periodPixelStart = startSegment.pixelStart;
                const periodPixelWidth = endPixel - periodPixelStart;
                
                // This correctly places the bracket. If the duration is 0, the width is 0, making them touch.
                const brace = document.createElement('div');
                brace.className = `period-brace ${isTop ? 'top' : 'bottom'}`;
                brace.style.left = `${periodPixelStart}px`;
                brace.style.width = `${periodPixelWidth}px`;
                timelineWrapper.appendChild(brace);
                
                // Position the label card above/below the brace
                const cardWidth = Math.max(140, measureTextWidth(item.name) + 30);
                const eventElement = document.createElement('div');
                eventElement.className = `timeline-event ${isTop ? 'top' : 'bottom'}`;
                eventElement.innerHTML = `<div class="timeline-event-title">${item.name}</div><div class="timeline-event-date">${item.startStr} - ${item.endStr}</div>`;
                eventElement.style.width = `${cardWidth}px`;
                // Center the card over the brace
                eventElement.style.left = `${periodPixelStart + (periodPixelWidth / 2) - (cardWidth / 2)}px`;
                
                // Vertical positioning for periods
                const periodVerticalLevel = 18; // A bit further out
                eventElement.style.marginBottom = isTop ? `${periodVerticalLevel}px` : null;
                eventElement.style.marginTop = !isTop ? `${periodVerticalLevel}px` : null;

                eventElement.style.cursor = 'pointer';
                eventElement.onclick = () => handleTimelineCardClick(item, hybridData);
                timelineWrapper.appendChild(eventElement);

            } else { // type === 'event'
                const isTop = eventVerticalToggle;
                eventVerticalToggle = !eventVerticalToggle; // Alternate for the next event

                // For events, we find the period they belong to.
                let containingPeriod = null;
                for (const p of allItems) {
                    if (p.type === 'period' && item.startYear >= p.startYear && item.startYear <= p.endYear) {
                        containingPeriod = p;
                        break;
                    }
                }

                let eventPixelPos;
                if (containingPeriod) {
                    // --- THIS IS THE FIX FOR EVENT PLACEMENT ---
                    // Linearly interpolate the event's position within its containing period's pixel space.
                    const periodStartSeg = segments.find(s => Math.abs(s.start - containingPeriod.startYear) < 0.001);
                    const periodEndSeg = segments.find(s => Math.abs(s.end - containingPeriod.endYear) < 0.001);
                    
                    if(periodStartSeg) {
                        const periodPixelStart = periodStartSeg.pixelStart;
                        const periodPixelEnd = periodEndSeg ? periodEndSeg.pixelStart + periodEndSeg.pixelWidth : periodPixelStart;
                        const periodPixelWidth = periodPixelEnd - periodPixelStart;
                        const periodDuration = containingPeriod.endYear - containingPeriod.startYear;

                        if (periodDuration > 0) {
                            const timeRatio = (item.startYear - containingPeriod.startYear) / periodDuration;
                            eventPixelPos = periodPixelStart + (timeRatio * periodPixelWidth);
                        } else {
                            eventPixelPos = periodPixelStart; // Place at start if period has no duration
                        }
                    } else {
                         eventPixelPos = startSegment.pixelStart; // Fallback
                    }

                } else {
                    // If event is not in a period (standalone), place it at its segment start.
                    eventPixelPos = startSegment.pixelStart;
                }
                
                const cardWidth = 140;
                const eventWrapper = document.createElement('div');
                eventWrapper.className = `hybrid-event ${isTop ? 'top' : 'bottom'}`;
                eventWrapper.style.left = `${eventPixelPos - (cardWidth / 2)}px`;
                eventWrapper.style.width = `${cardWidth}px`;
                
                // Vertical positioning for events
                const eventVerticalLevel = 30; // Closer to the line
                eventWrapper.style.setProperty('--connector-height', `${eventVerticalLevel}px`);
                if (isTop) {
                    eventWrapper.style.bottom = '50%';
                    eventWrapper.style.marginBottom = '2px';
                } else {
                    eventWrapper.style.top = '50%';
                    eventWrapper.style.marginTop = '2px';
                }
                
                eventWrapper.innerHTML = `
                    <div class="timeline-event-card">
                        <div class="timeline-event-title">${item.name}</div>
                        <div class="timeline-event-date">${item.dateStr}</div>
                    </div>
                    <div class="timeline-connector"></div>
                `;
                eventWrapper.style.cursor = 'pointer';
                eventWrapper.onclick = () => handleTimelineCardClick(item, hybridData);
                timelineWrapper.appendChild(eventWrapper);
            }
        });
    });
}



/**
 * --- NEW: SKELETON LOADER FUNCTION ---
 * Clears the main content area and displays an animated skeleton loader
 * to indicate that content is being fetched.
 */
 function showSkeletonLoader() {
    const mainContent = document.getElementById('mainContent');
    mainContent.innerHTML = `
        <div class="skeleton-loader">
            <div class="skeleton-title"></div>
            <div class="skeleton-text"></div>
            <div class="skeleton-text"></div>
            <div class="skeleton-text short"></div>
            <br/>
            <div class="skeleton-text"></div>
            <div class="skeleton-text short"></div>
        </div>
    `;
}
        /**
 * --- NEW: PRE-FETCHING FUNCTION ---
 * Fetches the content for a given node in the background without showing a UI loading state.
 * This is used to pre-load content for cards before the user clicks on them.
 * @param {object} node - The tree node to fetch content for.
 */
/**
 * --- UPDATED WITH FULL PROMPT ---
 * Fetches the content for a given node in the background without showing a UI loading state.
 * This is used to pre-load content for cards before the user clicks on them.
 * @param {object} node - The tree node to fetch content for.
 */
 // =================== START: REPLACE THIS FUNCTION ===================
/**
 * Fetches node content in the background with a robust retry mechanism,
 * preserving the specific prefetch prompt and logic.
 * @param {object} node - The tree node to fetch content for.
 */
/**
 * Fetches node content in the background with a robust retry mechanism,
 * preserving the specific prefetch prompt and logic.
 */
 async function prefetchNodeContent(node) {
    // Silently exit if content already exists or is being fetched.
    if (node.content || node.isPrefetching) return;

    // Mark as prefetching to avoid duplicate calls
    node.isPrefetching = true;
    console.log(`%cPrefetching: "${node.fullTitle}"`, 'color: #34495e;');

    const maxRetries = 3;
    let success = false;

    for (let i = 0; i < maxRetries; i++) {
        try {
            const rootNode = treeStructure; // Get the root of the current topic
            const contextPrompt = (node.parent && node.parent.id !== 'root')
                ? ` In the context of "${node.parent.fullTitle}", `
                : '';

            // Assemble the full context object for the prompt
            const promptParams = {
                topicTitle: rootNode.fullTitle,
                sophistication: rootNode.sophistication,
                currentNodeTitle: node.fullTitle,
                journeyStructure: buildTreeStructureString(rootNode, node.id),
                lineageContent: getLineageContent(node.parent), // Use parent for prior context
                contextPrompt: contextPrompt
            };
            
            const prefetchPrompt = getPrefetchPrompt(promptParams);

            const prefetchConversation = [
                { role: "system", content: "You are an educational assistant." },
                { role: "user", content: prefetchPrompt }
            ];

            const response = await fetch(BACKEND_URL + '/chat', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ messages: prefetchConversation })
            });

            if (!response.ok) throw new Error(`Prefetch API failed for "${node.fullTitle}"`);

            const data = await response.json();
            const botResponseText = data.choices[0].message.content;

            const structuredResponse = sanitizeAndParseJson(botResponseText);

            const explanation = structuredResponse.explanation || "No explanation provided.";
            const definitions = structuredResponse.definitions || [];
            const visualAssets = structuredResponse.visualAssets || [];

            const parsed = parseResponse(explanation, definitions);
            parsed.visualAssets = visualAssets;
            parsed.showTellMeMore = true;

            node.content = parsed;
            
            success = true;
            break; 

        } catch (error) {
            console.error(`Prefetch attempt ${i + 1} of ${maxRetries} failed for "${node.fullTitle}":`, error);
            if (i < maxRetries - 1) {
                await new Promise(res => setTimeout(res, 500));
            }
        }
    }

    if (success) {
        console.log(`%c Prefetch successful for "${node.fullTitle}"`, 'color: #22c55e;');
        await saveTopicsToFirestore(); 
    } else {
        console.error(`Prefetch ultimately failed for "${node.fullTitle}" after ${maxRetries} attempts.`);
    }

    node.isPrefetching = false;
}
/**
 * A robust function to find, clean, and parse a JSON object from a raw text string.
 * This handles conversational text, code fences, and invalid escape characters.
 * @param {string} rawText The raw text response from the AI.
 * @returns {object} The parsed JavaScript object.
 */
 /**
 * A robust function to find, clean, and parse a JSON object from a raw text string.
 * This handles conversational text, code fences, comments, and invalid escape characters.
 * @param {string} rawText The raw text response from the AI.
 * @returns {object} The parsed JavaScript object.
 */
/**
 * A robust function to find, clean, and parse a JSON object from a raw text string.
 * This version includes debugging logs.
 * @param {string} rawText The raw text response from the AI.
 * @returns {object} The parsed JavaScript object.
 */
 /**
 * The final, most robust version of the JSON sanitizer.
 * This handles comments, backslashes, AND unescaped control characters.
 * @param {string} rawText The raw text response from the AI.
 * @returns {object} The parsed JavaScript object.
 */
/**
 * The final, most robust version of the JSON sanitizer.
 * This handles comments and backslashes, while letting the parser handle standard whitespace.
 * @param {string} rawText The raw text response from the AI.
 * @returns {object} The parsed JavaScript object.
 */
 /**
 * The final, most robust version of the JSON sanitizer.
 * This handles comments (without breaking URLs), backslashes, and other edge cases.
 * @param {string} rawText The raw text response from the AI.
 * @returns {object} The parsed JavaScript object.
 */
function sanitizeAndParseJson(rawText) {
    console.log("--- RAW AI RESPONSE ---", rawText);

    const startIndex = rawText.indexOf('{');
    const endIndex = rawText.lastIndexOf('}');

    if (startIndex === -1 || endIndex === -1 || endIndex < startIndex) {
        console.error("COULD NOT FIND JSON in the following text:", rawText);
        throw new Error("No valid JSON object found in the AI response.");
    }

    let jsonString = rawText.substring(startIndex, endIndex + 1);

    // --- THIS IS THE CORRECTED REGEX ---
    // It finds '//' but NOT when it is preceded by a colon, which protects "https://".
    jsonString = jsonString.replace(/(?<!:)\/\/.*/g, '');
    // ------------------------------------

    // The multi-line comment removal is still good.
    jsonString = jsonString.replace(/\/\*[\s\S]*?\*\//g, '');
    
    // This removes trailing commas from arrays or objects, which is another common AI error.
    jsonString = jsonString.replace(/,\s*([\]}])/g, '$1');

    console.log("--- FINAL STRING TO PARSE ---", jsonString);

    try {
        // We don't need to sanitize backslashes or newlines if we trust the parser.
        return JSON.parse(jsonString);
    } catch (e) {
        console.error("---!!!--- FINAL JSON PARSING FAILED ---!!!---");
        console.error("The specific error was:", e.message);
        throw e;
    }
}
// ==================== END: REPLACE THIS FUNCTION ====================
        /**
 * Creates the HTML for the category and sophistication tags.
 * @param {object} topicNode The topic's main node containing category and sophistication.
 * @returns {string} The HTML string for the tags.
 */
/**
 * Creates the HTML for the category and sophistication tags.
 * @param {object} topicNode The topic's main node containing category and sophistication.
 * @returns {string} The HTML string for the tags.
 */
 function createTagsHTML(topicNode) {
    const category = topicNode.category || 'General';
    const sophistication = topicNode.sophistication || 'Simple';
    const categoryColor = getCategoryColor(category);

    // This now returns clean HTML, relying on the stylesheet for layout.
    return `
        <div class="tags-container">
            <div class="tag" style="background-color: ${categoryColor};">
                ${category}
            </div>
            <div class="tag" style="background-color: #e5e7eb; color: #4b5563;">
                ${sophistication}
            </div>
        </div>
    `;
}
/**
 * Returns a background color based on the category name.
 * @param {string} category The category name.
 * @returns {string} A CSS hex color code.
 */
 function getCategoryColor(category) {
    const colors = {
        "Finance & Economics": "#059669",
        "Literature & Language": "#7c3aed",
        "History": "#d97706",
        "Science": "#2563eb",
        "Mathematics": "#db2777",
        "Technology & Engineering": "#6d28d9",
        "Philosophy & Ethics": "#c2410c",
        "Politics & Government": "#dc2626",
        "Art & Aesthetics": "#34495e",
        "Culture & Anthropology": "#c026d3",
        "Psychology & Human Behavior": "#0891b2",
        "Health & Medicine": "#16a34a",
        "Education & Learning": "#65a30d",
        "Sports & Physical Training": "#f59e0b",
        "Life Skills & Personal Development": "#22d3ee",
        "default": "#4b5563"
    };
    return colors[category] || colors["default"];
}
        // --- START OF NEW JAVASCRIPT FOR DELETION ---

// Get references to all the new HTML elements we added
const deleteTopicBtn = document.getElementById('deleteTopicBtn');
const deleteConfirmModal = document.getElementById('deleteConfirmModal');
const confirmDeleteBtn = document.getElementById('confirmDeleteBtn');
const cancelDeleteBtn = document.getElementById('cancelDeleteBtn');

// Helper functions to show and hide the modal
function openDeleteModal() {
    deleteConfirmModal.classList.add('active');
}

function closeDeleteModal() {
    deleteConfirmModal.classList.remove('active');
}

// When the user clicks the trash can icon, open the confirmation modal
deleteTopicBtn.addEventListener('click', openDeleteModal);

// If the user clicks 'Cancel' or outside the modal, just close it
cancelDeleteBtn.addEventListener('click', closeDeleteModal);
deleteConfirmModal.addEventListener('click', (e) => {
    if (e.target === deleteConfirmModal) {
        closeDeleteModal();
    }
});

// This is the main logic for when the user confirms the deletion
confirmDeleteBtn.addEventListener('click', () => {
    if (!currentTopicId) {
        alert("Error: No topic is currently loaded.");
        return;
    }

    const topicIdToDelete = currentTopicId;
    const topicDataBackup = { ...learningTopics[topicIdToDelete] }; // Backup for rollback

    // --- Optimistic UI Update ---
    // 1. Immediately delete the topic from the local state
    delete learningTopics[topicIdToDelete];
    console.log(`Optimistically deleted topic: ${topicIdToDelete}`);

    // 2. Immediately close the modal and update the UI
    closeDeleteModal();
    renderTopicCards();
    switchView('landingView');

    // 3. Perform the database operation in the background
    saveTopicsToFirestore()
        .then(() => {
            console.log("Deletion successfully saved to Firestore.");
        })
        .catch(error => {
            // --- Rollback on Failure ---
            console.error("Firestore deletion failed:", error);
            alert("Could not delete the topic from the cloud. It will be restored.");
            
            // Restore the topic locally
            learningTopics[topicIdToDelete] = topicDataBackup;
            
            // Re-render the UI to show the restored topic
            renderTopicCards();
        });
});

// --- END OF NEW JAVASCRIPT FOR DELETION ---
        /**
 * Converts a string to Title Case.
 * @param {string} str The string to convert.
 * @returns {string} The Title Cased string.
 */
 function toTitleCase(str) {
    if (!str) return '';
    // The .toLowerCase() has been removed to preserve existing capitalization within words.
    return str.replace(
        /\w\S*/g,
        (txt) => txt.charAt(0).toUpperCase() + txt.substr(1)
    );
}
        // --- ADD THIS SNIPPET FOR SIGN OUT FUNCTIONALITY ---

// Get a reference to the new sign-out button
const signOutBtn = document.getElementById('signOutBtn');

// Add a click event listener to the button
signOutBtn.addEventListener('click', () => {
    // Use the Firebase auth object to sign the user out
    auth.signOut()
        .then(() => {
            // This .then() block runs on successful sign-out
            console.log("User signed out successfully.");
            // You don't need to do anything else here.
            // The `onAuthStateChanged` listener will automatically detect the sign-out
            // and show the login screen.
        })
        .catch((error) => {
            // This .catch() block runs if there was an error
            console.error("Sign-out error:", error);
        });
});
        // Import the functions you need from the SDKs you need

// TODO: Add SDKs for Firebase products that you want to use
// https://firebase.google.com/docs/web/setup#available-libraries

// Your web app's Firebase configuration
// For Firebase JS SDK v7.20.0 and later, measurementId is optional
const firebaseConfig = {
  apiKey: "AIzaSyBkDl26l4dEQWp5E3-i-Tg1NzkAYDC4ELE",
  authDomain: "my-learning-app-8b760.firebaseapp.com",
  projectId: "my-learning-app-8b760",
  storageBucket: "my-learning-app-8b760.firebasestorage.app",
  messagingSenderId: "449522463774",
  appId: "1:449522463774:web:3eb0d9e6bd9164e8972a0f",
  measurementId: "G-N4N54809FB"
};

// Initialize Fireba
const app = firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.firestore();
const googleProvider = new firebase.auth.GoogleAuthProvider();

 // ======================= START: ADD THIS CODE =======================
 window.addEventListener('beforeunload', () => {
        // Only save the state if a topic is actually loaded and the user is in the learning view.
        if (currentTopicId && currentTreeNode && document.getElementById('learningView').classList.contains('active')) {
            const stateToSave = {
                topicId: currentTopicId,
                nodeId: currentTreeNode.id
            };
            // Use sessionStorage to store the state for the current session.
            // It's automatically cleared when the browser tab is closed.
            sessionStorage.setItem('learningAppLastState', JSON.stringify(stateToSave));
            console.log('Saved state to sessionStorage:', stateToSave);
        }
    });
    // ======================== END: ADD THIS CODE ========================

// At the top of your script, get references to the new elements
const authView = document.getElementById('authView');
const appContainer = document.getElementById('appContainer');
const loginBtn = document.getElementById('loginBtn');
const signupBtn = document.getElementById('signupBtn');
const emailInput = document.getElementById('emailInput');
const passwordInput = document.getElementById('passwordInput');
const authError = document.getElementById('authError');

// --- Authentication Logic ---

// Listen for login/signup button clicks
// --- Replace your existing loginBtn listener with this enhanced version ---

loginBtn.addEventListener('click', () => {
    const authError = document.getElementById('authError');

    // Clear previous messages and set color to red for potential errors
    authError.textContent = '';
    authError.style.color = '#dc2626'; // Default to red for errors

    auth.signInWithEmailAndPassword(emailInput.value, passwordInput.value)
        .catch(error => {
            let userMessage;

            // Check for specific Firebase error codes
            switch (error.code) {
                case 'auth/invalid-login-credentials':
                case 'auth/user-not-found':
                case 'auth/wrong-password':
                    userMessage = 'Incorrect email or password. Please try again.';
                    break;
                case 'auth/invalid-email':
                    userMessage = 'Please enter a valid email address.';
                    break;
                case 'auth/too-many-requests':
                    userMessage = 'Access to this account has been temporarily disabled. Please reset your password or try again later.';
                    break;
                case 'auth/network-request-failed':
                    userMessage = 'Network error. Please check your connection.';
                    break;
                default:
                    // A catch-all for any other errors
                    userMessage = 'An unexpected error occurred. Please try again.';
                    console.error("Login Error:", error); // Log the original error for you to see
                    break;
            }

            authError.textContent = userMessage;

            // Make the error message disappear after 5 seconds
            setTimeout(() => {
                authError.textContent = '';
            }, 5000);
        });
});

// --- Replace your signupBtn listener with this one ---
signupBtn.addEventListener('click', () => {
    const authError = document.getElementById('authError');
    authError.textContent = ''; // Clear previous errors

    auth.createUserWithEmailAndPassword(emailInput.value, passwordInput.value)
        .then((userCredential) => {
            // User created successfully. Now, send the verification email.
            console.log('User created, sending verification email...');
            return userCredential.user.sendEmailVerification();
        })
        .then(() => {
            console.log('Verification email sent.');
            // The onAuthStateChanged listener will automatically show the 'verify email' screen.
        })
        .catch(error => {
            // Handle signup errors (e.g., email already in use)
            authError.textContent = error.message;
        });
});

// This is the gatekeeper. It checks if a user is logged in or not.
// --- Replace your entire onAuthStateChanged function with this new gatekeeper ---
auth.onAuthStateChanged(user => {
    const authView = document.getElementById('authView');
    const appContainer = document.getElementById('appContainer');
    const verifyEmailView = document.getElementById('verifyEmailView'); // Get the new view

    if (user) {
        // User is signed in. Check if their email is verified.
        if (user.emailVerified) {
            // --- User is verified, let them in ---
            authView.style.display = 'none';
            verifyEmailView.style.display = 'none';
            appContainer.style.display = 'block';

            // Load their data as normal
            loadTopicsFromFirestore(user.uid);
        } else {
            // --- User is NOT verified, show the verify screen ---
            authView.style.display = 'none';
            appContainer.style.display = 'none';
            
            // Display the user's email on the verification page
            document.getElementById('verificationEmail').textContent = user.email;
            verifyEmailView.style.display = 'flex';
        }
    } else {
        // --- User is signed out, show the login form ---
        authView.style.display = 'flex';
        appContainer.style.display = 'none';
        verifyEmailView.style.display = 'none';
    }
});
// Function to save the entire learningTopics object to Firestore
// Replace the existing function with this one
/**
 * Creates a deep copy of the learning topics object and removes the circular
 * 'parent' properties so it can be safely saved to Firestore.
 * @param {object} topicsObject - The original learningTopics object.
 * @returns {object} A clean copy of the object suitable for JSON stringification.
 */
 /**
 * Recursively creates a deep copy of a topic node and its children,
 * omitting the 'parent' property to make it safe for Firestore.
 * @param {object} originalNode The node to clean.
 * @returns {object} A clean, saveable copy of the node and its descendants.
 */
function createSaveableCopy(originalNode) {
    const newNode = {};

    // Copy all properties from the original node to the new one, EXCEPT 'parent'.
    for (const key in originalNode) {
        if (key !== 'parent' && Object.hasOwnProperty.call(originalNode, key)) {
            newNode[key] = originalNode[key];
        }
    }

    // If the original node has children, recursively clean them.
    if (originalNode.children && originalNode.children.length > 0) {
        newNode.children = originalNode.children.map(child => createSaveableCopy(child));
    }

    return newNode;
}


async function saveTopicsToFirestore() {
    console.log("Attempting to save topics...");
    const user = auth.currentUser;

    if (user) {
        console.log("User found:", user.uid);
        
        try {
            // --- THIS IS THE NEW FIX ---
            const topicsToSave = {};

            // Go through each main topic in your learningTopics object
            for (const topicId in learningTopics) {
                if (Object.hasOwnProperty.call(learningTopics, topicId)) {
                    // Create a clean, saveable copy of each topic's tree structure
                    topicsToSave[topicId] = createSaveableCopy(learningTopics[topicId]);
                }
            }
            // --------------------------

            console.log("Clean data to be saved:", topicsToSave);
            
            await db.collection('userTopics').doc(user.uid).set({
                topics: topicsToSave
            });
            
            console.log("SUCCESS: Topics saved to Firestore!");

        } catch (error) {
            console.error("FIRESTORE SAVE ERROR:", error);
        }
    } else {
        console.log("Save failed: No user is currently logged in.");
    }
}
// ADD THIS EVENT LISTENER
window.addEventListener('beforeunload', () => {
    if (currentTopicId && currentTreeNode && document.getElementById('learningView').classList.contains('active')) {
        const stateToSave = {
            topicId: currentTopicId,
            nodeId: currentTreeNode.id
        };
        sessionStorage.setItem('learningAppLastState', JSON.stringify(stateToSave));
        console.log('Saved state to sessionStorage:', stateToSave);
    }
});


// Function to load topics when a user logs in
// =================== START: REPLACE THIS FUNCTION ===================
// REPLACE the entire loadTopicsFromFirestore function
async function loadTopicsFromFirestore(userId) {
    try {
        const doc = await db.collection('userTopics').doc(userId).get();
        if (doc.exists) {
            const data = doc.data();
            learningTopics = restoreAndFixData(data.topics);
            console.log("Topics loaded successfully! IDs are now persistent.");
        } else {
            console.log("No saved topics found for this user. Starting fresh.");
            learningTopics = {};
        }

        // Attempt to restore the last session.
        const wasSessionRestored = restoreLastSession();

        // If a session was NOT restored, show the default landing page.
        if (!wasSessionRestored) {
            renderTopicCards();
            switchView('landingView');
        }
    } catch (error) {
        console.error("Error loading topics: ", error);
        renderTopicCards();
        switchView('landingView');
    }
}
// ==================== END: REPLACE THIS FUNCTION ====================

// Helper function to restore the parent-child links in your tree
// REPLACE the existing restoreParents function with this new one
function restoreAndFixData(topics) {
    Object.values(topics).forEach(topic => {
        function traverse(node, parent) {
            // Assign a persistent ID if one doesn't exist (for old data)
            if (!node.id) {
                node.id = generateUniqueId();
            }
            // Restore the circular parent reference
            node.parent = parent;

            if (node.children) {
                node.children.forEach(child => traverse(child, node));
            }
        }
        traverse(topic, null);
    });
    return topics;
}
// You also need a logout button. Add this to your main app's navigation controls.
// <button id="logoutBtn" class="nav-button">Logout</button>
// And add the event listener for it:
// document.getElementById('logoutBtn').addEventListener('click', () => auth.signOut());

        /**
 * A universal "catch-all" parser that finds numbered list items
 * anywhere in a string, whether it's plain text or embedded in JSON.
 * @param {string} text - The raw text response from the AI.
 * @returns {Array<Object>} An array of section objects.
 */
/**
 * A universal "catch-all" parser that finds numbered list items
 * anywhere in a string, whether it's plain text or embedded in JSON.
 * @param {string} text - The raw text response from the AI, which may contain newlines.
 * @returns {Array<Object>} An array of section objects.
 */
 /**
 * A universal "catch-all" parser that finds numbered list items
 * anywhere in a string, whether it's plain text or embedded in JSON.
 * @param {string} text - The raw text response from the AI.
 * @returns {Array<Object>} An array of section objects.
 */
function universalParseSyllabus(text) {
    const sections = [];

    // --- THIS IS THE FIX ---
    // First, normalize the string by replacing the literal characters '\\n'
    // with an actual newline character '\n'. This handles the AI's output format.
    const normalizedText = text.replace(/\\n/g, '\n');
    // ---------------------

    const flexibleRegex = /^\s*(?:\d+\.|\-|\*)\s+(.+)$/gm;
    let match;

    // IMPORTANT: Run the regex on the NEW, normalizedText variable
    while ((match = flexibleRegex.exec(normalizedText)) !== null) {
        // The captured title is in match[1]. We trim it and remove any markdown bolding.
        const title = match[1].replace(/\*\*/g, '').trim();

        sections.push({
            title: title,
            content: "",
            fullContent: "",
            isExpanded: false
        });
    }

    console.log("DEBUG: Universal parser now finds sections:", sections);
    return sections;
}
        let currentQuizQuestions = [];
        let currentQuestionIndex = 0;
        let userScore = 0;
        /**
 * Shows or hides a loading spinner on the new topic modal's submit button.
 * @param {boolean} isLoading - Whether to show the loading state.
 */
 function showModalLoading(isLoading) {
    const submitBtn = document.getElementById('submitTopicBtn');
    if (isLoading) {
        submitBtn.disabled = true;
        submitBtn.innerHTML = '<span class="loading-spinner" style="width: 16px; height: 16px; border-width: 2px; margin-right: 8px;"></span>Loading...';
    } else {
        submitBtn.disabled = false;
        submitBtn.innerHTML = 'Submit';
    }
}
/**
 * Parses the raw text response from the syllabus API call.
 * @param {string} text - The raw text from the AI.
 * @returns {Array<Object>} An array of section objects.
 */

 function gatherReadContent(node) {
    let compiledText = '';

    // A recursive inner function to traverse the tree
    function traverse(currentNode) {
        if (!currentNode) return;

        // If the node is read and has content, add it to our "study guide"
        if (currentNode.isRead && currentNode.content && currentNode.content.overview) {
            // Strip HTML tags for a cleaner text to send to the AI
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = currentNode.content.overview;
            compiledText += (tempDiv.textContent || tempDiv.innerText || "") + "\n\n";
        }

        // Recurse for all children
        if (currentNode.children && currentNode.children.length > 0) {
            currentNode.children.forEach(child => traverse(child));
        }
    }

    traverse(node);
    return compiledText;
}
async function fetchQuiz(textContent) {
    showModalLoading(true); // Re-using your existing modal loader
    const prompt = `Based *only* on the following text, create a multiple-choice quiz with 6-10 questions. The questions must be answerable solely from the provided text.

    Your response MUST be a valid JSON object. Do not include any other text or explanations. The JSON object should follow this exact structure:
    {
      "questions": [
        {
          "questionText": "A question based on the text.",
          "options": ["Option A", "Option B", "Option C", "Option D"],
          "correctAnswerIndex": 1 
        }
      ]
    }

    TEXT:
    ---
    ${textContent}
    ---
    `;

    try {
        // Using a temporary history for this specific, one-off request
        const quizConversation = [
            { role: "system", content: "You are a quiz generation assistant." },
            { role: "user", content: prompt }
        ];

        const response = await fetch(BACKEND_URL + '/chat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ messages: quizConversation })
        });

        if (!response.ok) throw new Error('API request failed');

        const result = await response.json();
        const botResponseText = result.choices[0].message.content;
        
        // Find the JSON part of the response and parse it
        const jsonMatch = botResponseText.match(/\{[\s\S]*\}/);
        if (!jsonMatch) throw new Error("No valid JSON object found in the AI response.");
        
        const parsedJson = repairJsonKeys(jsonMatch[0]);
        const structuredResponse = JSON.parse(fixedJson);
        return parsedJson.questions || [];

    } catch (error) {
        console.error("Error fetching or parsing quiz:", error);
        showError("Could not generate the quiz. The AI may have returned an invalid format.");
        return [];
    } finally {
        showModalLoading(false);
    }
}
let selectedOptionIndex = null; // Track which option is selected

function displayQuestion() {
    selectedOptionIndex = null;
    const question = currentQuizQuestions[currentQuestionIndex];
    const quizOptionsContainer = document.getElementById('quizOptions');
    
    document.getElementById('quizTitle').textContent = `Question ${currentQuestionIndex + 1} of ${currentQuizQuestions.length}`;
    document.getElementById('quizQuestionText').textContent = question.questionText;
    document.getElementById('quizFeedback').textContent = '';
    quizOptionsContainer.innerHTML = '';

    question.options.forEach((option, index) => {
        const optionEl = document.createElement('div');
        optionEl.className = 'quiz-option';
        optionEl.textContent = option;
        optionEl.onclick = () => {
            // Remove 'selected' from any other option
            document.querySelectorAll('.quiz-option').forEach(el => el.classList.remove('selected'));
            // Add 'selected' to the clicked one
            optionEl.classList.add('selected');
            selectedOptionIndex = index;
        };
        quizOptionsContainer.appendChild(optionEl);
    });

    const submitBtn = document.getElementById('quizSubmitBtn');
    submitBtn.textContent = 'Submit';
    submitBtn.onclick = checkAnswer;
    submitBtn.disabled = false;
}

function checkAnswer() {
    if (selectedOptionIndex === null) {
        alert("Please select an answer.");
        return;
    }

    const question = currentQuizQuestions[currentQuestionIndex];
    const feedbackEl = document.getElementById('quizFeedback');
    const options = document.querySelectorAll('.quiz-option');
    
    // Disable all options after submission
    options.forEach(opt => opt.onclick = null);

    if (selectedOptionIndex === question.correctAnswerIndex) {
        userScore++;
        feedbackEl.textContent = "Correct!";
        feedbackEl.className = 'correct';
        options[selectedOptionIndex].classList.add('correct');
    } else {
        feedbackEl.textContent = "Incorrect. The correct answer is highlighted.";
        feedbackEl.className = 'incorrect';
        options[selectedOptionIndex].classList.add('incorrect');
        options[question.correctAnswerIndex].classList.add('correct');
    }

    const submitBtn = document.getElementById('quizSubmitBtn');
    if (currentQuestionIndex < currentQuizQuestions.length - 1) {
        submitBtn.textContent = 'Next Question';
        submitBtn.onclick = () => {
            currentQuestionIndex++;
            displayQuestion();
        };
    } else {
        submitBtn.textContent = 'Show Results';
        submitBtn.onclick = displayResults;
    }
}

function displayResults() {
    document.getElementById('quizArea').style.display = 'none';
    document.getElementById('quizSubmitBtn').style.display = 'none';

    const resultsEl = document.getElementById('quizResults');
    document.getElementById('quizScoreText').textContent = `Your Score: ${userScore} / ${currentQuizQuestions.length}`;
    resultsEl.style.display = 'block';
}

function closeQuizModal() {
    document.getElementById('quizModal').classList.remove('active');
    // Reset for next time
    document.getElementById('quizArea').style.display = 'block';
    document.getElementById('quizSubmitBtn').style.display = 'block';
    document.getElementById('quizResults').style.display = 'none';
}
async function startQuiz() {
    // 1. Gather Content
    const quizMeBtn = document.getElementById('quizMeBtn');
    quizMeBtn.disabled = true;
    quizMeBtn.textContent = 'Generating...';

    const textContent = gatherReadContent(currentTreeNode);
    if (textContent.length < 100) { // Require a minimum amount of text
        alert("You need to read more content before a quiz can be generated.");
        quizMeBtn.disabled = false;
        quizMeBtn.textContent = 'Quiz Me On This Topic';
        return;
    }

    // 2. Fetch Quiz Questions
    const questions = await fetchQuiz(textContent);
    
    quizMeBtn.disabled = false;
    quizMeBtn.textContent = 'Quiz Me On This Topic';

    if (!questions || questions.length === 0) {
        return; // Error is already shown by fetchQuiz
    }

    // 3. Initialize and Display Quiz
    currentQuizQuestions = questions;
    currentQuestionIndex = 0;
    userScore = 0;

    document.getElementById('quizModal').classList.add('active');
    displayQuestion();
}
 // REPLACE the old parseSyllabusResponse function with this new one.

function parseSyllabusResponse(text) {
    const sections = [];
    
    // This new, more flexible regex handles multiple list formats:
    // - Numbered lists (e.g., "1. Title")
    // - Hyphenated lists (e.g., "- Title")
    // - Asterisk lists (e.g., "* Title")
    // It also ignores leading whitespace.
    const flexibleRegex = /^\s*(?:\d+\.|\-|\*)\s+(.+)$/gm;
    let match;

    while ((match = flexibleRegex.exec(text)) !== null) {
        // The captured title is in match[1].
        // We still trim it and remove any markdown bolding.
        console.log("DEBUG: Regex found a match:", match[0]);

        const title = match[1].replace(/\*\*/g, '').trim(); 
        
        sections.push({
            title: title,
            content: "", 
            fullContent: "",
            isExpanded: false
        });
    }
    
    // This ensures that even if the AI's response has extra text, 
    // we can still extract the list items.
    return sections;
}
        // --- NEW: In-Memory Storage for Topics ---
let learningTopics = {};
let currentTopicId = null; // <-- ADD THIS LINE
/**
 * Clears and redraws the topic cards on the landing page from our storage.
 */
 /**
 * Clears and redraws the topic cards on the landing page from our storage.
 */
/**
 * Clears and redraws the topic cards on the landing page from our storage.
 */
 // --- NEW SORTING AND RENDERING LOGIC ---

// Add this state variable near the top of your script
let currentSort = 'recent';

/**
 * Creates the DOM element for a single topic card.
 * @param {object} topic The topic data object, including its ID.
 * @returns {HTMLElement} The card element.
 */
function createTopicCardDOM(topic) {
    const card = document.createElement('div');
    card.className = 'topic-card';
    
    // This logic is extracted from the old renderTopicCards function
    const category = topic.category || 'General';
    const categoryColor = getCategoryColor(category);
    const sophistication = topic.sophistication || 'Simple';

    card.innerHTML = `
        <div class="tags-container">
            <div class="tag" style="background-color: ${categoryColor};">
                ${category}
            </div>
            <div class="tag" style="background-color: #e5e7eb; color: #4b5563;">
                ${sophistication}
            </div>
        </div>
        <h2>${toTitleCase(topic.fullTitle || topic.title)}</h2>
        <p>Click to continue learning.</p>
    `;

    // Use the topic's ID for the click handler
    card.onclick = () => loadLearningTopic(topic.id);
    return card;
}


/**
 * Clears and redraws the topic cards on the landing page based on the current sort order.
 */
function renderTopicCards() {
    const grid = document.getElementById('topicGrid');
    grid.innerHTML = ''; 

    // Convert topics object to a usable array, making sure to include the ID
    const topicsArray = Object.entries(learningTopics).map(([id, data]) => ({ ...data, id: id }));

    if (topicsArray.length === 0) {
    grid.className = 'empty';
    grid.innerHTML = `
        <div style="text-align: center;">
            <h2 style="font-size: 28px; color: #11182c; margin-bottom: 16px; font-weight: 700;">
                Welcome to Your Interactive Learning Journey
            </h2>
            <p style="color: #4b5563; font-size: 16px; line-height: 1.5; margin-bottom: 30px;">
                Learn about any topics from personal interests to complex academic subjects in a personalized, responsive and visual way. Dive deeper on elements of particular interest to you and become learned in any topic! 
            </p>
            
            <div style="display: flex; gap: 20px; margin: 30px 0; justify-content: center; flex-wrap: wrap;">
                <div style="background: #f9fafb; padding: 20px; border-radius: 12px; border: 1px solid #e5e7eb; width: 250px;">
                    <div style="font-size: 28px; margin-bottom: 12px;"></div>
                    <h3 style="font-size: 16px; color: #11182c; margin-bottom: 8px;">Interactive Graphs</h3>
                    <p style="color: #6b7280; font-size: 13px; line-height: 1.4;">
                        Explore math with live function plotters. Zoom, pan, and see equations in real-time.
                    </p>
                </div>
                
                <div style="background: #f9fafb; padding: 20px; border-radius: 12px; border: 1px solid #e5e7eb; width: 250px;">
                    <div style="font-size: 28px; margin-bottom: 12px;"></div>
                    <h3 style="font-size: 16px; color: #11182c; margin-bottom: 8px;">Dynamic Timelines</h3>
                    <p style="color: #6b7280; font-size: 13px; line-height: 1.4;">
                        Visualize history with intelligent timelines showing periods of history and particular events.
                    </p>
                </div>
                
                <div style="background: #f9fafb; padding: 20px; border-radius: 12px; border: 1px solid #e5e7eb; width: 250px;">
                    <div style="font-size: 28px; margin-bottom: 12px;"></div>
                    <h3 style="font-size: 16px; color: #11182c; margin-bottom: 8px;">Knowledge Trees</h3>
                    <p style="color: #6b7280; font-size: 13px; line-height: 1.4;">
                        Build understanding with a visual map of your learning journey.
                    </p>
                </div>
            </div>
            
            <button class="new-topic-btn" onclick="document.getElementById('newTopicBtn').click()" style="font-size: 16px; padding: 12px 24px;">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14m-7-7h14"/></svg>
                Start Your First Learning Journey
            </button>
            
            <p style="color: #9ca3af; font-size: 13px; margin-top: 20px;">
                Try "Quadratic Equations", "Medieval Spanish History", or "US political system" to get started!
            </p>
        </div>
    `;
    return;
}

    if (currentSort === 'recent') {
        grid.className = 'topic-grid-layout'; // Use the standard grid layout
        // Sort by most recently opened
        topicsArray.sort((a, b) => (b.lastOpened || 0) - (a.lastOpened || 0));
        
        topicsArray.forEach(topic => {
            const card = createTopicCardDOM(topic);
            grid.appendChild(card);
        });

    } else if (currentSort === 'category') {
        grid.className = 'category-view'; // Use the new block layout for headers
        
        // Group topics by their category
        const grouped = topicsArray.reduce((acc, topic) => {
            const category = topic.category || 'General';
            if (!acc[category]) acc[category] = [];
            acc[category].push(topic);
            return acc;
        }, {});

        // Sort the category names alphabetically
        const sortedCategories = Object.keys(grouped).sort();

        sortedCategories.forEach(category => {
            // Add category header
            const header = document.createElement('h2');
            header.className = 'category-header';
            header.textContent = category;
            grid.appendChild(header);

            // Create a sub-grid for this category's topics
            const categoryGrid = document.createElement('div');
            categoryGrid.className = 'topic-grid-layout';
            grid.appendChild(categoryGrid);

            // Sort topics within this category by most recent
            const topicsInCategory = grouped[category];
            topicsInCategory.sort((a, b) => (b.lastOpened || 0) - (a.lastOpened || 0));
            
            topicsInCategory.forEach(topic => {
                const card = createTopicCardDOM(topic);
                categoryGrid.appendChild(card);
            });
        });
    }
}


// --- Add this event listener setup inside your main script execution area ---
// (e.g., inside the DOMContentLoaded listener)

document.getElementById('sortControls').addEventListener('click', (e) => {
    if (e.target.matches('.sort-btn')) {
        // Ignore click if the button is already active
        if (e.target.classList.contains('active')) return;

        // Update the active state on buttons
        document.querySelectorAll('.sort-btn').forEach(btn => btn.classList.remove('active'));
        e.target.classList.add('active');

        // Get the new sort preference and re-render the topic cards
        currentSort = e.target.dataset.sort;
        renderTopicCards();
    }
});

// =================== START: REPLACE THIS CODE BLOCK ===================

/**
 * Sets up the learning view for a given topic, but does not navigate to a node.
 * @param {string} topicId - The ID of the topic to set up.
 * @returns {boolean} True if setup was successful, false otherwise.
 */
 function setupLearningViewForTopic(topicId) {
    currentTopicId = topicId;
    const topicData = learningTopics[topicId];
    if (!topicData) {
        console.error("Topic not found:", topicId);
        return false;
    }
    topicData.lastOpened = Date.now(); // Update last opened time

    treeStructure = topicData;
    navigationHistory = [];
    currentHistoryIndex = -1;

    document.getElementById('sidebarTitle').innerHTML = createTagsHTML(treeStructure);
    switchView('learningView');
    return true;
}
// ======================= START: ADD THIS CODE =======================
/**
 * Checks sessionStorage for a saved state and restores it if found.
 * @returns {boolean} True if a state was successfully restored, otherwise false.
 */
 function restoreLastSession() {
    const savedStateJSON = sessionStorage.getItem('learningAppLastState');
    if (savedStateJSON) {
        // Clear the state once we've read it, so a subsequent refresh doesn't
        // get stuck in a loop if something goes wrong.
        sessionStorage.removeItem('learningAppLastState');
        try {
            const savedState = JSON.parse(savedStateJSON);
            const { topicId, nodeId } = savedState;

            // Check if the saved topic and node still exist in our loaded data.
            if (topicId && nodeId && learningTopics[topicId]) {
                const topicData = learningTopics[topicId];
                const targetNode = findNodeById(topicData, nodeId);

                if (targetNode) {
                    console.log('Restoring previous session state:', savedState);
                    // Use the helper to set up the main view
                    if(setupLearningViewForTopic(topicId)) {
                        // Then navigate to the specific node from the saved state.
                        navigateToNode(nodeId);
                        return true; // Indicate that state was restored.
                    }
                }
            }
        } catch (error) {
            console.error('Failed to parse or restore session state:', error);
            // In case of error, ensure the corrupted state is cleared.
            sessionStorage.removeItem('learningAppLastState');
        }
    }
    return false; // No valid state was found or restored.
}
// ======================== END: ADD THIS CODE ========================

// This is the updated `loadLearningTopic` function
// REPLACE the existing loadLearningTopic function
// =================== START: REPLACE THIS FUNCTION ===================
/**
 * Loads a specific topic's data into the learning view, resuming at the
 * last visited node if one exists.
 * @param {string} topicId - The ID of the topic to load.
 */
 function loadLearningTopic(topicId) {
    if (setupLearningViewForTopic(topicId)) {
        const topicData = learningTopics[topicId];
        const lastNodeId = topicData.lastVisitedNodeId;

        // Check if a last visited node ID has been saved for this topic
        // and also make sure that node still actually exists in our data.
        if (lastNodeId && findNodeById(topicData, lastNodeId)) {
            console.log(`Resuming topic '${topicId}' at last visited node: ${lastNodeId}`);
            navigateToNode(lastNodeId);
        } else {
            // If there's no saved spot, or if it's invalid, just start from the root.
            console.log(`Starting topic '${topicId}' from the beginning.`);
            navigateToNode('root');
        }
    }
}
// ==================== END: REPLACE THIS FUNCTION ====================

// ==================== END: REPLACE THIS CODE BLOCK ====================
       /**
 * Resets the learning view and displays the initial syllabus for a new topic.
 * @param {string} topicTitle - The title of the new topic.
 * @param {Array<Object>} syllabusSections - An array of section objects for the syllabus.
 * @param {string} topicId - The unique ID for this new topic.
 */
 // Find and replace this entire function
/**
 * Resets the learning view and displays the initial syllabus for a new topic.
 * @param {string} topicTitle - The title of the new topic.
 * @param {Array<Object>} syllabusSections - An array of section objects for the syllabus.
 * @param {string} topicId - The unique ID for this new topic.
 * @param {string} category - The category assigned to this topic.
 */
 /**
 * Resets the learning view and displays the initial syllabus for a new topic.
 * @param {string} topicTitle - The title of the new topic.
 * @param {Array<Object>} syllabusSections - An array of section objects for the syllabus.
 * @param {string} topicId - The unique ID for this new topic.
 * @param {string} category - The category assigned to this topic.
 * @param {string} sophistication - The sophistication level for the topic.
 */
 function startLearningTopic(topicTitle, syllabusSections, topicId, category, sophistication, visualAssets = null) {
    console.log("Step 2: visualAssets passed into startLearningTopic:", visualAssets);
    currentTopicId = topicId;
    navigationHistory = [];
    currentHistoryIndex = -1;

    treeStructure = createTreeNode(topicTitle, null, null);
    treeStructure.id = 'root';
    treeStructure.category = category; 
    treeStructure.sophistication = sophistication; // <-- STORE THE SOPHISTICATION LEVEL
    treeStructure.lastOpened = Date.now(); // ADD THIS LINE
    currentTreeNode = treeStructure;

    const topicContent = {
    overview: `An introduction to the key areas of ${toTitleCase(topicTitle)}. Select a card to begin.`,
    sections: syllabusSections,
    definitions: [],
    visualAssets: visualAssets || [] // Add this line
};
    treeStructure.content = topicContent;

    syllabusSections.forEach(section => {
        createTreeNode(section.title, null, treeStructure, false); 
    });

    learningTopics[topicId] = treeStructure; 
    
    document.getElementById('sidebarTitle').innerHTML = createTagsHTML(treeStructure);
    navigateToNode('root');
    switchView('learningView');
    saveTopicsToFirestore();

    treeStructure.children.forEach(childNode => {
        prefetchNodeContent(childNode);
    });
}

        const BACKEND_URL = '/api';
        const PLOT_COLORS = ['#191970', '#f59e0b', '#14b8a6', '#ef4444', '#34495e', '#3b82f6'];
        // Navigation and content management
        let navigationHistory = [];
        let currentHistoryIndex = -1;
        let treeStructure = {
            id: 'root',
            title: 'Home',
            content: null,
            children: [],
            isUserQuestion: false,
            sectionIndex: null
        };
        let currentTreeNode = treeStructure;

        // Current context tracking
        let currentContext = {
            topic: null,
            subtopic: null,
            fullContent: null
        };

        // Initialize conversation history
        // Initialize conversation history
// Initialize conversation history
// Initialize conversation history

// --- NEW: View and Modal Management Functions ---

/**
 * Hides all views and shows the one with the specified ID.
 * @param {string} viewId - The ID of the view to show ('landingView' or 'learningView').
 */
 function switchView(viewId) {
    // Hide all views first
    document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
    // Show the requested view
    document.getElementById(viewId).classList.add('active');
}

/**
 * Opens the "New Topic" modal dialog.
 */
function openNewTopicModal() {
    newTopicModal.classList.add('active');
}

/**
 * Closes the "New Topic" modal dialog.
 */
function closeNewTopicModal() {
    newTopicModal.classList.remove('active');
    document.getElementById('topicInput').value = ''; // Clear input on close
}

/**
 * Handles the submission of a new topic from the modal.
 */
/**
 * Handles the submission of a new topic from the modal.
 */
 /**
 * Handles the submission of a new topic from the modal.
 */
/**
 * Handles the submission of a new topic from the modal by calling the Gemini API.
 */
 /**
 * Handles the submission of a new topic from the modal by calling the Gemini API.
 */
/**
 * Handles the submission of a new topic from the modal by calling the local backend server.
 */
 async function handleNewTopicSubmit() {
    const topic = document.getElementById('topicInput').value.trim();
    const sophistication = document.querySelector('.sophistication-option.active').dataset.level;

    if (!topic) {
        alert('Please enter a topic to learn about.');
        return;
    }

    showModalLoading(true);

    const categories = [
        "Finance & Economics", "Literature & Language", "History", "Science", 
        "Mathematics", "Technology & Engineering", "Philosophy & Ethics", 
        "Politics & Government", "Art & Aesthetics", "Culture & Anthropology", 
        "Psychology & Human Behavior", "Health & Medicine", "Education & Learning", 
        "Sports & Physical Training", "Life Skills & Personal Development"
    ];

    // This new prompt asks for a JSON object with two keys: "category" and "syllabus".
    // REPLACE the existing prompt in the handleNewTopicSubmit function

    const prompt = getSyllabusPrompt(topic, sophistication, categories);

    try {
        const syllabusConversation = [
            { role: "system", content: "You are an educational assistant specializing in creating and categorizing a syllabus." },
            { role: "user", content: prompt }
        ];

        const response = await fetch(BACKEND_URL + '/chat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ messages: syllabusConversation })
        });

        if (!response.ok) {
            throw new Error(`API response was not ok. Status: ${response.status}`);
        }

        const result = await response.json();
        const botResponseText = result.choices[0].message.content;
        console.log("DEBUG: Raw AI response:", botResponseText);

        const parsedResponse = sanitizeAndParseJson(botResponseText);

        const { category, syllabus, visualAssets } = parsedResponse;       
        if (!category || !syllabus) {
            throw new Error("AI response was missing 'category' or 'syllabus'.");
        }
        console.log("Step 1: visualAssets received from API:", visualAssets);

        const syllabusSections = universalParseSyllabus(syllabus);

        if (syllabusSections.length === 0) {
             throw new Error("The AI didn't return a valid syllabus list. Please try a different topic.");
        }

        const newTopicId = `topic-${Date.now()}`;
        closeNewTopicModal();
        // Pass the new category to the startLearningTopic function
        startLearningTopic(topic, syllabusSections, newTopicId, category, sophistication, visualAssets);

    } catch (error) {
        console.error("Error fetching syllabus:", error);
        alert(`An error occurred: ${error.message}`);
    } finally {
        showModalLoading(false);
    }
}

let conversationHistory = [
            {
                role: "system",
                content: `You are an educational assistant. 
                In your response do not add any conversational fluff or introductory sentences.`
            }
        ];
        // Parse response with markdown support
        // Parse response with markdown support and definitions
// Parse response which is now a full JSON object
// This function now receives the answer text and definitions array directly
// Replace the entire parseResponse function

/**
 * Parses the final content, converting markdown and handling paragraph/line breaks.
 * This is the final step in the rendering pipeline.
 * @param {string} mainContentText The explanation text from the AI.
 * @param {Array} definitionsArray The array of definitions from the AI.
 * @returns {object} A content object ready for rendering.
 */
 /**
 * Parses the final content, converting markdown and handling paragraph/line breaks.
 * @param {string} mainContentText The explanation text from the AI.
 * @param {Array} definitionsArray The array of definitions from the AI.
 * @returns {object} A content object ready for rendering.
 */
/**
 * Parses the final content, adding a final cleanup step for inconsistent LaTeX.
 * @param {string} mainContentText The explanation text from the AI.
 * @param {Array} definitionsArray The array of definitions from the AI.
 * @returns {object} A content object ready for rendering.
 */
 /**
 * A robust, streamlined function to parse AI content, focusing on
 * correct paragraph and markdown handling to prevent formatting errors.
 * @param {string} mainContentText The explanation text from the AI.
 * @param {Array} definitionsArray The array of definitions from the AI.
 * @returns {object} A content object ready for rendering.
 */
/**
 * A robust, streamlined function to parse AI content, now with
 * math-aware line break conversion.
 * @param {string} mainContentText The explanation text from the AI.
 * @param {Array} definitionsArray The array of definitions from the AI.
 * @returns {object} A content object ready for rendering.
 */
 function parseResponse(mainContentText, definitionsArray) {
    const rawText = mainContentText || "";
    console.log("DEBUG: Raw text received by parser:", rawText);

    // Step 1: Normalize the input string.
    const normalizedText = rawText.replace(/\\n/g, '\n').replace(/\\"/g, '"');

    // Step 2: Convert basic markdown to HTML.
    let html = normalizedText
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*(.*?)\*/g, '<em>$1</em>');

    // --- START: UPDATED PARAGRAPH LOGIC ---
    // Step 3: Handle paragraphs with math-aware line breaks.
    const paragraphs = html
        .split(/(\n\s*){2,}/g) // Split by 2+ newlines to form paragraphs.
        .filter(p => p && p.trim() !== '') // Filter out empty strings from the split.
        .map(p => {
            const trimmedParagraph = p.trim();

            // We now split EACH paragraph into math and text segments.
            const splitRegex = /(\$\$[\s\S]*?\$\$|\$[\s\S]*?\$|\\\[[\s\S]*?\\\]|\\\(.*?\\\))/g;
            const segments = trimmedParagraph.split(splitRegex);

            // Process the segments to only add <br> tags to the text parts.
            const processedSegments = segments.map((segment, index) => {
                // If it's a math segment (odd index) or empty, leave it completely alone.
                if (!segment || index % 2 !== 0) {
                    return segment;
                }
                // This is a text segment. We can safely replace any newlines with <br> tags here.
                return segment.replace(/\n/g, '<br>');
            });

            // Re-join the segments and wrap the whole thing in a <p> tag.
            const finalParagraphHtml = processedSegments.join('');
            return `<p>${finalParagraphHtml}</p>`;
        });
    // --- END: UPDATED PARAGRAPH LOGIC ---

    html = paragraphs.join('');

    // Step 4: Final safety net for backslashes.
    html = html.replace(/\\\\/g, '\\');

    console.log("DEBUG: Final processed HTML for rendering:", html);

    const result = {
        overview: html,
        definitions: definitionsArray || []
    };
    return result;
}
// Create a new helper function to wrap terms in special HTML
// In your <script> tag...

    /**
 * A "math-aware" function that applies term highlighting only to text
 * that is NOT inside LaTeX delimiters.
 * @param {string} text - The full HTML string to process.
 * @param {Array} definitions - The array of term/definition objects.
 * @returns {string} The processed HTML with terms highlighted.
 */
function applyTermHighlighting(text, definitions) {
    // If there's nothing to highlight, return the text immediately.
    if (!definitions || definitions.length === 0 || !text) {
        return text;
    }

    // This regex splits the text by all common LaTeX delimiters,
    // crucially keeping the delimiters themselves in the resulting array.
    const splitRegex = /(\$\$[\s\S]*?\$\$|\$[\s\S]*?\$|\\\[[\s\S]*?\\\]|\\\(.*?\\\))/g;
    const segments = text.split(splitRegex);

    // Sort definitions by length to avoid partial matches (e.g., "equity" in "private equity").
    const sortedDefinitions = definitions.sort((a, b) => b.term.length - a.term.length);

    // Iterate through the segments. Even-indexed segments are regular text; odd-indexed are math.
    const processedSegments = segments.map((segment, index) => {
        // If the segment is a math block (odd index) or empty, return it unchanged.
        if (!segment || index % 2 !== 0) {
            return segment;
        }

        // This is a regular text segment, so we can safely perform replacements.
        let processedText = segment;
        sortedDefinitions.forEach(def => {
            try {
                // This regex finds the term as a whole word, but not inside an HTML tag.
                const termRegex = new RegExp(`\\b${def.term}\\b(?![^<]*?>)`, 'gi');
                const sanitizedDefinition = def.definition.replace(/"/g, '&quot;');
                const replacement = `<span class="technical-term">${def.term}<span class="term-tooltip">${sanitizedDefinition}</span></span>`;
                processedText = processedText.replace(termRegex, replacement);
            } catch (e) {
                // Safety net for terms with special characters that might break the regex.
                console.error(`Could not create regex for term: "${def.term}"`, e);
            }
        });
        return processedText;
    });

    // Join the processed and untouched segments back into a single, final HTML string.
    return processedSegments.join('');
}
        // Create tree node
        // REPLACE the existing createTreeNode function
function createTreeNode(title, content, parent, isUserQuestion = false) {
    const node = {
        id: generateUniqueId(), // Use the new robust ID generator
        title: title.length > 30 ? title.substring(0, 30) + '...' : title,
        fullTitle: title,
        content: content,
        parent: parent,
        children: [],
        isUserQuestion: isUserQuestion,
        sectionIndex: null,
        isRead: false
    };

    if (parent) {
        parent.children.push(node);
        updateSectionIndices(parent);
    }

    return node;
}

        // Update section indices for children
        function updateSectionIndices(parent) {
            let sectionCount = 0;
            parent.children.forEach(child => {
                if (!child.isUserQuestion) {
                    sectionCount++;
                    child.sectionIndex = sectionCount;
                }
            });
        }

        // Update tree visualization
        function updateTreeVisualization() {
            const container = document.getElementById('treeContainer');
            container.innerHTML = renderTreeNode(treeStructure);
            
            // Auto-scroll to show the active node
            setTimeout(() => {
                const activeNode = container.querySelector('.tree-node-content.active');
                if (activeNode) {
                    activeNode.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'end' });
                }
            }, 100);
        }

        // Render tree node
        // Find and replace this entire function
// Find and replace this entire function
function renderTreeNode(node, level = 0) {
    // --- NEW LOGIC for ICON ---
    let icon = '';
    if (node.isTimelineElaboration) {
        icon = '';
    } else if (node.id === 'root') {
        icon = '';
    } else if (node.isUserQuestion) {
        icon = '';
    } else if (node.sectionIndex) {
        icon = `${node.sectionIndex}.`;
    }
    // --- END ICON LOGIC ---
    
    const statusIndicatorHTML = node.id !== 'root' ? 
        `<div class="tree-status-indicator ${node.isRead ? 'read' : ''}"></div>` : 
        '';

    let html = `
        <div class="tree-node" style="margin-left: ${level * 25}px;">
            <div class="tree-node-content ${node === currentTreeNode ? 'active' : ''}" 
     data-node-id="${node.id}"
     title="${toTitleCase(node.fullTitle || node.title)}">
                
                ${statusIndicatorHTML}

                <span class="tree-node-icon">${icon}</span>
                <span class="tree-node-text">${toTitleCase(node.title)}</span>
            </div>
    `;
    
    if (node.children.length > 0) {
        html += '<div class="tree-children">';
        
        // --- NEW SORTING LOGIC ---
        // Sort children to put timeline elaborations first
        const sortedChildren = [...node.children].sort((a, b) => {
            if (a.isTimelineElaboration && !b.isTimelineElaboration) return -1;
            if (!a.isTimelineElaboration && b.isTimelineElaboration) return 1;
            return (a.sectionIndex || Infinity) - (b.sectionIndex || Infinity);
        });
        // --- END SORTING LOGIC ---

        sortedChildren.forEach(child => {
            html += renderTreeNode(child, level + 1);
        });
        html += '</div>';
    }
    
    html += '</div>';
    return html;
}
        // Navigate to tree node
        // =================== START: REPLACE THIS FUNCTION ===================
/**
 * Navigates to a specific node, fetching its content with retries if it doesn't exist.
 * This is the new, robust navigation handler.
 * @param {string} nodeId - The ID of the node to navigate to.
 */
async function navigateToNode(nodeId) {
    const node = findNodeById(treeStructure, nodeId);
    if (!node) {
        console.error("Navigation failed: Node not found with ID:", nodeId);
        return;
    }
    node.isRead = true;
    updateParentReadStatus(node.parent);

    // If the node is a leaf and has no content, fetch it with retries.
    if (node.children.length === 0 && !node.content && node.id !== 'root') {
        showSkeletonLoader();
        const maxRetries = 3;
        let success = false;
        
        for (let i = 0; i < maxRetries; i++) {
            success = await elaborateOnTopic(node, false);
            if (success) break; // Exit loop on success
            if (i < maxRetries - 1) {
                console.log(`Fetch failed for "${node.fullTitle}", retrying...`);
                await new Promise(res => setTimeout(res, 500)); // Wait 0.5s before retrying
            }
        }

        if (!success) {
            document.getElementById('mainContent').innerHTML = ''; // Clear skeleton loader
            showError(`Failed to load "${node.fullTitle}" after several attempts.`);
        }
    }

    // This block now runs for ALL navigations, ensuring the UI state is always consistent.
    currentTreeNode = node;
    treeStructure.lastVisitedNodeId = node.id;

    navigationHistory = navigationHistory.slice(0, currentHistoryIndex + 1);
    navigationHistory.push({
        node: node,
        content: node.content ? JSON.parse(JSON.stringify(node.content)) : null,
        context: { topic: node.fullTitle || node.title, subtopic: null, fullContent: node.content }
    });
    currentHistoryIndex = navigationHistory.length - 1;

    updateNavigation();
    displayContent(node); // Display content (or lack thereof)
    updateTreeVisualization(); // Update the tree to show the active node
    saveTopicsToFirestore();
}
// ==================== END: REPLACE THIS FUNCTION ====================


        // Find node by ID
        function findNodeById(node, id) {
            if (node.id === id) return node;
            for (let child of node.children) {
                const found = findNodeById(child, id);
                if (found) return found;
            }
            return null;
        }

        // Update navigation buttons and breadcrumb
        function updateNavigation() {
            const backButton = document.getElementById('backButton');
            const forwardButton = document.getElementById('forwardButton');
            
            backButton.disabled = currentHistoryIndex <= 0;
            forwardButton.disabled = currentHistoryIndex >= navigationHistory.length - 1;
            
            updateBreadcrumb();
        }
// ADD THIS NEW FUNCTION
function generateUniqueId() {
    return `node-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
}
        // Update breadcrumb
        // Find and replace this entire function
function updateBreadcrumb() {
    const breadcrumb = document.getElementById('breadcrumb');
    breadcrumb.innerHTML = '';
    
    let path = [];
    let node = currentTreeNode;
    while (node) {
        path.unshift(node);
        node = node.parent;
    }
    
    path.forEach((node, index) => {
        const crumb = document.createElement('span');
        crumb.className = 'breadcrumb-item';
        if (node === currentTreeNode) {
            crumb.classList.add('active');
        }
        crumb.textContent = toTitleCase(node.title); // Applied here

        breadcrumb.appendChild(crumb);
        
        if (index < path.length - 1) {
            const separator = document.createElement('span');
            separator.className = 'breadcrumb-separator';
            separator.textContent = '';
            breadcrumb.appendChild(separator);
        }
    });
}

        // Navigate back
        function navigateBack() {
            if (currentHistoryIndex > 0) {
                currentHistoryIndex--;
                const historyItem = navigationHistory[currentHistoryIndex];
                currentTreeNode = historyItem.node;
                currentContext = historyItem.context;
                displayContent(historyItem.node, historyItem.content);
                updateNavigation();
                updateTreeVisualization();
            }
        }

        // Navigate forward
        function navigateForward() {
            if (currentHistoryIndex < navigationHistory.length - 1) {
                currentHistoryIndex++;
                const historyItem = navigationHistory[currentHistoryIndex];
                currentTreeNode = historyItem.node;
                currentContext = historyItem.context;
                displayContent(historyItem.node, historyItem.content);
                updateNavigation();
                updateTreeVisualization();
            }
        }

        // Display content
        function displayContent(node, preservedContent = null) {
            const mainContent = document.getElementById('mainContent');
            
            if (node.id === 'root' && !node.content) {
                mainContent.innerHTML = `
                    <div class="welcome-message">
                        <h1>What do you want to learn?</h1>
                        <p>Explore topics through an interactive learning journey</p>
                        <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap; margin-top: 40px;">
                            <button class="card" style="padding: 15px 25px; cursor: pointer;" onclick="askQuestion('How does the central bank work?')">
                                <span style="font-size: 16px;"> Central Banking</span>
                            </button>
                            <button class="card" style="padding: 15px 25px; cursor: pointer;" onclick="askQuestion('What are securities and their types?')">
                                <span style="font-size: 16px;"> Securities</span>
                            </button>
                            <button class="card" style="padding: 15px 25px; cursor: pointer;" onclick="askQuestion('Explain bonds and how they work')">
                                <span style="font-size: 16px;"> Bonds</span>
                            </button>
                        </div>
                    </div>
                `;
                updatePlaceholder(false);
            } else if (node.content || preservedContent) {
                renderContent(preservedContent || node.content, node.fullTitle || node.title);
                updatePlaceholder(true);
            }else {
        // This is the NEW path for a node whose content failed to load.
        // Instead of a silent failure, we show a clear message.
        mainContent.innerHTML = `
            <div class="topic-overview">
                <h2>${toTitleCase(node.fullTitle || node.title)}</h2>
                <p style="color: #dc2626; font-weight: 500;">
                    We were unable to load the content for this section after multiple attempts. 
                    Please try another section or navigate back and click the card again.
                </p>
            </div>
        `;
        updatePlaceholder(false);
    }
        }

        // Render content
       // Render content
       function renderContent(parsedContent, userQuestion = null) {
            console.log("Step 3: Content received by renderContent:", parsedContent);
            const mainContent = document.getElementById('mainContent');
            mainContent.innerHTML = '';

            try {
                // Render the main text explanation (overview)
                if (parsedContent.overview) {
                    const overviewDiv = document.createElement('div');
                    overviewDiv.className = 'topic-overview';
                    
                    let formattedOverview = parsedContent.overview;
                    const highlightedOverview = applyTermHighlighting(formattedOverview, parsedContent.definitions);
                    overviewDiv.innerHTML = `<h2>${toTitleCase(currentTreeNode.fullTitle || currentTreeNode.title)}</h2><div>${highlightedOverview}</div>`;
                    mainContent.appendChild(overviewDiv);
                }

                // --- NEW: VISUAL ASSET DISPATCHER ---
                if (parsedContent.visualAssets && parsedContent.visualAssets.length > 0) {
                    parsedContent.visualAssets.forEach(asset => {
                        // Check if this asset is our new row structure
                        if (asset.type === 'layout_row' && asset.columns) {
                            const rowContainer = document.createElement('div');
                            rowContainer.className = 'visual-asset-row';

                            asset.columns.forEach(columnAsset => {
                                const columnContainer = document.createElement('div');
                                columnContainer.className = 'visual-asset-column';
                                
                                const assetType = columnAsset.type.trim();
                                if (assetType === 'implicit_plotter') {
                                    const labWrapper = document.createElement('div');
                                    labWrapper.className = 'lab-container';
                                    labWrapper.style.margin = '0'; 
                                    labWrapper.style.width = '100%'; 
                                    renderImplicitPlotter(labWrapper, columnAsset.data);
                                    columnContainer.appendChild(labWrapper);

                                } else if (assetType === 'bar_chart' || assetType === 'pie_chart') {
                                    const chartWrapper = document.createElement('div');
                                    chartWrapper.className = 'chart-container'; 
                                    const chartId = 'asset-' + Date.now() + Math.random().toString(36).substring(2, 9);
                                    chartWrapper.innerHTML = `<canvas id="${chartId}"></canvas>`;
                                    
                                    if (assetType === 'bar_chart') {
                                        chartWrapper.classList.add('bar-chart-container');
                                        renderBarChart(chartId, columnAsset.data);
                                    } else {
                                        chartWrapper.classList.add('pie-chart-container');
                                        renderPieChart(chartId, null, columnAsset.data);
                                    }
                                    columnContainer.appendChild(chartWrapper);
                                }
                                rowContainer.appendChild(columnContainer);
                            });
                            mainContent.appendChild(rowContainer);

                        } else {
                            // --- Fallback for old/non-row assets (like timelines) ---
                            const assetContainer = document.createElement('div');
                            assetContainer.className = 'lab-container';
                            assetContainer.style.marginTop = '40px';
                            
                            const assetType = asset.type.trim();
                            if (assetType.includes('hybrid_timeline')) {
                                renderHybridTimeline(assetContainer, asset.data);
                            }
                            mainContent.appendChild(assetContainer);
                        }
                    });
                }
                
                // Render the sub-topic cards
                if (parsedContent.sections && parsedContent.sections.length > 0) {
                    const cardsGrid = document.createElement('div');
                    cardsGrid.className = 'cards-grid';
                    const parentNodeId = currentTreeNode.id;

                    parsedContent.sections.forEach((section, index) => {
                        if (!section.isExpanded) {
                            const childNode = currentTreeNode.children.find(child => child.fullTitle === section.title || child.title === section.title);
                            const isNodeRead = childNode ? childNode.isRead : false;
                            const childNodeId = childNode ? childNode.id : null;
                            const card = createCard(section, index, isNodeRead, childNodeId, parentNodeId);
                            cardsGrid.appendChild(card);
                        }
                    });
                    mainContent.appendChild(cardsGrid);
                }

                // Render action buttons if applicable
// Render action buttons if applicable
if (parsedContent.showTellMeMore) {
    // Create a wrapper to hold the buttons and space them out
    const buttonWrapper = document.createElement('div');
    buttonWrapper.style.display = 'flex';
    buttonWrapper.style.gap = '15px'; // Adjust spacing between buttons here
    buttonWrapper.style.marginTop = '20px';

    // 1. Create the "Tell me more" button with its NEW functionality
    const tellMeMoreBtn = document.createElement('button');
    tellMeMoreBtn.className = 'tell-me-more-button';
    tellMeMoreBtn.innerHTML = `Tell me more about this <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14m0 0l-7-7m7 7l7-7"/></svg>`;
    tellMeMoreBtn.onclick = () => elaborateInPlace(); // <-- UPDATED

    // 2. Create the "Go deeper on this" button with its ORIGINAL functionality
    const goDeeperBtn = document.createElement('button');
    goDeeperBtn.className = 'tell-me-more-button'; // Use the same style
    goDeeperBtn.innerHTML = `Go deeper on this <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="2" width="6" height="6" rx="1"></rect><path d="M12 8v4"></path><path d="M4 12h16"></path><rect x="2" y="16" width="4" height="4" rx="1"></rect><rect x="10" y="16" width="4" height="4" rx="1"></rect><rect x="18" y="16" width="4" height="4" rx="1"></rect><path d="M4 12v4"></path><path d="M12 12v4"></path><path d="M20 12v4"></path></svg>`;
    goDeeperBtn.onclick = () => elaborateOnCurrent(); // <-- REMAINS THE SAME

    // Add both buttons to the wrapper
    buttonWrapper.appendChild(tellMeMoreBtn);
    buttonWrapper.appendChild(goDeeperBtn);
// --- Add the following code for the new button ---
const differenceBtn = document.createElement('button');
    differenceBtn.className = 'difference-button';
    differenceBtn.textContent = "What's the difference between tell me more and go deeper?";
    differenceBtn.onclick = openDifferenceModal; // This will open the new modal

    buttonWrapper.appendChild(differenceBtn);
    // --- End of new code ---
    // Add the wrapper to the main content area
    mainContent.appendChild(buttonWrapper);
}
            } finally {
                // This will now run even if an error occurs while rendering a chart or timeline.
                triggerMathRendering(mainContent);
            }
        }


        // Create card element
        // Update the function signature to accept isRead
        // Create card element
        // Update the function signature to accept isRead and childNodeId
        // Create card element
        // Update the function signature to accept isRead and childNodeId
        function createCard(section, index, isRead, childNodeId, parentNodeId) { 
            const card = document.createElement('div');
            card.className = 'card';
            
            const displayContent = section.content ? 
                (section.content.length > 80 ? section.content.substring(0, 80) + '...' : section.content) : '';
            
            card.innerHTML = `
                <div class="status-indicator ${isRead ? 'read' : ''}"></div>

                <h3>
                    ${section.title}
                </h3>
                ${displayContent ? `<p>${displayContent}</p>` : ''}
            `;
            
            // This now calls a new, more reliable function using the unique node ID
            if (childNodeId) {
                card.onclick = () => expandCardById(parentNodeId, childNodeId);
            }
            return card;
        }

        // Expand card
       // Replace the entire expandCard function
 // REPLACE the entire function
// Expand card by its unique ID, replacing the old title-based lookup
// Expand card
       // Replace the entire expandCard function
 // REPLACE the entire function
// Expand card by its unique ID, replacing the old title-based lookup
// Expand card by its unique ID, replacing the old title-based lookup
async function expandCardById(parentNodeId, nodeId) {
            // Find the parent node first to ensure we are in the correct context
            const parentNode = findNodeById(treeStructure, parentNodeId);
            if (!parentNode) {
                console.error("Could not find the parent node for the clicked card:", parentNodeId);
                showError("An error occurred: Cannot find the card's context.");
                return;
            }

            // Now, find the child node directly within that parent's children
            const childNodeToLoad = parentNode.children.find(child => child.id === nodeId);

            if (childNodeToLoad) {
                // Set the context based on the reliably found node
                currentContext.subtopic = childNodeToLoad.fullTitle;

                // This logic remains the same: check if content exists or fetch it
                if (childNodeToLoad.content) {
                    console.log("Content already exists. Navigating directly.");
                    navigateToNode(childNodeToLoad.id);
                } else {
                    console.log("Content does not exist. Fetching from API.");
                    await elaborateOnTopic(childNodeToLoad, false);
                }
            } else {
                console.error("Could not find the tree node corresponding to the clicked card ID:", nodeId, "within parent:", parentNodeId);
                showError("An error occurred trying to load this section.");
            }
        }

        // Update placeholder text
        function updatePlaceholder(hasQuestion) {
            const chatInput = document.getElementById('chatInput');
            chatInput.placeholder = hasQuestion ? "Any further questions?" : "Ask about finance or economics...";
        }

        // Elaborate on current context
        // This is the new, corrected function
async function elaborateOnCurrent() {
    // Get the full title of the current node we are viewing
    const currentTitle = currentTreeNode.fullTitle || currentTreeNode.title;

    if (currentTitle) {
        const question = `More about ${currentTitle}`;
        
        // Use the existing askQuestion function, which correctly creates a child node
        await askQuestion(question);
    }
}

        // Ask for elaboration
        // Elaborate on a specific topic, creating new sub-nodes in the tree
        // REPIACE the entire function
        /**
 * Fetches content for a target node, assembling different prompts based on whether
 * it's a new user question or a standard content request.
 * @param {object} targetNode - The node to get content for.
 * @param {boolean} [generateNewCards=false] - If true, treat it as a new question and generate sub-topic cards.
 * @returns {Promise<boolean>} - True on success, false on failure.
 */
 async function elaborateOnTopic(targetNode, generateNewCards = false) {
    showSkeletonLoader();
    const rootNode = treeStructure;
    let elaborationPrompt = '';

    if (generateNewCards) {
        // This part for handling new questions remains the same.
        const parentOfQuestion = targetNode.parent;
        elaborationPrompt = getNewSubtopicsPrompt({
            topicTitle: rootNode.fullTitle,
            sophistication: rootNode.sophistication || 'Detailed',
            journeyStructure: buildTreeStructureString(rootNode, parentOfQuestion.id),
            lineageContent: getLineageContent(parentOfQuestion),
            userQuestion: targetNode.fullTitle,
            currentNodeTitle: parentOfQuestion.fullTitle
        });

    } else {
        // --- THIS IS THE UPDATED BLOCK ---
        // This path is for expanding a standard topic card.
        const topicCategory = rootNode.category;
        const isStemTopic = topicCategory === 'Science' || topicCategory === 'Mathematics';
        
        // This is the object containing all the context details.
        const promptParams = {
            topicTitle: rootNode.fullTitle,
            sophistication: rootNode.sophistication || 'Detailed',
            currentNodeTitle: targetNode.fullTitle,
            journeyStructure: buildTreeStructureString(rootNode, targetNode.id),
            lineageContent: getLineageContent(targetNode)
        };

        if (isStemTopic) {
            elaborationPrompt = getStemElaborationPrompt(promptParams);
        } else {
            // Add the simple context prompt for non-STEM topics
            promptParams.contextPrompt = (targetNode.parent && targetNode.parent.id !== 'root')
                ? `In the context of "${targetNode.parent.fullTitle}", `
                : '';
            elaborationPrompt = getStandardElaborationPrompt(promptParams);
        }
    }

    showLoading(true);

    // The rest of the function (API call, response handling) remains the same.
    try {
        conversationHistory.push({ role: "user", content: elaborationPrompt });
        pruneConversationHistory();

        const response = await fetch(BACKEND_URL + '/chat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ messages: conversationHistory })
        });

        if (!response.ok) throw new Error('Failed to get response');

        const data = await response.json();
        const botResponse = data.choices[0].message.content;
        conversationHistory.push({ role: "assistant", content: botResponse });

        let parsed;
        if (generateNewCards) {
            parsed = { overview: `Here are some deeper areas to explore.`, sections: universalParseSyllabus(botResponse), definitions: [] };
            targetNode.children = [];
            parsed.sections.forEach(section => {
                createTreeNode(section.title, null, targetNode, false);
            });
            targetNode.children.forEach(childNode => {
                prefetchNodeContent(childNode);
            });
        } else {
            try {
                const structuredResponse = sanitizeAndParseJson(botResponse);
                const explanation = structuredResponse.explanation || "No explanation provided.";
                const definitions = structuredResponse.definitions || [];
                const visualAssets = structuredResponse.visualAssets || [];
                parsed = parseResponse(explanation, definitions);
                parsed.visualAssets = visualAssets;
                parsed.showTellMeMore = true;
            } catch (e) {
                console.error("Failed to parse structured response from AI:", e);
                parsed = parseResponse(botResponse, []);
            }
        }

        targetNode.content = parsed;
        navigateToNode(targetNode.id);
        await saveTopicsToFirestore();
        return true;

    } catch (error) {
        console.error("Error in elaborateOnTopic:", error);
        showError('Failed to get more information. Please try again.');
        return false;
    } finally {
        showLoading(false);
    }
}

        // Send message
        async function sendMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            
            if (!message) return;
            
            await askQuestion(message);
            input.value = '';
        }

        // Ask question
        async function askQuestion(question) {
    showLoading(true);
    const rootNode = treeStructure;
    const currentNode = currentTreeNode;

    // Case A vs Case B: Does the current node have cards?
    const currentNodeHasCards = currentNode.content && currentNode.content.sections && currentNode.content.sections.length > 0;

    try {
        const dispatcherPrompt = getQuestionDispatcherPrompt({
            topicTitle: rootNode.fullTitle,
            sophistication: rootNode.sophistication,
            journeyStructure: buildTreeStructureString(rootNode, currentNode.id),
            lineageContent: getLineageContent(currentNode),
            userQuestion: question,
            currentNodeTitle: currentNode.fullTitle,
            currentNodeHasCards: currentNodeHasCards
        });

        // This conversation is temporary for the dispatcher and won't be saved to the main history.
        const dispatcherConversation = [
            { role: "system", content: "You are an educational assistant." },
            { role: "user", content: dispatcherPrompt }
        ];

        const response = await fetch(BACKEND_URL + '/chat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ messages: dispatcherConversation })
        });

        if (!response.ok) throw new Error('Dispatcher API request failed');

        const result = await response.json();
        const botResponseText = result.choices[0].message.content;
        const dispatcherResponse = sanitizeAndParseJson(botResponseText);

        const { responseType, location, content } = dispatcherResponse;

        // --- Handle the AI's decision ---

        if (responseType === 'subtopics') {
            // Case 2: Create a new node with sub-topic cards.
            const newNode = createTreeNode(question, null, currentNode, true);
            const syllabusSections = universalParseSyllabus(content.syllabus);
            newNode.content = {
                 overview: `Here are some deeper areas to explore regarding your question about "${question}".`,
                 sections: syllabusSections,
                 definitions: []
            };
            syllabusSections.forEach(section => createTreeNode(section.title, null, newNode, false));
            newNode.children.forEach(childNode => prefetchNodeContent(childNode));
            navigateToNode(newNode.id);

        } else if (responseType === 'explanation') {
            const parsedContent = parseResponse(content.explanation, content.definitions);
            parsedContent.visualAssets = content.visualAssets || [];
            parsedContent.showTellMeMore = true;

            if (location === 'inline' && !currentNodeHasCards) {
                // Case 1.1: Append to the current node's content.
                const separator = `<hr style="border: none; border-top: 1px solid #e5e7eb; margin: 25px 0;">`;
                const titleHeader = `<h3>Your Question: ${toTitleCase(question)}</h3>`;
                                const highlightedNewText = applyTermHighlighting(parsedContent.overview, parsedContent.definitions);
                
                currentNode.content.overview += separator + titleHeader + highlightedNewText;
                
                // Also merge definitions and assets
                if (content.definitions.length > 0) {
                    currentNode.content.definitions.push(...content.definitions);
                }
                if (content.visualAssets && content.visualAssets.length > 0) {
                     if (!currentNode.content.visualAssets) currentNode.content.visualAssets = [];
                     currentNode.content.visualAssets.push(...content.visualAssets);
                }

                displayContent(currentNode); // Re-render the current node

            } else {
                // Case 1 (from Case A) or Case 1.2 (from Case B): Create a new node for the explanation.
                const newNode = createTreeNode(question, parsedContent, currentNode, true);
                navigateToNode(newNode.id);
            }
        }
        
        await saveTopicsToFirestore();
        document.getElementById('chatInput').value = ''; // Clear input

    } catch (error) {
        console.error("Error in askQuestion:", error);
        showError(error.message || 'Failed to get response. Please check your connection.');
    } finally {
        showLoading(false);
    }
}

        // Show loading state
        function showLoading(isLoading) {
            const sendButton = document.getElementById('sendButton');
            const buttonText = document.getElementById('buttonText');
            const input = document.getElementById('chatInput');
            
            if (isLoading) {
                sendButton.disabled = true;
                input.disabled = true;
                buttonText.textContent = 'Loading';
                if (!sendButton.querySelector('.loading-spinner')) {
                    const spinner = document.createElement('span');
                    spinner.className = 'loading-spinner';
                    sendButton.insertBefore(spinner, buttonText);
                }
            } else {
                sendButton.disabled = false;
                input.disabled = false;
                buttonText.textContent = 'Send';
                const spinner = sendButton.querySelector('.loading-spinner');
                if (spinner) spinner.remove();
            }
        }

        // Show error
        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            setTimeout(() => {
                errorDiv.style.display = 'none';
            }, 5000);
        }

        // Event listeners
        document.getElementById('chatInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });

        // Check backend connection
        // Check backend connection
// Check backend connection
async function checkConnection() {
            try {
                // This message is now created here and NOT added to the main conversation history.
                const testMessage = [{
                    role: "system",
                    content: "You are a health check assistant. If you receive the message 'test', respond with 'ok'."
                }, {
                    role: "user",
                    content: "test"
                }];

                const response = await fetch(BACKEND_URL + '/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        messages: testMessage
                    })
                });

                if (!response.ok) {
                    showError('Backend not connected. Please start your server.');
                }
            } catch (error) {
                showError('Backend not connected. Please start your server at ' + BACKEND_URL);
            }
        }

        // Initialize
        checkConnection();
        updateTreeVisualization();
        
        // Add initial navigation entry
        navigationHistory.push({
            node: treeStructure,
            content: null,
            context: {
                topic: 'Home',
                subtopic: null,
                fullContent: null
            }
        });
    
        currentHistoryIndex = 0;

        // New function to keep the conversation history from getting too long
        function pruneConversationHistory() {
            const maxHistoryLength = 5; // Keeps the system prompt + the last 2 Q&A pairs
            if (conversationHistory.length > maxHistoryLength) {
                // It keeps the first item (system prompt) and takes the last few items
                const keptHistory = conversationHistory.slice(-maxHistoryLength + 1);
                conversationHistory = [conversationHistory[0], ...keptHistory];
            }
        }
        // --- RESIZABLE SIDEBAR LOGIC ---

        // Wait until the document is fully loaded to run this script
        document.addEventListener('DOMContentLoaded', function () {
            // --- COLOR PALETTE FOR MULTI-LINE PLOTS ---

// --- JavaScript for the 'What's the difference' modal ---

// Get the modal and the close button
const differenceModal = document.getElementById('differenceModal');
const closeDifferenceModalBtn = document.getElementById('closeDifferenceModal');

// Function to open the modal
window.openDifferenceModal = function() {
    differenceModal.classList.add('active');
}

// Function to close the modal
function closeDifferenceModal() {
    differenceModal.classList.remove('active');
}

// Event listener for the close button
closeDifferenceModalBtn.addEventListener('click', closeDifferenceModal);

// Event listener to close the modal if the user clicks the overlay
differenceModal.addEventListener('click', (event) => {
    if (event.target === differenceModal) {
        closeDifferenceModal();
    }
});

            function renderPeriodTimeline() {
                const timelineWrapper = document.getElementById('period-timeline-wrapper');
                const timelineLine = timelineWrapper.querySelector('.timeline-line');
                timelineWrapper.innerHTML = '';
                timelineWrapper.appendChild(timelineLine);

                const dynastyData = [ { name: 'Xia', startStr: 'c. 2070 BC', endStr: 'c. 1600 BC' }, { name: 'Shang', startStr: 'c. 1600 BC', endStr: '1046 BC' }, { name: 'Zhou', startStr: '1046 BC', endStr: '256 BC' }, { name: 'Qin', startStr: '221 BC', endStr: '206 BC' }, { name: 'Han', startStr: '206 BC', endStr: '220 AD' }, { name: 'Three Kingdoms', startStr: '220 AD', endStr: '280 AD' }, { name: 'Jin', startStr: '266 AD', endStr: '420 AD' }, { name: 'Sui', startStr: '581 AD', endStr: '618 AD' }, { name: 'Tang', startStr: '618 AD', endStr: '907 AD' }, { name: 'Song', startStr: '960 AD', endStr: '1279 AD' }, { name: 'Yuan', startStr: '1271 AD', endStr: '1368 AD' }, { name: 'Ming', startStr: '1368 AD', endStr: '1644 AD' }, { name: 'Qing', startStr: '1644 AD', endStr: '1912 AD' }];
                
                const dynasties = dynastyData.map(d => ({
                    ...d,
                    startYear: parseDateToFractionalYear(d.startStr),
                    endYear: parseDateToFractionalYear(d.endStr),
                })).filter(d => d.startYear !== null && d.endYear !== null)
                   .map((d, i, arr) => ({
                    ...d,
                    duration: d.endYear - d.startYear,
                    gap: i > 0 ? d.startYear - arr[i-1].endYear : 0
                }));

                if (dynasties.length === 0) return;

                const compressionExponent = 0.5;
                const totalCompressedSpan = dynasties.reduce((sum, d) => {
                    return sum + Math.pow(Math.max(0, d.gap), compressionExponent) + Math.pow(Math.max(0, d.duration), compressionExponent);
                }, 0);

                const targetPixelWidth = 2000;
                const pixelsPerUnit = totalCompressedSpan > 0 ? targetPixelWidth / totalCompressedSpan : 0;
                const scaleValue = (value) => Math.pow(Math.max(0, value), compressionExponent) * pixelsPerUnit;

                let currentPos = 40;
                let lastTopEnd = -Infinity, lastBottomEnd = -Infinity;
                const verticalLevels = [25, 60, 95];
                let topLevel = 0, bottomLevel = 0;

                dynasties.forEach((dynasty) => {
                    const scaledGap = scaleValue(dynasty.gap);
                    const minCardWidth = 130;

                    const braceWidth = scaleValue(dynasty.duration);
                    const cardWidth = Math.max(braceWidth, minCardWidth);
                    
                    const braceStartPos = currentPos + scaledGap;
                    const cardStartPos = braceStartPos + (braceWidth - cardWidth) / 2;
                    
                    const endPos = braceStartPos + braceWidth;
                    const isTop = dynasties.indexOf(dynasty) % 2 === 0;

                    const eventElement = document.createElement('div');
                    eventElement.className = `timeline-event ${isTop ? 'top' : 'bottom'}`;
                    eventElement.innerHTML = `<div class="timeline-event-title">${dynasty.name}</div><div class="timeline-event-date">${dynasty.startStr} - ${dynasty.endStr}</div>`;
                    eventElement.style.left = `${cardStartPos}px`;
                    eventElement.style.width = `${cardWidth}px`;
                    
                    if (isTop) {
                        if (braceStartPos < lastTopEnd + 10) topLevel = (topLevel + 1) % verticalLevels.length;
                        eventElement.style.marginBottom = `${verticalLevels[topLevel]}px`;
                        lastTopEnd = endPos;
                    } else {
                        if (braceStartPos < lastBottomEnd + 10) bottomLevel = (bottomLevel + 1) % verticalLevels.length;
                        eventElement.style.marginTop = `${verticalLevels[bottomLevel]}px`;
                        lastBottomEnd = endPos;
                    }
                    timelineWrapper.appendChild(eventElement);

                    const brace = document.createElement('div');
                    brace.className = `period-brace ${isTop ? 'top' : 'bottom'}`;
                    brace.style.left = `${braceStartPos}px`;
                    brace.style.width = `${braceWidth}px`;
                    timelineWrapper.appendChild(brace);
                    
                    currentPos = endPos;
                });
                
                const totalWidth = currentPos + 40;
                timelineWrapper.style.width = `${totalWidth}px`;
                timelineLine.style.width = `${totalWidth}px`;
            }

            
            
            function renderEventTimeline() {
                const timelineWrapper = document.getElementById('event-timeline-wrapper');
                const timelineLine = timelineWrapper.querySelector('.timeline-line');
                timelineWrapper.innerHTML = ''; 
                timelineWrapper.appendChild(timelineLine);
                
                const inventionData = [ { name: 'The Wheel', dateStr: 'c. 3500 BC' }, { name: 'Written Language', dateStr: 'c. 3200 BC' }, { name: 'Iron Smelting', dateStr: 'c. 1200 BC' }, { name: 'Compass', dateStr: 'c. 200 BC' }, { name: 'Paper', dateStr: 'c. 105 AD' }, { name: 'Printing Press', dateStr: '1440 AD' }, { name: 'Telescope', dateStr: '1608 AD' }, { name: 'Steam Engine', dateStr: '1712 AD' }, { name: 'Telephone', dateStr: '1876 AD' }, { name: 'Light Bulb', dateStr: '1879 AD' }, { name: 'Computer', dateStr: '1943 AD' }, { name: 'Internet (ARPANET)', dateStr: '1969 AD' }];
                
                const inventions = inventionData.map(d => ({
                    ...d,
                    year: parseDateToFractionalYear(d.dateStr)
                })).filter(d => d.year !== null)
                   .map((d, i, arr) => ({
                    ...d,
                    gap: i > 0 ? d.year - arr[i-1].year : 0
                }));

                if (inventions.length < 2) return;
                
                const compressionExponent = 0.75;
                const totalCompressedSpan = inventions.reduce((sum, d) => {
                    return sum + Math.pow(Math.max(0, d.gap), compressionExponent);
                }, 0);
                
                const targetPixelWidth = 2000;
                const pixelsPerUnit = totalCompressedSpan > 0 ? targetPixelWidth / totalCompressedSpan : 0;
                const scaleValue = (value) => Math.pow(Math.max(0, value), compressionExponent) * pixelsPerUnit;
                
                let currentPos = 80;
                let lastTopEnd = -Infinity, lastBottomEnd = -Infinity;
                const verticalLevels = [25, 65, 105];
                let topLevel = 0, bottomLevel = 0;

                inventions.forEach((invention, index) => {
                    const scaledGap = scaleValue(invention.gap);
                    const eventPosition = currentPos + scaledGap;
                    const isTop = index % 2 === 0;
                    const cardWidth = 140;

                    const eventElement = document.createElement('div');
                    eventElement.className = `timeline-event event-style ${isTop ? 'top' : 'bottom'}`;
                    eventElement.innerHTML = `<div class="timeline-event-title">${invention.name}</div><div class="timeline-event-date">${invention.dateStr}</div>`;
                    eventElement.style.left = `${eventPosition}px`;
                    eventElement.style.transform = 'translateX(-50%)';

                    let currentLevel;
                    if (isTop) {
                        if (eventPosition - cardWidth / 2 < lastTopEnd + 10) topLevel = (topLevel + 1) % verticalLevels.length;
                        currentLevel = verticalLevels[topLevel];
                        eventElement.style.marginBottom = `${currentLevel}px`;
                        lastTopEnd = eventPosition + cardWidth / 2;
                    } else {
                        if (eventPosition - cardWidth / 2 < lastBottomEnd + 10) bottomLevel = (bottomLevel + 1) % verticalLevels.length;
                        currentLevel = verticalLevels[bottomLevel];
                        eventElement.style.marginTop = `${currentLevel}px`;
                        lastBottomEnd = eventPosition + cardWidth / 2;
                    }

                    eventElement.style.setProperty('--connector-height', `${currentLevel}px`);
                    timelineWrapper.appendChild(eventElement);
                    
                    currentPos = eventPosition;
                });
                
                const totalWidth = currentPos + 80;
                timelineWrapper.style.width = `${totalWidth}px`;
                timelineLine.style.width = `${totalWidth}px`;
            }

            let barChartInstance;
                function renderBarChart(canvasId, dataString) {
                    const ctx = document.getElementById(canvasId).getContext('2d');
                    
                    const lines = dataString.trim().split('\n');
                    const labels = [];
                    const data = [];
                    let maxValue = 0;
    
                    lines.forEach(line => {
                        const parts = line.split(':');
                        if (parts.length === 2) {
                            const label = parts[0].trim();
                            const value = parseFloat(parts[1].trim());
                            if (label && !isNaN(value)) {
                                labels.push(label);
                                data.push(value);
                                if (value > maxValue) {
                                    maxValue = value;
                                }
                            }
                        }
                    });
                    
                    const suggestedMax = maxValue * 1.1;
    
                    if (barChartInstance) { barChartInstance.destroy(); }
    
                    barChartInstance = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: labels,
                            datasets: [{
                                label: 'Value',
                                data: data,
                                backgroundColor: 'rgba(93, 109, 126, 0.6)',
                                borderColor: 'rgba(93, 109, 126, 1)',
                                borderWidth: 1,
                                borderRadius: 4
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false },
                                tooltip: { callbacks: { label: (context) => ` ${context.raw}` } }
                            },
                            scales: {
                                y: { beginAtZero: true, suggestedMax: suggestedMax, grid: { color: '#e5e7eb' } },
                                x: { grid: { display: false } }
                            }
                        }
                    });
                }

                let pieChartInstance;
                function renderPieChart(canvasId, legendId, dataString) {
                    const legendContainer = document.getElementById(legendId);
                    const ctx = document.getElementById(canvasId).getContext('2d');
                    
                    const lines = dataString.trim().split('\n');
                    const labels = [];
                    let data = [];
                    
                    lines.forEach(line => {
                        const parts = line.split(':');
                        if (parts.length === 2) {
                            const label = parts[0].trim();
                            const value = parseFloat(parts[1].trim());
                            if (label && !isNaN(value)) {
                                labels.push(label);
                                data.push(value);
                            }
                        }
                    });
    
                    const total = data.reduce((sum, val) => sum + val, 0);
                    if (total > 0) { data = data.map(val => (val / total) * 100); }
                    
                    const backgroundColors = [ '#34495e', '#191970', '#3b82f6', '#14b8a6', '#f59e0b', '#ef4444', '#ec4899'];
    
                    if (pieChartInstance) { pieChartInstance.destroy(); }
    
                    pieChartInstance = new Chart(ctx, {
                        type: 'pie',
                        data: {
                            labels: labels,
                            datasets: [{ data: data, backgroundColor: backgroundColors, borderColor: '#ffffff', borderWidth: 2 }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false },
                                tooltip: { callbacks: { label: (context) => ` ${context.label}: ${context.raw.toFixed(1)}%` } }
                            }
                        }
                    });
    
                    legendContainer.innerHTML = '';
                    labels.forEach((label, index) => {
                        const item = document.createElement('div');
                        item.className = 'legend-item';
                        const colorBox = document.createElement('div');
                        colorBox.className = 'legend-color-box';
                        colorBox.style.backgroundColor = backgroundColors[index % backgroundColors.length];
                        const text = document.createElement('span');
                        text.textContent = label;
                        item.appendChild(colorBox);
                        item.appendChild(text);
                        legendContainer.appendChild(item);
                    });
                }

          
            
            

            // --- Z-INDEX MANAGEMENT FOR OVERLAPPING CARDS ---
            let highestZIndex = 10;
            function bringCardToFront(event) {
                const card = event.target.closest('.timeline-event');
                if (card) {
                    highestZIndex++;
                    card.style.zIndex = highestZIndex;
                }
            }
            
        
            const handle = document.getElementById('dragHandle');
            const sidebar = document.getElementById('treeSidebar');
            
            // A flag to check if we are currently dragging
            let isDragging = false;
            let startX;
            let startWidth;

            // When the mouse button is pressed down on the handle
            handle.addEventListener('mousedown', function (e) {
                // Prevent default browser actions, like text selection
                e.preventDefault();
                
                isDragging = true;
                startX = e.clientX; // Record the initial mouse X position
                startWidth = parseInt(document.defaultView.getComputedStyle(sidebar).width, 10); // Record the initial width of the sidebar
                
                // Add listeners to the whole document to track mouse movement and release
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
                
                // Add a style to the body to prevent text selection during drag
                document.body.style.userSelect = 'none';
                document.body.style.pointerEvents = 'none'; // Prevents other elements from interfering
            });

            // When the mouse is moved anywhere on the page
            function handleMouseMove(e) {
                if (!isDragging) return;
                
                // Calculate the distance the mouse has moved
                const dx = e.clientX - startX;
                
                // Calculate the new width and apply it.
                // We enforce a minimum and maximum width to prevent the layout from breaking.
                const newWidth = Math.max(200, Math.min(600, startWidth + dx));
                sidebar.style.width = newWidth + 'px';
            }

            // When the mouse button is released
            function handleMouseUp() {
                if (!isDragging) return;
                
                isDragging = false;
                
                // IMPORTANT: Remove the listeners from the document
                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);

                // Restore the default body styles
                document.body.style.userSelect = '';
                document.body.style.pointerEvents = '';
            }
             // --- NEW: DOM Element References ---
         const landingView = document.getElementById('landingView');
        const learningView = document.getElementById('learningView');
        const newTopicModal = document.getElementById('newTopicModal');
        // --- NEW: Event Listeners ---
document.getElementById('newTopicBtn').addEventListener('click', openNewTopicModal);
document.getElementById('cancelTopicBtn').addEventListener('click', closeNewTopicModal);
document.getElementById('submitTopicBtn').addEventListener('click', handleNewTopicSubmit);
document.getElementById('mainMenuBtn').addEventListener('click', () => {
    renderTopicCards(); // Redraw the landing page

    switchView('landingView');
});
// Handle clicks on the sophistication slider
document.getElementById('sophisticationSlider').addEventListener('click', (e) => {
    if (e.target.classList.contains('sophistication-option')) {
        // Remove 'active' from all options
        document.querySelectorAll('.sophistication-option').forEach(opt => opt.classList.remove('active'));
        // Add 'active' to the clicked option
        e.target.classList.add('active');
    }
});

// Close modal if user clicks on the overlay background
newTopicModal.addEventListener('click', (e) => {
    if (e.target === newTopicModal) {
        closeNewTopicModal();
    }
});

// Initialize the app on the landing page
// --- FINAL REVISION: Tooltip Repositioning Logic ---
const mainContent = document.getElementById('mainContent');

mainContent.addEventListener('mouseover', (event) => {
    const term = event.target.closest('.technical-term');
    if (!term) return;

    const tooltip = term.querySelector('.term-tooltip');
    if (!tooltip) return;

    // Make the tooltip visible
    tooltip.classList.add('visible');

    // Defer the measurement to prevent timing issues, ensuring the element is rendered.
    requestAnimationFrame(() => {
        // **THE FIX**: Get the bounding box of the main content area, which is the actual boundary.
        const containerRect = mainContent.getBoundingClientRect();
        const tooltipRect = tooltip.getBoundingClientRect();
        const PADDING = 15; // A little more space from the edge

        let deltaX = 0;
        
        // Check for overflow against the CONTAINER's right edge
        if (tooltipRect.right > containerRect.right - PADDING) {
            deltaX = (containerRect.right - PADDING) - tooltipRect.right;
        } 
        // Check for overflow against the CONTAINER's left edge
        else if (tooltipRect.left < containerRect.left + PADDING) {
            deltaX = (containerRect.left + PADDING) - tooltipRect.left;
        }

        // Apply the calculated shift if necessary
        if (deltaX !== 0) {
            tooltip.style.transform = `translateX(${deltaX}px)`;
        }
    });
});

mainContent.addEventListener('mouseout', (event) => {
    const term = event.target.closest('.technical-term');
    if (!term) return;

    const tooltip = term.querySelector('.term-tooltip');
    if (tooltip) {
        // Hide the tooltip
        tooltip.classList.remove('visible');
        // Reset the transform so it can be recalculated on the next hover
        tooltip.style.transform = '';
    }
});
// --- END OF FINAL REVISION ---


        });
        // --- FIX FOR TREE NAVIGATION ---
document.getElementById('treeContainer').addEventListener('click', (e) => {
    // Find the closest parent element that is a tree node
    const nodeElement = e.target.closest('.tree-node-content');
    
    // If we found a node and it has a data-node-id, navigate to it
    if (nodeElement && nodeElement.dataset.nodeId) {
        navigateToNode(nodeElement.dataset.nodeId);
    }
});
        // Checks if all children of a node are read and updates the parent's status
        function updateParentReadStatus(parentNode) {
            // Do nothing if there's no parent or the parent has no children
            if (!parentNode || !parentNode.children || parentNode.children.length === 0) {
                return;
            }

            // Check if every child node is marked as san
            const allChildrenAreRead = parentNode.children.every(child => child.isRead);

            // Update the parent's read status
            parentNode.isRead = allChildrenAreRead;
        }
        // --- STAGE 1 & 2: Get the button and listen for a click ---

// Get a reference to the HTML button with the id 'googleSignInBtn'
const googleSignInBtn = document.getElementById('googleSignInBtn');

// Tell the button to listen for a 'click' and run the code inside when it happens
googleSignInBtn.addEventListener('click', () => {
    
    // --- STAGE 3: Define the action to perform on click ---

    // Clear out any old error messages from previous attempts
    authError.textContent = ''; 

    // This command opens the Google Sign-in popup window
    auth.signInWithPopup(googleProvider)

        // --- STAGE 4: Handle the result (Success or Failure) ---

        // The .then() block runs ONLY if the sign-in was successful
        .then((result) => {
            console.log("Google Sign-in successful!", result.user.displayName);

            // IMPORTANT: You don't need to do anything else here to show the app.
            // The 'onAuthStateChanged' function is always listening in the background.
            // It will automatically detect this successful login and show your app.
        })

        // The .catch() block runs ONLY if there was an error
        .catch((error) => {
            console.error("Google Sign-in error:", error.message);
            
            // It's helpful to show the error message to the user on the screen.
            authError.textContent = error.message; 
        });
});
/**
 * Normalizes an equation string. If it's a simple expression of x,
 * it prepends 'y = '. Otherwise, it returns the original string.
 * @param {string} expressionString - The raw equation string.
 * @returns {string} The normalized equation string.
 */
 function normalizeEquation(expressionString) {
    const processed = expressionString.trim();
    const parts = processed.split('=');

    // If no '=' is present and it looks like a function of x, assume y = f(x).
    if (parts.length === 1) {
        const singlePart = parts[0];
        if (singlePart.includes('x') && !singlePart.includes('y')) {
            return `y = ${singlePart}`;
        }
    }
    
    // If it already has an equals sign, or isn't a simple f(x), return it as is.
    return processed;
}
function renderImplicitPlotter(container, dataString) {
    // Generate Legend HTML using the new helper function
    const equationStrings = dataString.split(';').filter(s => s.trim() !== '');

    const legendHTML = equationStrings.map((eq, index) => {
        const color = PLOT_COLORS[index % PLOT_COLORS.length];
        const normalizedEq = normalizeEquation(eq); // Use the helper for the visible text
        return `
            <div class="plot-legend-item">
                <span class="plot-legend-color-swatch" style="background-color: ${color};"></span>
                <span class="plot-legend-equation-text">$${normalizedEq.trim()}$</span>
            </div>
        `;
    }).join('');

    // Create the plotter's HTML structure
    container.innerHTML = `
        <div id="graphContainer">
            <canvas id="functionGraph"></canvas>
            <div class="zoom-controls">
                <button id="zoomInBtn" class="zoom-btn" title="Zoom in">+</button>
                <button id="zoomOutBtn" class="zoom-btn" title="Zoom out">-</button>
            </div>
        </div>
        <div class="equation-input-wrapper">
            <div class="plot-legend-container">${legendHTML}</div>
            <p id="error-message"></p>
        </div>
    `;

    // --- Re-initialize the plotter logic ---
    const canvas = container.querySelector('#functionGraph');
    const ctx = canvas.getContext('2d');
    const errorMessage = container.querySelector('#error-message');
    const graphContainer = container.querySelector('#graphContainer');

    let scale = 40, origin = { x: 0, y: 0 }, view = { minX: -10, maxX: 10, minY: -10, maxY: 10 };
    let isGraphDragging = false, lastMousePos = { x: 0, y: 0 };
    let plotObjects = [];
    let plotTimeout;

    const resizeObserver = new ResizeObserver(entries => {
        if (!entries || !entries.length) return;
        const { width, height } = entries[0].contentRect;
        canvas.width = width; canvas.height = height;
        if(width === 0 || height === 0) return;
        origin.x = width / 2; origin.y = height / 2;
        updateView();
        calculateAndDrawEquations();
    });
    resizeObserver.observe(graphContainer);

    const toScreenX = (x) => origin.x + x * scale;
    const toScreenY = (y) => origin.y - y * scale;
    const toGraphX = (x) => (x - origin.x) / scale;
    const toGraphY = (y) => (y - origin.y) / -scale;

    function updateView() {
        view.minX = toGraphX(0); view.maxX = toGraphX(canvas.width);
        view.minY = toGraphY(canvas.height); view.maxY = toGraphY(0);
    }

    function drawGrid() {
        if (!ctx) return;
        ctx.beginPath(); ctx.strokeStyle = '#e5e7eb'; ctx.lineWidth = 1;
        const step = Math.pow(10, Math.floor(Math.log10(70 / scale)));
        for (let x = Math.floor(view.minX / step) * step; x < view.maxX; x += step) {
            const screenX = Math.round(toScreenX(x));
            ctx.moveTo(screenX, 0); ctx.lineTo(screenX, canvas.height);
        }
        for (let y = Math.floor(view.minY / step) * step; y < view.maxY; y += step) {
            const screenY = Math.round(toScreenY(y));
            ctx.moveTo(0, screenY); ctx.lineTo(canvas.width, screenY);
        }
        ctx.stroke();
    }

    function drawAxes() {
        ctx.beginPath(); ctx.strokeStyle = '#374151'; ctx.lineWidth = 1.5;
        ctx.moveTo(0, origin.y); ctx.lineTo(canvas.width, origin.y);
        ctx.moveTo(origin.x, 0); ctx.lineTo(origin.x, canvas.height);
        ctx.stroke();
    }

    function drawLabels() {
            ctx.font = "12px sans-serif"; ctx.fillStyle = "#6b7280";
            ctx.textAlign = "center"; ctx.textBaseline = "top";
            const step = Math.pow(10, Math.floor(Math.log10(70/scale)));
            for (let x = Math.floor(view.minX / step) * step; x < view.maxX; x += step) {
                if (Math.abs(x) < 1e-9) continue;
                ctx.fillText(x.toFixed(2).replace(/\.?0+$/, ''), toScreenX(x), origin.y + 5);
            }
            ctx.textAlign = "right"; ctx.textBaseline = "middle";
            for (let y = Math.floor(view.minY/step) * step; y < view.maxY; y += step) {
                if (Math.abs(y) < 1e-9) continue;
                ctx.fillText(y.toFixed(2).replace(/\.?0+$/, ''), origin.x - 5, toScreenY(y));
            }
    }

    function drawPlot(objects) {
        if (!objects) return;
        ctx.lineWidth = 2.5;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        objects.forEach(obj => {
            if (!obj || !obj.paths || obj.paths.length === 0) return;

            ctx.beginPath();
            ctx.strokeStyle = obj.color;

            obj.paths.forEach(path => {
                if (path.length < 2) return;
                ctx.moveTo(toScreenX(path[0].x), toScreenY(path[0].y));
                for (let i = 1; i < path.length; i++) { ctx.lineTo(toScreenX(path[i].x), toScreenY(path[i].y)); }
            });
            ctx.stroke();
        });
    }

    // --- THIS IS THE CORRECTED, SIMPLIFIED VERSION INSIDE THE FUNCTION ---
    function calculatePaths(expression) {
        if (!expression) return [];
        try {
            const processedExpression = normalizeEquation(expression);

            const finalParts = processedExpression.split('=');
            if (finalParts.length !== 2) {
                throw new Error("Equation must have one '=' sign or be an expression of x (e.g., sin(x)).");
            }

            const equationNode = math.parse(`(${finalParts[0]}) - (${finalParts[1]})`);
            const compiledEquation = equationNode.compile();
            const derivativeX = math.derivative(equationNode, 'x').compile();
            const derivativeY = math.derivative(equationNode, 'y').compile();
            const resolution = 75, xStep = (view.maxX - view.minX) / resolution, yStep = (view.maxY - view.minY) / resolution;
            const grid = [], visited = new Set();
            for (let i = 0; i <= resolution; i++) {
                grid[i] = [];
                for (let j = 0; j <= resolution; j++) { grid[i][j] = compiledEquation.evaluate({ x: view.minX + j * xStep, y: view.minY + i * yStep });}
            }
            const allPaths = [];
            for (let i = 0; i < resolution; i++) {
                for (let j = 0; j < resolution; j++) {
                    const key = `${i},${j}`; if(visited.has(key)) continue;
                    const a = grid[i][j], b = grid[i+1][j];
                    if (Math.sign(a) !== Math.sign(b)) {
                        visited.add(key);
                        const startY = view.minY + (i + a / (a - b)) * yStep, startX = view.minX + j * xStep;
                        let path = tracePath({ x: startX, y: startY }, compiledEquation, derivativeX, derivativeY, visited, xStep, yStep);
                        if (path.length > 1) allPaths.push(path);
                    }
                }
            }
            return allPaths;
        } catch (error) {
            errorMessage.textContent = `Error in "${expression.trim()}": Invalid equation.`;
            console.error("Plotting Error:", error);
            return [];
        }
    }

    function tracePath(startPoint, func, derivX, derivY, visited, dx, dy) {
        const path = [startPoint]; let currentPoint = startPoint;
        const stepSize = Math.min(dx, dy) / 2, maxSteps = 500;
        for(let k = 0; k < maxSteps; k++) {
            const gradX = derivX.evaluate(currentPoint), gradY = derivY.evaluate(currentPoint);
            const mag = Math.sqrt(gradX * gradX + gradY * gradY); if (mag < 1e-9) break;
            const dirX = -gradY / mag, dirY = gradX / mag;
            let nextPoint = { x: currentPoint.x + dirX * stepSize, y: currentPoint.y + dirY * stepSize };
            const fVal = func.evaluate(nextPoint), newGradX = derivX.evaluate(nextPoint), newGradY = derivY.evaluate(nextPoint);
            const gradMagSq = newGradX * newGradX + newGradY * newGradY;
            if (gradMagSq > 1e-9) {
                const correction = fVal / gradMagSq;
                nextPoint.x -= correction * newGradX; nextPoint.y -= correction * newGradY;
            }
            if (nextPoint.x < view.minX || nextPoint.x > view.maxX || nextPoint.y < view.minY || nextPoint.y > view.maxY) break;
            path.push(nextPoint); currentPoint = nextPoint;
            const gridI = Math.floor((currentPoint.y - view.minY) / dy), gridJ = Math.floor((currentPoint.x - view.minX) / dx);
            visited.add(`${gridI},${gridJ}`);
        }
        return path;
    }

    function draw() { requestAnimationFrame(() => { if(!ctx) return; ctx.clearRect(0, 0, canvas.width, canvas.height); drawGrid(); drawAxes(); drawLabels(); drawPlot(plotObjects); }); }

    function zoomOnPoint(zoomFactor, centerX, centerY) {
        const graphX = toGraphX(centerX);
        const graphY = toGraphY(centerY);
        scale *= zoomFactor;
        origin.x = centerX - graphX * scale;
        origin.y = centerY + graphY * scale;
        updateView();
        draw();
        clearTimeout(plotTimeout);
        plotTimeout = setTimeout(calculateAndDrawEquations, 150);
    }

    function calculateAndDrawEquations() {
        errorMessage.textContent = '';
        const currentEquationStrings = dataString.split(';').filter(s => s.trim() !== '');
        plotObjects = [];
        currentEquationStrings.forEach((eq, index) => {
            const paths = calculatePaths(eq);
            if (paths.length > 0) {
                plotObjects.push({
                    paths: paths,
                    color: PLOT_COLORS[index % PLOT_COLORS.length]
                });
            }
        });
        draw();
    }

    canvas.addEventListener('mousedown', (e) => { isGraphDragging = true; lastMousePos = { x: e.offsetX, y: e.offsetY }; });
    canvas.addEventListener('mousemove', (e) => { if (!isGraphDragging) return; const dx = e.offsetX - lastMousePos.x, dy = e.offsetY - lastMousePos.y; origin.x += dx; origin.y += dy; lastMousePos = { x: e.offsetX, y: e.offsetY }; updateView(); draw(); });
    canvas.addEventListener('mouseup', () => { if (!isGraphDragging) return; isGraphDragging = false; calculateAndDrawEquations(); });
    canvas.addEventListener('mouseleave', () => { if(isGraphDragging) { isGraphDragging = false; calculateAndDrawEquations(); } });
    canvas.addEventListener('wheel', (e) => { e.preventDefault(); const zoomFactor = e.deltaY < 0 ? 1.2 : 1 / 1.2; zoomOnPoint(zoomFactor, e.offsetX, e.offsetY); });

    container.querySelector('#zoomInBtn').addEventListener('click', () => { zoomOnPoint(1.3, canvas.width / 2, canvas.height / 2); });
    container.querySelector('#zoomOutBtn').addEventListener('click', () => { zoomOnPoint(1 / 1.3, canvas.width / 2, canvas.height / 2); });

    // Initial calculation
    calculateAndDrawEquations();
    triggerMathRendering(container);
}
/**
 * A helper function to measure the pixel width of a string of text.
 * @param {string} text - The text to measure.
 * @returns {number} The width of the text in pixels.
 */
 function measureTextWidth(text) {
    const tempSpan = document.createElement('span');
    tempSpan.style.fontSize = '15px';
    tempSpan.style.fontWeight = '600';
    tempSpan.style.visibility = 'hidden';
    tempSpan.style.position = 'absolute';
    tempSpan.style.whiteSpace = 'nowrap';
    tempSpan.textContent = text;
    document.body.appendChild(tempSpan);
    const width = tempSpan.offsetWidth;
    document.body.removeChild(tempSpan);
    return width;
}

/**
 * Handles the click on a timeline card.
 * @param {object} clickedItem - The data object for the clicked timeline item.
 * @param {Array} allItems - The array of all items on the timeline for context.
 */
function handleTimelineCardClick(clickedItem, allItems) {
    // Check if a node for this event already exists
    const existingNode = currentTreeNode.children.find(child => child.fullTitle === clickedItem.name);
    if (existingNode) {
        navigateToNode(existingNode.id);
        return;
    }
    
    // If not, show loader and fetch the new content
    showSkeletonLoader();
    elaborateOnTimelineEvent(clickedItem, allItems);
}

/**
 * Calls the API to get details about a specific timeline event.
 * @param {object} clickedItem - The data object for the clicked timeline item.
 * @param {Array} allItems - The array of all items on the timeline for context.
 */
// =================== START: REPLACE THIS FUNCTION ===================
/**
 * Calls the API to get details about a specific timeline event, now including definitions.
 * @param {object} clickedItem - The data object for the clicked timeline item.
 * @param {Array} allItems - The array of all items on the timeline for context.
 */
 async function elaborateOnTimelineEvent(clickedItem, allItems) {
    const overallTopic = currentTreeNode.fullTitle;
    const eventName = clickedItem.name;
    const otherEvents = allItems.filter(item => item.name !== eventName).map(item => item.name).join(', ');
    const rootNode = treeStructure;

    // Assemble the full context object for the prompt
    const promptParams = {
        overallTopic: rootNode.fullTitle,
        eventName: eventName,
        otherEvents: otherEvents,
        sophistication: rootNode.sophistication,
        // The "current node" is the one displaying the timeline when the user clicks
        currentNodeTitle: currentTreeNode.fullTitle,
        journeyStructure: buildTreeStructureString(rootNode, currentTreeNode.id),
        lineageContent: getLineageContent(currentTreeNode)
    };

    const prompt = getTimelineElaborationPrompt(promptParams);

    try {
        const tempConversation = [
            { role: "system", content: "You are an educational assistant." },
            { role: "user", content: prompt }
        ];
        
        const response = await fetch(BACKEND_URL + '/chat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ messages: tempConversation })
        });

        if (!response.ok) throw new Error('API request failed');

        const result = await response.json();
        const botResponseText = result.choices[0].message.content;

        const structuredResponse = sanitizeAndParseJson(botResponseText);
        const explanation = structuredResponse.explanation || "No explanation provided.";
        const definitions = structuredResponse.definitions || [];

        const parsed = parseResponse(explanation, definitions);
        parsed.showTellMeMore = true; 

        const newNode = createTreeNode(eventName, parsed, currentTreeNode);
        newNode.isTimelineElaboration = true;

        await saveTopicsToFirestore();
        updateTreeVisualization();
        navigateToNode(newNode.id);

    } catch (error) {
        console.error("Error elaborating on timeline event:", error);
        showError("Failed to get details for this timeline event.");
    }
}
// ==================== END: REPLACE THIS FUNCTION ====================
// ======================= START: ADD THIS NEW FUNCTION =======================
/**
 * Finds and converts unnecessarily-wrapped LaTeX for simple text and percentages
 * back into plain text, leaving real equations untouched.
 * @param {string} text The text content from the AI.
 * @returns {string} The cleaned text.
 */
 /**
 * Finds and converts unnecessarily-wrapped LaTeX for simple text and percentages
 * back into plain text, leaving real equations untouched.
 * @param {string} text The text content from the AI.
 * @returns {string} The cleaned text.
 */
 function cleanUnnecessaryLatex(text) {
    if (!text) return '';

    // This regex finds all content wrapped in $...$ delimiters.
    return text.replace(/\$(.*?)\$/g, (originalMatch, content) => {
        const trimmedContent = content.trim();

        // Pattern 1: Check for the \text{...} wrapper.
        const textMatch = trimmedContent.match(/^\\text\{(.*)\}$/);
        if (textMatch) {
            const innerText = textMatch[1];
            // If the content inside is just simple text (letters, numbers, spaces, basic punctuation)
            // then we "unwrap" it from LaTeX.
            if (/^[\w\s%.,-]+$/.test(innerText)) {
                // Convert LaTeX's escaped percent \\% back to a normal %
                return innerText.replace(/\\%/g, '%');
            }
        }

        // Pattern 2: Check for a simple percentage like "10\%" without the \text wrapper.
        if (/^-?[\d,.]+\\%$/.test(trimmedContent)) {
            return trimmedContent.replace(/\\%/g, '%');
        }

        // If it's not a simple pattern, it's probably a real equation.
        // Return the original match (e.g., "$E=mc^2$") to leave it alone.
        return originalMatch;
    });
}
// ======================== END: ADD THIS NEW FUNCTION ========================
/**
 * Elaborates on the current node's content in place, adding 2-3 new
 * paragraphs without creating a new node.
 */
 /**
 * Elaborates on the current node's content in place, adding new paragraphs
 * and identifying/highlighting new technical terms.
 */
/**
 * Elaborates on the current node's content in place, adding new paragraphs
 * and identifying/highlighting new technical terms.
 */
 /**
 * Elaborates on the current node's content in place, adding new paragraphs
 * and identifying/highlighting new technical terms.
 */
/**
 * Elaborates on the current node's content in place, adding new paragraphs
 * and identifying/highlighting new technical terms.
 */
 /**
 * Elaborates on the current node's content in place, adding new paragraphs
 * and identifying/highlighting new technical terms.
 */
/**
 * Elaborates on the current node's content in place, adding new paragraphs
 * and identifying/highlighting new technical terms.
 */
 /**
 * Elaborates on the current node's content in place, adding new paragraphs
 * and identifying/highlighting new technical terms.
 */
async function elaborateInPlace() {
    const currentNode = currentTreeNode;
    if (!currentNode || !currentNode.content || !currentNode.content.overview) {
        showError("There is no content here to elaborate on.");
        return;
    }

    showLoading(true);

    try {
        const rootNode = treeStructure;
        const sophistication = rootNode.sophistication || 'Detailed';
        const topicTitle = rootNode.fullTitle;
        const journeyStructure = buildTreeStructureString(rootNode, currentNode.id);
        const lineageContent = getLineageContent(currentNode);
        
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = currentNode.content.overview;
        const existingParagraphs = tempDiv.textContent || tempDiv.innerText || "";

        const elaborationPrompt = getInPlaceElaborationPrompt({
            topicTitle: rootNode.fullTitle,
            sophistication: rootNode.sophistication || 'Detailed',
            journeyStructure: buildTreeStructureString(rootNode, currentNode.id),
            lineageContent: getLineageContent(currentNode),
            currentNodeTitle: currentNode.fullTitle,
            existingParagraphs: (tempDiv.textContent || tempDiv.innerText || "")
        });

        conversationHistory.push({ role: "user", content: elaborationPrompt });
        pruneConversationHistory();

        const response = await fetch(BACKEND_URL + '/chat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ messages: conversationHistory })
        });

        if (!response.ok) throw new Error('API request failed');

        const result = await response.json();
        const botResponseText = result.choices[0].message.content;
        
        // ... inside elaborateInPlace
        let structuredResponse;
        try {
            // Use the new sanitizer to reliably get the JSON object
            structuredResponse = sanitizeAndParseJson(botResponseText);
        } catch (e) {
            console.error("---!!!--- JSON PARSING FAILED in elaborateInPlace ---!!!---");
            console.error("The code could not parse the following text:", botResponseText);
            console.error("The specific error was:", e.message);
            throw new Error("The AI returned data in a format that could not be read.");
        }
        
        const newText = structuredResponse.newText || "";
        const newDefinitions = structuredResponse.newDefinitions || [];
        const visualAssets = structuredResponse.visualAssets || [];

        if (newDefinitions.length > 0) {
            currentNode.content.definitions.push(...newDefinitions);
        }

        if (visualAssets.length > 0) {
            if (!currentNode.content.visualAssets) {
                currentNode.content.visualAssets = [];
            }
            currentNode.content.visualAssets.push(...visualAssets);
        }
        
        // --- START OF FIX 1 ---
        // First, normalize any literal '\\n' strings from the AI into actual newline characters.
        const normalizedNewText = newText.replace(/\\n/g, '\n');

        // Then, process the normalized text to create paragraphs and line breaks.
        const formattedNewText = normalizedNewText
            .split(/\n\s*\n/)
            .map(p => p.trim())
            .filter(p => p)
            .map(p => `<p>${p.replace(/\n/g, '<br>')}</p>`)
            .join('');
        // --- END OF FIX 1 ---

        const highlightedNewText = applyTermHighlighting(formattedNewText, newDefinitions);

        const separator = '<hr style="border: none; border-top: 1px solid #e5e7eb; margin: 25px 0;">';
        currentNode.content.overview += separator + highlightedNewText;
        
        displayContent(currentNode);
        await saveTopicsToFirestore();

    } catch (error) {
        console.error("Error during in-place elaboration:", error);
        showError(error.message || "Sorry, I was unable to generate more content for this section.");
    } finally {
        showLoading(false);
    }
}
// --- Add this snippet for Forgot Password functionality ---

// Get a reference to the new button
// --- Add this snippet for Forgot Password functionality ---

// Get a reference to the new button
const forgotPasswordBtn = document.getElementById('forgotPasswordBtn');

forgotPasswordBtn.addEventListener('click', () => {
    const email = emailInput.value;
    const authError = document.getElementById('authError');

    // Clear previous messages immediately
    authError.textContent = '';

    if (!email) {
        authError.style.color = '#dc2626'; // Red for error
        authError.textContent = 'Please enter your email address first.';
        return;
    }

    // Use Firebase's built-in function to send the reset email
    auth.sendPasswordResetEmail(email)
        .then(() => {
            // Success! Let the user know.
            authError.style.color = '#16a34a'; // Green for success
            // CHANGE 3: Shortened confirmation message
            authError.textContent = 'Password reset email sent.';

            // CHANGE 4: Make the message disappear after 5 seconds
            setTimeout(() => {
                authError.textContent = '';
            }, 5000);
        })
        .catch((error) => {
            // An error happened. Show the error message from Firebase.
            authError.style.color = '#dc2626'; // Red for error
            authError.textContent = error.message;

            // Also make error messages disappear after 5 seconds
            setTimeout(() => {
                authError.textContent = '';
            }, 5000);
        });
});
// --- Add this script for the new verification view buttons ---

document.getElementById('resendVerificationBtn').addEventListener('click', () => {
    const user = auth.currentUser;
    const resendBtn = document.getElementById('resendVerificationBtn');
    const resendMsg = document.getElementById('resendMessage');

    if (user) {
        user.sendEmailVerification()
            .then(() => {
                resendMsg.textContent = 'A new verification email has been sent.';
                resendBtn.disabled = true; // Prevent spamming
                // Re-enable the button after 20 seconds
                setTimeout(() => {
                    resendMsg.textContent = '';
                    resendBtn.disabled = false;
                }, 20000);
            }).catch(error => {
                resendMsg.textContent = error.message;
            });
    }
});

// --- Replace the 'checkVerificationBtn' listener with this corrected version ---

document.getElementById('checkVerificationBtn').addEventListener('click', () => {
    const user = auth.currentUser;
    const resendMsg = document.getElementById('resendMessage');

    // Give the user immediate feedback
    resendMsg.style.color = '#4b5563'; // Use a neutral color for status
    resendMsg.textContent = 'Checking verification status...';

    if (user) {
        // Reload the user's data from Firebase to get the latest status
        user.reload().then(() => {
            // The user object is now updated with the latest data from the server.
            
            if (auth.currentUser.emailVerified) {
                // SUCCESS: The user is now verified.
                // The most reliable way to proceed is to refresh the page.
                // This will cause onAuthStateChanged to run again, and since the
                // user is now verified, it will grant them access correctly.
                resendMsg.textContent = 'Success! Loading the app...';
                location.reload();

            } else {
                // FAILURE: The user is still not verified.
                resendMsg.style.color = '#dc2626'; // Red for error
                resendMsg.textContent = 'Email not verified. Please click the link in your inbox.';
                // Clear the message after a few seconds
                setTimeout(() => {
                    resendMsg.textContent = '';
                }, 5000);
            }
        }).catch(error => {
            // This handles cases where the reload call itself fails (e.g., network issues)
            resendMsg.style.color = '#dc2626';
            resendMsg.textContent = 'Could not check status. Please try again.';
            console.error('Error on user.reload():', error);
            setTimeout(() => {
                resendMsg.textContent = '';
            }, 5000);
        });
    }
});

document.getElementById('signOutFromVerifyBtn').addEventListener('click', () => {
    auth.signOut();
});
// --- NEW: VEGA-LITE GRAPH LAB LOGIC ---

// 1. Get references to all the new HTML elements
const graphLabBtn = document.getElementById('graphLabBtn');
const graphLabModal = document.getElementById('graphLabModal');
const cancelGraphBtn = document.getElementById('cancelGraphBtn');
const submitGraphBtn = document.getElementById('submitGraphBtn');
const graphPromptInput = document.getElementById('graphPromptInput');

const graphDisplayModal = document.getElementById('graphDisplayModal');
const closeGraphDisplayBtn = document.getElementById('closeGraphDisplayBtn');
const vegaContainer = document.getElementById('vegaContainer');

// 2. Add event listeners to control the modals
graphLabBtn.addEventListener('click', () => graphLabModal.classList.add('active'));
cancelGraphBtn.addEventListener('click', () => graphLabModal.classList.remove('active'));
closeGraphDisplayBtn.addEventListener('click', () => graphDisplayModal.classList.remove('active'));

// Close modals if the user clicks on the dark overlay
graphLabModal.addEventListener('click', (e) => {
    if (e.target === graphLabModal) graphLabModal.classList.remove('active');
});
graphDisplayModal.addEventListener('click', (e) => {
    if (e.target === graphDisplayModal) graphDisplayModal.classList.remove('active');
});

// In index.html, inside the <script type="module"> block

// This is a global variable to hold our chart instance
window.myChart = null;

submitGraphBtn.addEventListener('click', async () => {
    const userPrompt = graphPromptInput.value.trim();
    if (!userPrompt) {
        alert("Please describe the graph you want to create.");
        return;
    }

    submitGraphBtn.disabled = true;
    submitGraphBtn.innerHTML = '<span class="loading-spinner"></span> Generating...';

    try {
        // Step 1: Use the new prompt builder for Chart.js
        const prompt = getChartJsCodePrompt(userPrompt);

        const chartConversation = [
            { role: "system", content: "You are a Chart.js code generation assistant." },
            { role: "user", content: prompt }
        ];

        const response = await fetch(BACKEND_URL + '/chat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ messages: chartConversation, purpose: 'graph_lab' })
        });

        if (!response.ok) throw new Error('API request failed');

        const result = await response.json();
        const botResponseText = result.choices[0].message.content;

        // Step 2: Extract the pure JavaScript code from the AI's response
        const codeBlockRegex = /```javascript\n([\s\S]*?)\n```/;
        const match = botResponseText.match(codeBlockRegex);
        if (!match || !match[1]) {
            throw new Error("AI did not return a valid JavaScript code block.");
        }
        const chartCode = match[1];

        // Hide the input modal and show the graph display modal
        graphLabModal.classList.remove('active');
        graphDisplayModal.classList.add('active');

        // Step 3: Display the generated code in the <pre><code> block for the user
        document.getElementById('chartJsCodeBlock').textContent = chartCode;

        // Step 4: Execute the generated code
        const canvasId = 'chartJsCanvas';
        const ctx = document.getElementById(canvasId).getContext('2d');
        
        // Destroy the previous chart instance if it exists
        if (window.myChart) {
            window.myChart.destroy();
        }
        
        // Safely execute the AI-generated code.
        // We pass 'ctx' as an argument for the code to use.
        // The generated code is wrapped in a function and then called.
        const generatedFunction = new Function('ctx', chartCode);
        window.myChart = generatedFunction(ctx);


    } catch (error) {
        console.error("Error generating Chart.js code:", error);
        showError("Sorry, there was an error creating the graph. The AI may have returned an invalid format. Please try again.");
    } finally {
        submitGraphBtn.disabled = false;
        submitGraphBtn.textContent = 'Generate Graph';
    }
});

/**
 * Renders a Vega-Lite chart into a specified container.
 * @param {string} containerId The ID of the div where the chart should be rendered.
 * @param {object} spec The Vega-Lite JSON specification.
 */
async function renderVegaLiteChart(containerId, spec) {
    const container = document.getElementById(containerId);
    if (!container) {
        console.error(`Container with id "${containerId}" not found.`);
        return;
    }
    
    try {
        // Use the vegaEmbed library function to render the chart
        await vegaEmbed(`#${containerId}`, spec, { "actions": true });
        console.log("Vega-Lite chart rendered successfully.");
    } catch (error) {
        console.error("Vega-Lite Rendering Error:", error);
        container.innerHTML = `<p style="color: #dc2626; font-weight: 500;">Could not render the graph. The specification provided by the AI was invalid.</p><pre style="white-space: pre-wrap; background: #f3f4f6; padding: 10px; border-radius: 8px; margin-top: 10px;">${JSON.stringify(spec, null, 2)}</pre>`;
    }
}
    </script>
    <!-- New Topic Modal -->
<div class="modal-overlay" id="newTopicModal">
    <div class="modal-content">
        <h2>Start a New Topic</h2>
        <label for="topicInput">I want to learn about:</label>
        <input type="text" id="topicInput" class="modal-input" placeholder="e.g., 'Quantum Physics' or 'History of Imperial Rome'">

        <label>Sophistication Level:</label>
        <div class="sophistication-slider" id="sophisticationSlider">
            <div class="sophistication-option active" data-level="Simple">Simple</div>
            <div class="sophistication-option" data-level="Detailed">Detailed</div>
            <div class="sophistication-option" data-level="Expert">Expert</div>
        </div>

        <div class="modal-actions">
            <button class="modal-btn cancel" id="cancelTopicBtn">Cancel</button>
            <button class="modal-btn submit" id="submitTopicBtn">Submit</button>
        </div>
    </div>
</div>
<div class="modal-overlay" id="quizModal">
    <div class="modal-content" style="max-width: 700px;">
        <h2 id="quizTitle">Topic Quiz</h2>
        <div id="quizArea">
            <p id="quizQuestionText" style="font-size: 18px; margin-bottom: 25px;"></p>
            <div id="quizOptions" class="cards-grid" style="grid-template-columns: 1fr; gap: 10px;">
                </div>
            <p id="quizFeedback" style="margin-top: 20px; font-weight: 600;"></p>
        </div>
        <div id="quizResults" style="display: none;">
            <h3>Quiz Complete!</h3>
            <p id="quizScoreText" style="font-size: 24px; margin: 20px 0;"></p>
        </div>
        <div class="modal-actions" style="margin-top: 30px;">
             <button class="modal-btn cancel" onclick="closeQuizModal()">Close</button>
             <button class="modal-btn submit" id="quizSubmitBtn">Submit</button>
        </div>
    </div>
</div>
<div class="modal-overlay" id="deleteConfirmModal">
    <div class="modal-content">
        <h2>Confirm Deletion</h2>
        <p style="margin-bottom: 30px; font-size: 16px; color: #4b5563; text-align: center;">
            Are you sure you want to permanently delete this topic and all of its content? This action cannot be undone.
        </p>
        <div class="modal-actions">
            <button class="modal-btn cancel" id="cancelDeleteBtn">Cancel</button>
            <button class="modal-btn delete" id="confirmDeleteBtn">Confirm Delete</button>
        </div>
    </div>
</div>
<div class="modal-overlay" id="differenceModal">
    <div class="modal-content" style="max-width: 700px;">
        <span class="close-modal-btn" id="closeDifferenceModal">&times;</span>
        <h2>Understanding the difference</h2>
        <div class="difference-container">
            <div class="difference-column">
                <h3>Tell me more</h3>
                <p>Tell me more expands the current page and adds more paragraphs to further elaborate on the content in the previous ones. Best if you want just a bit more detail.</p>
                <div class="icon-placeholder">
                    <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevrons-down"><polyline points="7 13 12 18 17 13"></polyline><polyline points="7 6 12 11 17 6"></polyline></svg>
                </div>
            </div>
            <div class="vertical-separator"></div>
            <div class="difference-column">
                <h3>Go deeper on this</h3>
                <p>Go deeper on this splits this topic into several more categories, each of which can be explored further. Best if you want a rigorous expansion of the content you're currently reading.</p>
                <div class="icon-placeholder">
                    <svg xmlns="http://www.w3.org/2000/svg"
                         width="56" height="48"
                         viewBox="-2 0 28 24"
                         fill="none" stroke="currentColor"
                         stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                      <!-- all Xs now at +1 from original -->
                      <path d="M13 7v5
                               M4 12h18
                               M4 12v5
                               M13 12v5
                               M22 12v5" />
                      <!-- top circle at cx=13 -->
                      <circle cx="13" cy="4"  r="3" />
                      <!-- bottom circles at cx=4,13,22 -->
                      <circle cx="4"  cy="20" r="3" />
                      <circle cx="13" cy="20" r="3" />
                      <circle cx="22" cy="20" r="3" />
                    </svg>
                  </div>
                  
            </div>
        </div>
    </div>
</div>
<!-- Add this HTML at the end of your <body>, with the other modals -->
    <div class="modal-overlay" id="graphLabModal">
        <div class="modal-content" style="max-width: 600px;">
            <h2>Vega-Lite Graph Lab</h2>
            <p style="margin: 15px 0 25px; font-size: 16px; color: #4b5563; text-align: center;">
                Describe the graph you want to create in plain English.
            </p>
            <div class="input-wrapper">
                <textarea id="graphPromptInput" class="styled-textarea" placeholder="e.g., 'A sine wave and a cosine wave, with a dotted line showing their intersection at pi/4.'"></textarea>
            </div>
            <div class="modal-actions" style="margin-top: 25px;">
                <button class="modal-btn cancel" id="cancelGraphBtn">Cancel</button>
                <button class="modal-btn submit" id="submitGraphBtn">Generate Graph</button>
            </div>
        </div>
    </div>
    
    <div class="modal-overlay" id="graphDisplayModal">
        <div class="modal-content" style="max-width: 800px; width: 90%;">
            <span class="close-modal-btn" id="closeGraphDisplayBtn">&times;</span>
            <h2>Generated Graph</h2>
            
            <div style="position: relative; height:400px; width:100%; margin-top: 20px; margin-bottom: 20px;">
                <canvas id="chartJsCanvas"></canvas>
            </div>
    
            <details>
                <summary style="cursor: pointer; font-weight: 500; color: #4b5563;">View Generated Code</summary>
                <pre style="background: #f3f4f6; border-radius: 8px; padding: 15px; margin-top: 10px; max-height: 200px; overflow-y: auto;"><code id="chartJsCodeBlock" style="font-family: 'Courier New', Courier, monospace; font-size: 14px;"></code></pre>
            </details>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/vega@5"></script>
<script src="https://cdn.jsdelivr.net/npm/vega-lite@5"></script>
<script src="https://cdn.jsdelivr.net/npm/vega-embed@6"></script>
</body>
</html>